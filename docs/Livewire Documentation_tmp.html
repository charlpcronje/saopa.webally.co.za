<!-- docs/Livewire Documentation_tmp.html -->
<!DOCTYPE html>
<html>
<head>
<title>Livewire Documentation.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="analysis-report">Analysis Report</h2>
<table>
<thead>
<tr>
<th>No.</th>
<th>File</th>
<th>Lines</th>
<th>Words</th>
<th>AI Tokens</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>./Untitled 1.md</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>./Untitled 2.md</td>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>./Untitled.md</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>./__nav.md</td>
<td>82</td>
<td>482</td>
<td>755</td>
</tr>
<tr>
<td>5</td>
<td>./__outline.md</td>
<td>212</td>
<td>882</td>
<td>1042</td>
</tr>
<tr>
<td>6</td>
<td>./actions.md</td>
<td>1022</td>
<td>4625</td>
<td>7600</td>
</tr>
<tr>
<td>7</td>
<td>./alpine.md</td>
<td>343</td>
<td>1849</td>
<td>2955</td>
</tr>
<tr>
<td>8</td>
<td>./best-practices.md</td>
<td>2</td>
<td>19</td>
<td>20</td>
</tr>
<tr>
<td>9</td>
<td>./blade-components.md</td>
<td>66</td>
<td>104</td>
<td>387</td>
</tr>
<tr>
<td>10</td>
<td>./bundling.md</td>
<td>50</td>
<td>324</td>
<td>445</td>
</tr>
<tr>
<td>11</td>
<td>./component-hooks.md</td>
<td>148</td>
<td>487</td>
<td>658</td>
</tr>
<tr>
<td>12</td>
<td>./components.md</td>
<td>805</td>
<td>3297</td>
<td>5295</td>
</tr>
<tr>
<td>13</td>
<td>./computed-properties.md</td>
<td>346</td>
<td>1616</td>
<td>2473</td>
</tr>
<tr>
<td>14</td>
<td>./contribution-guide.md</td>
<td>186</td>
<td>1163</td>
<td>1490</td>
</tr>
<tr>
<td>15</td>
<td>./dirty.md</td>
<td>68</td>
<td>447</td>
<td>668</td>
</tr>
<tr>
<td>16</td>
<td>./downloads.md</td>
<td>109</td>
<td>320</td>
<td>580</td>
</tr>
<tr>
<td>17</td>
<td>./events.md</td>
<td>573</td>
<td>2115</td>
<td>3391</td>
</tr>
<tr>
<td>18</td>
<td>./forms.md</td>
<td>785</td>
<td>3298</td>
<td>5567</td>
</tr>
<tr>
<td>19</td>
<td>./how-livewire-works.md</td>
<td>183</td>
<td>383</td>
<td>806</td>
</tr>
<tr>
<td>20</td>
<td>./hydration.md</td>
<td>245</td>
<td>1123</td>
<td>1640</td>
</tr>
<tr>
<td>21</td>
<td>./installation.md</td>
<td>183</td>
<td>983</td>
<td>1447</td>
</tr>
<tr>
<td>22</td>
<td>./javascript.md</td>
<td>634</td>
<td>3028</td>
<td>4585</td>
</tr>
<tr>
<td>23</td>
<td>./lazy.md</td>
<td>253</td>
<td>1078</td>
<td>1618</td>
</tr>
<tr>
<td>24</td>
<td>./lifecycle-hooks.md</td>
<td>380</td>
<td>1585</td>
<td>2315</td>
</tr>
<tr>
<td>25</td>
<td>./loading.md</td>
<td>184</td>
<td>1041</td>
<td>1770</td>
</tr>
<tr>
<td>26</td>
<td>./locked.md</td>
<td>61</td>
<td>411</td>
<td>564</td>
</tr>
<tr>
<td>27</td>
<td>./morph.md</td>
<td>191</td>
<td>934</td>
<td>1693</td>
</tr>
<tr>
<td>28</td>
<td>./navigate.md</td>
<td>323</td>
<td>1899</td>
<td>2884</td>
</tr>
<tr>
<td>29</td>
<td>./nesting.md</td>
<td>629</td>
<td>2661</td>
<td>4214</td>
</tr>
<tr>
<td>30</td>
<td>./offline.md</td>
<td>35</td>
<td>184</td>
<td>272</td>
</tr>
<tr>
<td>31</td>
<td>./pagination.md</td>
<td>415</td>
<td>1629</td>
<td>2662</td>
</tr>
<tr>
<td>32</td>
<td>./polling.md</td>
<td>79</td>
<td>430</td>
<td>621</td>
</tr>
<tr>
<td>33</td>
<td>./properties.md</td>
<td>707</td>
<td>3056</td>
<td>4804</td>
</tr>
<tr>
<td>34</td>
<td>./quickstart.md</td>
<td>143</td>
<td>766</td>
<td>1098</td>
</tr>
<tr>
<td>35</td>
<td>./redirecting.md</td>
<td>132</td>
<td>512</td>
<td>803</td>
</tr>
<tr>
<td>36</td>
<td>./security.md</td>
<td>401</td>
<td>1552</td>
<td>2455</td>
</tr>
<tr>
<td>37</td>
<td>./session-properties.md</td>
<td>91</td>
<td>440</td>
<td>659</td>
</tr>
<tr>
<td>38</td>
<td>./synthesizers.md</td>
<td>247</td>
<td>863</td>
<td>1421</td>
</tr>
<tr>
<td>39</td>
<td>./teleport.md</td>
<td>50</td>
<td>289</td>
<td>435</td>
</tr>
<tr>
<td>40</td>
<td>./testing.md</td>
<td>708</td>
<td>2893</td>
<td>5338</td>
</tr>
<tr>
<td>41</td>
<td>./the-livewire-protocol.md</td>
<td>43</td>
<td>63</td>
<td>189</td>
</tr>
<tr>
<td>42</td>
<td>./understanding-nesting.md</td>
<td>219</td>
<td>915</td>
<td>1540</td>
</tr>
<tr>
<td>43</td>
<td>./upgrading.md</td>
<td>615</td>
<td>2785</td>
<td>4895</td>
</tr>
<tr>
<td>44</td>
<td>./uploads.md</td>
<td>434</td>
<td>2045</td>
<td>3256</td>
</tr>
<tr>
<td>45</td>
<td>./url.md</td>
<td>250</td>
<td>1162</td>
<td>1756</td>
</tr>
<tr>
<td>46</td>
<td>./validation.md</td>
<td>654</td>
<td>2684</td>
<td>4520</td>
</tr>
<tr>
<td>47</td>
<td>./volt.md</td>
<td>812</td>
<td>3004</td>
<td>5188</td>
</tr>
<tr>
<td>48</td>
<td>./wire-click.md</td>
<td>46</td>
<td>167</td>
<td>286</td>
</tr>
<tr>
<td>49</td>
<td>./wire-confirm.md</td>
<td>38</td>
<td>241</td>
<td>367</td>
</tr>
<tr>
<td>50</td>
<td>./wire-dirty.md</td>
<td>68</td>
<td>447</td>
<td>668</td>
</tr>
<tr>
<td>51</td>
<td>./wire-ignore.md</td>
<td>31</td>
<td>165</td>
<td>234</td>
</tr>
<tr>
<td>52</td>
<td>./wire-init.md</td>
<td>13</td>
<td>80</td>
<td>118</td>
</tr>
<tr>
<td>53</td>
<td>./wire-loading.md</td>
<td>205</td>
<td>1131</td>
<td>1933</td>
</tr>
<tr>
<td>54</td>
<td>./wire-model.md</td>
<td>271</td>
<td>1519</td>
<td>2537</td>
</tr>
<tr>
<td>55</td>
<td>./wire-navigate.md</td>
<td>29</td>
<td>174</td>
<td>273</td>
</tr>
<tr>
<td>56</td>
<td>./wire-offline.md</td>
<td>15</td>
<td>140</td>
<td>173</td>
</tr>
<tr>
<td>57</td>
<td>./wire-poll.md</td>
<td>79</td>
<td>437</td>
<td>634</td>
</tr>
<tr>
<td>58</td>
<td>./wire-stream.md</td>
<td>162</td>
<td>797</td>
<td>1314</td>
</tr>
<tr>
<td>59</td>
<td>./wire-submit.md</td>
<td>61</td>
<td>288</td>
<td>477</td>
</tr>
<tr>
<td>60</td>
<td>./wire-transition.md</td>
<td>184</td>
<td>971</td>
<td>1730</td>
</tr>
<tr>
<td>61</td>
<td>./rules/Casing rules.md</td>
<td>4</td>
<td>18</td>
<td>28</td>
</tr>
<tr>
<td>62</td>
<td>./rules/Referencing file names in a sentance.md</td>
<td>8</td>
<td>51</td>
<td>76</td>
</tr>
<tr>
<td>63</td>
<td>./rules/examples.md</td>
<td>6</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>64</td>
<td>./rules/questions.md</td>
<td>2</td>
<td>11</td>
<td>18</td>
</tr>
<tr>
<td>65</td>
<td>./rules/rules.md</td>
<td>53</td>
<td>260</td>
<td>344</td>
</tr>
<tr>
<td></td>
<td>Total</td>
<td>15378</td>
<td>68334</td>
<td>109996</td>
</tr>
</tbody>
</table>
<h2 id="total-counts-across-all-files-tokenizer-used-nltks-punkt-tokenizer">Total Counts Across All Files. Tokenizer Used: NLTK's Punkt Tokenizer</h2>
<ul>
<li>Total Lines: 15378</li>
<li>Total Words: 68334</li>
<li>Total AI Tokens: 109996</li>
</ul>
<h2 id="file-untitled-1md">File: Untitled 1.md</h2>
<pre class="hljs"><code><div>
</div></code></pre>
<h2 id="file-untitled-2md">File: Untitled 2.md</h2>
<pre class="hljs"><code><div>39"


</div></code></pre>
<h2 id="file-untitledmd">File: Untitled.md</h2>
<pre class="hljs"><code><div>
</div></code></pre>
<h2 id="file-navmd">File: __nav.md</h2>
<pre class="hljs"><code><div>---
Getting Started:
<span class="hljs-code">    Quickstart: { uri: /docs/quickstart, file: /quickstart.md }</span>
<span class="hljs-code">    Installation: { uri: /docs/installation, file: /installation.md }</span>
<span class="hljs-code">    Upgrade Guide: { uri: /docs/upgrading, file: /upgrading.md }</span>
Essentials:
<span class="hljs-code">    Components: { uri: /docs/components, file: /components.md }</span>
<span class="hljs-code">    Properties: { uri: /docs/properties, file: /properties.md }</span>
<span class="hljs-code">    Actions: { uri: /docs/actions, file: /actions.md }</span>
<span class="hljs-code">    Forms: { uri: /docs/forms, file: /forms.md }</span>
<span class="hljs-code">    Events: { uri: /docs/events, file: /events.md }</span>
<span class="hljs-code">    Lifecycle Hooks: { uri: /docs/lifecycle-hooks, file: /lifecycle-hooks.md }</span>
<span class="hljs-code">    Nesting Components: { uri: /docs/nesting, file: /nesting.md }</span>
<span class="hljs-code">    Testing: { uri: /docs/testing, file: /testing.md }</span>
Features:
<span class="hljs-code">    Alpine: { uri: /docs/alpine, file: /alpine.md }</span>
<span class="hljs-code">    Navigate: { uri: /docs/navigate, file: /navigate.md }</span>
<span class="hljs-code">    Lazy Loading: { uri: /docs/lazy, file: /lazy.md }</span>
<span class="hljs-code">    Validation: { uri: /docs/validation, file: /validation.md }</span>
<span class="hljs-code">    File Uploads: { uri: /docs/uploads, file: /uploads.md }</span>
<span class="hljs-code">    Pagination: { uri: /docs/pagination, file: /pagination.md }</span>
<span class="hljs-code">    URL Query Parameters: { uri: /docs/url, file: /url.md }</span>
<span class="hljs-code">    Computed Properties: { uri: /docs/computed-properties, file: /computed-properties.md }</span>
<span class="hljs-code">    Session Properties: { uri: /docs/session-properties, file: /session-properties.md }</span>
<span class="hljs-code">    Redirecting: { uri: /docs/redirecting, file: /redirecting.md }</span>
<span class="hljs-code">    File Downloads: { uri: /docs/downloads, file: /downloads.md }</span>
<span class="hljs-code">    Locked Properties: { uri: /docs/locked, file: /locked.md }</span>
<span class="hljs-code">    Request Bundling: { uri: /docs/bundling, file: /bundling.md }</span>
<span class="hljs-code">    Offline States: { uri: /docs/offline, file: /offline.md }</span>
<span class="hljs-code">    Teleport: { uri: /docs/teleport, file: /teleport.md }</span>
HTML Directives:
<span class="hljs-code">    wire:click: { uri: /docs/wire-click, file: /wire-click.md }</span>
<span class="hljs-code">    wire:submit: { uri: /docs/wire-submit, file: /wire-submit.md }</span>
<span class="hljs-code">    wire:model: { uri: /docs/wire-model, file: /wire-model.md }</span>
<span class="hljs-code">    wire:loading: { uri: /docs/wire-loading, file: /wire-loading.md }</span>
<span class="hljs-code">    wire:navigate: { uri: /docs/wire-navigate, file: /wire-navigate.md }</span>
<span class="hljs-code">    wire:dirty: { uri: /docs/wire-dirty, file: /wire-dirty.md }</span>
<span class="hljs-code">    wire:confirm: { uri: /docs/wire-confirm, file: /wire-confirm.md }</span>
<span class="hljs-code">    wire:transition: { uri: /docs/wire-transition, file: /wire-transition.md }</span>
<span class="hljs-code">    wire:init: { uri: /docs/wire-init, file: /wire-init.md }</span>
<span class="hljs-code">    wire:poll: { uri: /docs/wire-poll, file: /wire-poll.md }</span>
<span class="hljs-code">    wire:offline: { uri: /docs/wire-offline, file: /wire-offline.md }</span>
<span class="hljs-code">    wire:ignore: { uri: /docs/wire-ignore, file: /wire-ignore.md }</span>
<span class="hljs-code">    wire:stream: { uri: /docs/wire-stream, file: /wire-stream.md }</span>
Concepts:
<span class="hljs-code">    Morphing: { uri: /docs/morphing, file: /morph.md }</span>
<span class="hljs-code">    Hydration: { uri: /docs/hydration, file: /hydration.md }</span>
<span class="hljs-code">    Nesting: { uri: /docs/understanding-nesting, file: /understanding-nesting.md }</span>
Advanced:
<span class="hljs-code">    Security: { uri: /docs/security, file: /security.md }</span>
<span class="hljs-code">    JavaScript: { uri: /docs/javascript, file: /javascript.md }</span>
<span class="hljs-code">    Synthesizers: { uri: /docs/synthesizers, file: /synthesizers.md }</span>
<span class="hljs-code">    Contribution Guide: { uri: /docs/contribution-guide, file: /contribution-guide.md }</span>
Packages:
<span class="hljs-section">    Volt: { uri: /docs/volt, file: /volt.md }
---</span>

Concepts:
<span class="hljs-code">    How Livewire Works: { uri: /docs/ }</span>
<span class="hljs-code">    Understanding Nested Components: { uri: /docs/ }</span>
<span class="hljs-code">    Component Hydration: { uri: /docs/ }</span>
<span class="hljs-code">    Anatomy Of A Request: { uri: /docs/ }</span>
<span class="hljs-code">    DOM diff-patch: { uri: /docs/ }</span>
UI Components:
<span class="hljs-code">    Dropdown: { uri: /docs/dropdown, file: /dropdown.md }</span>
<span class="hljs-code">    Modal: { uri: /docs/modal, file: /modal.md }</span>
<span class="hljs-code">    Tabs: { uri: /docs/tabs, file: /tabs.md }</span>
Extending:
<span class="hljs-code">    Synthesizers: { uri: /docs/foo }</span>
<span class="hljs-code">    Wireables: { uri: /docs/foo }</span>
<span class="hljs-code">    Traits: { uri: /docs/foo }</span>
<span class="hljs-code">    Component Hooks: { uri: /docs/foo }</span>
<span class="hljs-code">    JavaScript Hooks: { uri: /docs/foo }</span>
Deeper Concepts:
<span class="hljs-code">    Best Practices: { uri: /docs/foo }</span>
<span class="hljs-code">    Performance Optimization: { uri: /docs/foo }</span>
<span class="hljs-code">    Component Code Reuse: { uri: /docs/foo }</span>
<span class="hljs-code">    Deployment: { uri: /docs/foo }</span>
<span class="hljs-code">    Troubleshooting: { uri: /docs/foo }</span>
<span class="hljs-code">    Security: { uri: /docs/foo }</span>
<span class="hljs-code">    API Reference: { uri: /docs/foo }</span>

</div></code></pre>
<h2 id="file-outlinemd">File: __outline.md</h2>
<pre class="hljs"><code><div>
Should I ditch the terms "hydrate" and "dehydrate"? Hydrate is normally used for hydrating frontend behavior from a frozen state. Well, we're just applying it to the backend. Serialize and unserialize are alternatives as are "sleep" and "wakeup".
<span class="hljs-bullet">
* </span>more examples
<span class="hljs-bullet">* </span>best practices
<span class="hljs-bullet">	* </span>https://github.com/michael-rubel/livewire-best-practices
<span class="hljs-bullet">* </span>performance best practices
<span class="hljs-bullet">* </span>security dangers
<span class="hljs-bullet">	* </span>https://forum.archte.ch/livewire/t/advanced-livewire-a-better-way-of-working-with-models
<span class="hljs-bullet">* </span>More readable font
<span class="hljs-bullet">* </span>"how livewire works"
<span class="hljs-bullet">* </span>Laravel bootcamp style tutorial
<span class="hljs-bullet">* </span>small example app
<span class="hljs-bullet">* 

</span><span class="hljs-section">## Outline</span>

Quickstart
<span class="hljs-bullet">* </span>Installing Livewire
<span class="hljs-bullet">* </span>Creating your first component (create post, not counter)
<span class="hljs-bullet">* </span>Adding properties
<span class="hljs-bullet">* </span>Adding behavior
<span class="hljs-bullet">* </span>Rendering the component in the browser
<span class="hljs-bullet">* </span>Testing it out

Upgrade Guide

Fundamentals:
<span class="hljs-bullet">* </span>Installation
<span class="hljs-bullet">	* </span>Composer command
<span class="hljs-bullet">	* </span>Publishing config
<span class="hljs-bullet">	* </span>Disabling asset auto-injection
<span class="hljs-bullet">	* </span>Configuring Livewire's update endpoint
<span class="hljs-bullet">	* </span>Configuring Livewire's JavaScript endpoint
<span class="hljs-bullet">	* </span>Publishing and hosting Livewire's JavaScript
<span class="hljs-bullet">* </span>Components
<span class="hljs-bullet">	* </span>Creating a component
<span class="hljs-bullet">	* </span>The render method
<span class="hljs-bullet">		* </span>Returning Blade views
<span class="hljs-bullet">		* </span>Returning template strings
<span class="hljs-bullet">	       * </span>artisan make --inline
<span class="hljs-bullet">	- </span>Rendering a single component
<span class="hljs-bullet">		- </span>Passing parameters
<span class="hljs-bullet">		- </span>Receiving parameters
<span class="hljs-bullet">	- </span>Rendering a component route
<span class="hljs-bullet">		* </span>Configuring the layout
<span class="hljs-bullet">		* </span>Route parameters
<span class="hljs-bullet">		* </span>Route model binding
<span class="hljs-bullet">* </span>Properties
<span class="hljs-bullet">	* </span>Introduction
<span class="hljs-bullet">	* </span>Initializing properties in the mount method
<span class="hljs-bullet">	* </span>Bulk assigning properties ($this-&gt;fill())
<span class="hljs-bullet">	* </span>Resetting properties ($this-&gt;reset())
<span class="hljs-bullet">	* </span>Data binding (Basic introduction with link to other documentation page)
<span class="hljs-bullet">	* </span>Supported property types
<span class="hljs-bullet">		* </span>(Brief explanation of hydration/dehydration and why every possible type isn't supported)
<span class="hljs-bullet">		* </span>Primitive types (strings, int, boolean, etc...)
<span class="hljs-bullet">		* </span>Common PHP types (Collection, DateTime, etc...)
<span class="hljs-bullet">		* </span>Supporting custom types (explain how users can add support for types specific to their application)
<span class="hljs-bullet">			* </span>Using Wireables
<span class="hljs-bullet">			* </span>Using Synthesizers
<span class="hljs-bullet">	* </span>Using $wire 
<span class="hljs-bullet">	    * </span>Accessing properties with $wire in Alpine inside your component
<span class="hljs-bullet">	    * </span>Manipulating properties
<span class="hljs-bullet">	    * </span>Using $wire.get and $wire.set
<span class="hljs-bullet">	* </span>Security concerns
<span class="hljs-bullet">		* </span>Don't trust properties
<span class="hljs-bullet">			* </span>Authorizing properties
<span class="hljs-bullet">			* </span>Using "locked" properties
<span class="hljs-bullet">		* </span>Be aware that Livewire exposes property metadata like eloquent model class names
<span class="hljs-bullet">	* </span>"Computed" properties (using -&gt;getPostProperty() syntax)
<span class="hljs-bullet">
* </span>Actions
<span class="hljs-bullet">	* </span>Security concerns
<span class="hljs-bullet">	* </span>Parameters
<span class="hljs-bullet">	* </span>Event modifiers
<span class="hljs-bullet">		* </span>Keydown modifiers
<span class="hljs-bullet">	* </span>Magic actions
<span class="hljs-bullet">	 * </span>Wireable actions
<span class="hljs-bullet"> * </span>Data Binding
<span class="hljs-bullet">	* </span>Live binding
<span class="hljs-bullet">	* </span>Lazy binding
<span class="hljs-bullet">	* </span>Debounced binding
<span class="hljs-bullet">	* </span>Throttled binding
<span class="hljs-bullet">	* </span>Binding nested data
<span class="hljs-bullet">	* </span>Binding to eloquent models
<span class="hljs-bullet">* </span>Nesting components
<span class="hljs-bullet">* </span>Events
<span class="hljs-bullet">	* </span>Basic example
<span class="hljs-bullet">	* </span>Security concerns
<span class="hljs-bullet">	* </span>Firing events
<span class="hljs-bullet">	* </span>Listerns
<span class="hljs-bullet">	* </span>Passing parameters
<span class="hljs-bullet">	* </span>Scoping events
<span class="hljs-bullet">		* </span>parent / name / self
<span class="hljs-bullet">	* </span>JavaScript listeners
<span class="hljs-bullet">	* </span>Dispatching browser events
<span class="hljs-bullet">* </span>Lifecycle hooks
<span class="hljs-bullet">	* </span>Class hooks
<span class="hljs-bullet">		* </span>mount
<span class="hljs-bullet">		* </span>hydrate
<span class="hljs-bullet">		* </span>boot
<span class="hljs-bullet">		* </span>dehydrate
<span class="hljs-bullet">		* </span>update
<span class="hljs-bullet">* </span>Testing
<span class="hljs-bullet">	* </span>Basic test
<span class="hljs-bullet">        * </span><span class="hljs-code">`artisan make: --test`</span>
<span class="hljs-bullet">	* </span>Making a test
<span class="hljs-bullet">	* </span>Testing presence
<span class="hljs-bullet">	* </span>Passing component data
<span class="hljs-bullet">	* </span>Passing query string params
<span class="hljs-bullet">	* </span>Available commands
<span class="hljs-bullet">	* </span>Available assertions
<span class="hljs-bullet">* </span>AlpineJS
<span class="hljs-bullet">	* </span>...
<span class="hljs-bullet">* </span>Eloquent Models
<span class="hljs-bullet">	* </span>Setting as properties
<span class="hljs-bullet">	* </span>Performance implications
<span class="hljs-bullet">	* </span>Binding to attributes
<span class="hljs-bullet">	* </span>Collections of models

Forms:
<span class="hljs-bullet">* </span>Form submission
<span class="hljs-bullet">* </span>Form inputs
<span class="hljs-bullet">* </span>Input validation
<span class="hljs-bullet">* </span>File uploads

Features:
<span class="hljs-bullet">* </span>Loading states
<span class="hljs-bullet">* </span>Pagination
<span class="hljs-bullet">* </span>Inline scripts
<span class="hljs-bullet">* </span>Flash messages
<span class="hljs-bullet">* </span>Query string
<span class="hljs-bullet">* </span>Redirecting
<span class="hljs-bullet">* </span>Polling
<span class="hljs-bullet">* </span>Authorization
<span class="hljs-bullet">* </span>Dirty states
<span class="hljs-bullet">* </span>File Downloads
<span class="hljs-bullet">* </span>Offline states
<span class="hljs-bullet">* </span>Computed properties

Deep knowledge:
<span class="hljs-bullet">* </span>How Livewire works
<span class="hljs-bullet">* </span>Synthesizers

JavaScript Global
<span class="hljs-bullet">	* </span>Lifecycle hooks
Component abstractions
Artisan Commands
Troubleshooting
Security (both internal and userland)
Extending
<span class="hljs-bullet">- </span>Custom wireables
Package development
Deployment
Publishing stubs
Laravel Echo
Reference

V3:
<span class="hljs-bullet">* </span>Lazy loading
<span class="hljs-bullet">* </span>SPA Mode
<span class="hljs-bullet">

* </span>Is this even the place I want to order from?
<span class="hljs-bullet">* </span>What kind of flowers does mom like?
<span class="hljs-bullet">* </span>How much money should I spend on them?
<span class="hljs-bullet">* </span>When should I have them delivered?
<span class="hljs-bullet">* </span>Do I need to call dad and make sure she will like them?


Why is writing documentation so hard?

<span class="hljs-section">### Words are hard</span>

Yeah, but it's more than that. Agreed that words are hard, but I seem to be able to write a blog post no problem.

It's boring speak catered to the lowest common denominator of reader

Yeah like I feel like I don't have a voice at all. Like the jokes and meanderings and bold statements I usually like to write with don't belong here. Clarity at all costs belongs here.

<span class="hljs-section">### Organizing content is hard</span>
There's the "chicken" and "egg" problem: some content depends on another piece but that piece relies back on the original piece. Which one comes first?

There's the granularity problem: how much do we want to break this up?

There's the ordering problem: "do I go simple to complex? or most real-world to least real-world?"

The repetition problem: do you repeat yourself in multiple pages? or isolate one feature to a single file? This one is answered: repeat yourself.

<span class="hljs-section">### Code examples are hard</span>
How much non-crucial context to include? (include <span class="xml"><span class="hljs-tag">&lt; ?<span class="hljs-attr">php</span> <span class="hljs-attr">include</span> <span class="hljs-attr">class</span>? <span class="hljs-attr">namespace</span>? <span class="hljs-attr">use</span>? <span class="hljs-attr">render</span>?)

<span class="hljs-attr">How</span> <span class="hljs-attr">to</span> <span class="hljs-attr">make</span> <span class="hljs-attr">it</span> <span class="hljs-attr">real-world</span> <span class="hljs-attr">but</span> <span class="hljs-attr">cater</span> <span class="hljs-attr">to</span> <span class="hljs-attr">exactly</span> <span class="hljs-attr">the</span> <span class="hljs-attr">right</span> <span class="hljs-attr">mechanisms</span>? "<span class="hljs-attr">hello</span> <span class="hljs-attr">world</span>" <span class="hljs-attr">and</span> "<span class="hljs-attr">counter</span>" <span class="hljs-attr">components</span> <span class="hljs-attr">are</span> <span class="hljs-attr">helpful</span> <span class="hljs-attr">but</span> <span class="hljs-attr">not</span> <span class="hljs-attr">real-life.</span> <span class="hljs-attr">But</span> <span class="hljs-attr">real-life</span> <span class="hljs-attr">isn</span>'<span class="hljs-attr">t</span> <span class="hljs-attr">often</span> <span class="hljs-attr">simple</span> <span class="hljs-attr">enough.</span>

<span class="hljs-attr">Do</span> <span class="hljs-attr">you</span> <span class="hljs-attr">stick</span> <span class="hljs-attr">with</span> <span class="hljs-attr">the</span> <span class="hljs-attr">same</span> <span class="hljs-attr">domain</span>? "<span class="hljs-attr">CreatePost</span>" <span class="hljs-attr">the</span> <span class="hljs-attr">whole</span> <span class="hljs-attr">time</span>? <span class="hljs-attr">Is</span> <span class="hljs-attr">it</span> <span class="hljs-attr">too</span> <span class="hljs-attr">jarring</span> <span class="hljs-attr">to</span> <span class="hljs-attr">hop</span> <span class="hljs-attr">around</span> <span class="hljs-attr">a</span> <span class="hljs-attr">ton</span>, <span class="hljs-attr">or</span> <span class="hljs-attr">is</span> <span class="hljs-attr">it</span> <span class="hljs-attr">too</span> <span class="hljs-attr">predictable</span>, <span class="hljs-attr">constrained</span> <span class="hljs-attr">and</span> <span class="hljs-attr">monotonous</span> <span class="hljs-attr">to</span> <span class="hljs-attr">stick</span> <span class="hljs-attr">with</span> <span class="hljs-attr">one</span> <span class="hljs-attr">example</span> <span class="hljs-attr">the</span> <span class="hljs-attr">entire</span> <span class="hljs-attr">time</span>?

### <span class="hljs-attr">There</span>'<span class="hljs-attr">s</span> <span class="hljs-attr">a</span> <span class="hljs-attr">ton</span> <span class="hljs-attr">of</span> <span class="hljs-attr">it</span>
<span class="hljs-attr">There</span>'<span class="hljs-attr">s</span> <span class="hljs-attr">just</span> <span class="hljs-attr">so</span> <span class="hljs-attr">much</span> <span class="hljs-attr">of</span> <span class="hljs-attr">it</span>, <span class="hljs-attr">it</span> <span class="hljs-attr">feels</span> <span class="hljs-attr">overwhelming</span>






<span class="hljs-attr">Humor:</span>
* <span class="hljs-attr">bathtubs</span>
* <span class="hljs-attr">silly</span> <span class="hljs-attr">bands</span>
* <span class="hljs-attr">penguins</span> <span class="hljs-attr">of</span> <span class="hljs-attr">madagascar</span>
* <span class="hljs-attr">Ed</span> <span class="hljs-attr">Bassmaster</span>
* <span class="hljs-attr">Spongebob</span>

</span></span></div></code></pre>
<h2 id="file-actionsmd">File: actions.md</h2>
<pre class="hljs"><code><div>Livewire actions are methods on your component that can be triggered by frontend interactions like clicking a button or submitting a form. They provide the developer experience of being able to call a PHP method directly from the browser, allowing you to focus on the logic of your application without getting bogged down writing boilerplate code connecting your application's frontend and backend.

Let's explore a basic example of calling a <span class="hljs-code">`save`</span> action on a <span class="hljs-code">`CreatePost`</span> component:

<span class="hljs-code">```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;
use App\Models\Post;

class CreatePost extends Component
{
    public $title = '';

    public $content = '';

    public function save()
    {
        Post::create([
            'title' =&gt; $this-&gt;title,
            'content' =&gt; $this-&gt;content,
        ]);

        return redirect()-&gt;to('/posts');
    }

    public function render()
    {
        return view('livewire.create-post');
    }
}
</span></div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt; &lt;!-- [tl! highlight] --&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;

    &lt;textarea wire:model=&quot;content&quot;&gt;&lt;/textarea&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>In the above example, when a user submits the form by clicking &quot;Save&quot;, <code>wire:submit</code> intercepts the <code>submit</code> event and calls the <code>save()</code> action on the server.</p>
<p>In essence, actions are a way to easily map user interactions to server-side functionality without the hassle of submitting and handling AJAX requests manually.</p>
<h2 id="refreshing-a-component">Refreshing a component</h2>
<p>Sometimes you may want to trigger a simple &quot;refresh&quot; of your component. For example, if you have a component checking the status of something in the database, you may want to show a button to your users allowing them to refresh the displayed results.</p>
<p>You can do this using Livewire's simple <code>$refresh</code> action anywhere you would normally reference your own component method:</p>
<pre class="hljs"><code><div>&lt;button type=&quot;button&quot; wire:click=&quot;$refresh&quot;&gt;...&lt;/button&gt;
</div></code></pre>
<p>When the <code>$refresh</code> action is triggered, Livewire will make a server-roundtrip and re-render your component without calling any methods.</p>
<p>It's important to note that any pending data updates in your component (for example <code>wire:model</code> bindings) will be applied on the server when the component is refreshed.</p>
<p>Internally, Livewire uses the name &quot;commit&quot; to refer to any time a Livewire component is updated on the server. If you prefer this terminology, you can use the <code>$commit</code> helper instead of <code>$refresh</code>. The two are identical.</p>
<pre class="hljs"><code><div>&lt;button type=&quot;button&quot; wire:click=&quot;$commit&quot;&gt;...&lt;/button&gt;
</div></code></pre>
<p>You can also trigger a component refresh using AlpineJS in your Livewire component:</p>
<pre class="hljs"><code><div>&lt;button type=&quot;button&quot; x-on:click=&quot;$wire.$refresh()&quot;&gt;...&lt;/button&gt;
</div></code></pre>
<p>Learn more by reading the <a href="/docs/alpine">documentation for using Alpine inside Livewire</a>.</p>
<h2 id="confirming-an-action">Confirming an action</h2>
<p>When allowing users to perform dangerous actions—such as deleting a post from the database—you may want to show them a confirmation alert to verify that they wish to perform that action.</p>
<p>Livewire makes this easy by providing a simple directive called <code>wire:confirm</code>:</p>
<pre class="hljs"><code><div>&lt;button
    type=&quot;button&quot;
    wire:click=&quot;delete&quot;
    wire:confirm=&quot;Are you sure you want to delete this post?&quot;
&gt;
    Delete post &lt;!-- [tl! highlight:-2,1] --&gt;
&lt;/button&gt;
</div></code></pre>
<p>When <code>wire:confirm</code> is added to an element containing a Livewire action, when a user tries to trigger that action, they will be presented with a confirmation dialog containing the provided message. They can either press &quot;OK&quot; to confirm the action, or press &quot;Cancel&quot; or hit the escape key.</p>
<p>For more information, visit the <a href="/docs/wire-confirm"><code>wire:confirm</code> documentation page</a>.</p>
<h2 id="event-listeners">Event listeners</h2>
<p>Livewire supports a variety of event listeners, allowing you to respond to various types of user interactions:</p>
<table>
<thead>
<tr>
<th>Listener</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>wire:click</code></td>
<td>Triggered when an element is clicked</td>
</tr>
<tr>
<td><code>wire:submit</code></td>
<td>Triggered when a form is submitted</td>
</tr>
<tr>
<td><code>wire:keydown</code></td>
<td>Triggered when a key is pressed down</td>
</tr>
<tr>
<td><code>wire:keyup</code></td>
<td>Triggered when a key is released</td>
</tr>
<tr>
<td><code>wire:mouseenter</code></td>
<td>Triggered when the mouse enters an element</td>
</tr>
<tr>
<td><code>wire:*</code></td>
<td>Whatever text follows <code>wire:</code> will be used as the event name of the listener</td>
</tr>
</tbody>
</table>
<p>Because the event name after <code>wire:</code> can be anything, Livewire supports any browser event you might need to listen for. For example, to listen for <code>transitionend</code>, you can use <code>wire:transitionend</code>.</p>
<h3 id="listening-for-specific-keys">Listening for specific keys</h3>
<p>You can use one of Livewire's convenient aliases to narrow down key press event listeners to a specific key or combination of keys.</p>
<p>For example, to perform a search when a user hits <code>Enter</code> after typing into a search box, you can use <code>wire:keydown.enter</code>:</p>
<pre class="hljs"><code><div>&lt;input wire:model=&quot;query&quot; wire:keydown.enter=&quot;searchPosts&quot;&gt;
</div></code></pre>
<p>You can chain more key aliases after the first to listen for combinations of keys. For example, if you would like to listen for the <code>Enter</code> key only while the <code>Shift</code> key is pressed, you may write the following:</p>
<pre class="hljs"><code><div>&lt;input wire:keydown.shift.enter=&quot;...&quot;&gt;
</div></code></pre>
<p>Below is a list of all the available key modifiers:</p>
<table>
<thead>
<tr>
<th>Modifier</th>
<th>Key</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.shift</code></td>
<td>Shift</td>
</tr>
<tr>
<td><code>.enter</code></td>
<td>Enter</td>
</tr>
<tr>
<td><code>.space</code></td>
<td>Space</td>
</tr>
<tr>
<td><code>.ctrl</code></td>
<td>Ctrl</td>
</tr>
<tr>
<td><code>.cmd</code></td>
<td>Cmd</td>
</tr>
<tr>
<td><code>.meta</code></td>
<td>Cmd on Mac, Windows key on Windows</td>
</tr>
<tr>
<td><code>.alt</code></td>
<td>Alt</td>
</tr>
<tr>
<td><code>.up</code></td>
<td>Up arrow</td>
</tr>
<tr>
<td><code>.down</code></td>
<td>Down arrow</td>
</tr>
<tr>
<td><code>.left</code></td>
<td>Left arrow</td>
</tr>
<tr>
<td><code>.right</code></td>
<td>Right arrow</td>
</tr>
<tr>
<td><code>.escape</code></td>
<td>Escape</td>
</tr>
<tr>
<td><code>.tab</code></td>
<td>Tab</td>
</tr>
<tr>
<td><code>.caps-lock</code></td>
<td>Caps Lock</td>
</tr>
<tr>
<td><code>.equal</code></td>
<td>Equal, <code>=</code></td>
</tr>
<tr>
<td><code>.period</code></td>
<td>Period, <code>.</code></td>
</tr>
<tr>
<td><code>.slash</code></td>
<td>Forward Slash, <code>/</code></td>
</tr>
</tbody>
</table>
<h3 id="event-handler-modifiers">Event handler modifiers</h3>
<p>Livewire also includes helpful modifiers to make common event-handling tasks trivial.</p>
<p>For example, if you need to call <code>event.preventDefault()</code> from inside an event listener, you can suffix the event name with <code>.prevent</code>:</p>
<pre class="hljs"><code><div>&lt;input wire:keydown.prevent=&quot;...&quot;&gt;
</div></code></pre>
<p>Here is a full list of all the available event listener modifiers and their functions:</p>
<table>
<thead>
<tr>
<th>Modifier</th>
<th>Key</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.prevent</code></td>
<td>Equivalent of calling <code>.preventDefault()</code></td>
</tr>
<tr>
<td><code>.stop</code></td>
<td>Equivalent of calling <code>.stopPropagation()</code></td>
</tr>
<tr>
<td><code>.window</code></td>
<td>Listens for event on the <code>window</code> object</td>
</tr>
<tr>
<td><code>.outside</code></td>
<td>Only listens for clicks &quot;outside&quot; the element</td>
</tr>
<tr>
<td><code>.document</code></td>
<td>Listens for events on the <code>document</code> object</td>
</tr>
<tr>
<td><code>.once</code></td>
<td>Ensures the listener is only called once</td>
</tr>
<tr>
<td><code>.debounce</code></td>
<td>Debounce the handler by 250ms as a default</td>
</tr>
<tr>
<td><code>.debounce.100ms</code></td>
<td>Debounce the handler for a specific amount of time</td>
</tr>
<tr>
<td><code>.throttle</code></td>
<td>Throttle the handler to being called every 250ms at minimum</td>
</tr>
<tr>
<td><code>.throttle.100ms</code></td>
<td>Throttle the handler at a custom duration</td>
</tr>
<tr>
<td><code>.self</code></td>
<td>Only call listener if event originated on this element, not children</td>
</tr>
<tr>
<td><code>.camel</code></td>
<td>Converts event name to camel case (<code>wire:custom-event</code> -&gt; &quot;customEvent&quot;)</td>
</tr>
<tr>
<td><code>.dot</code></td>
<td>Converts event name to dot notation (<code>wire:custom-event</code> -&gt; &quot;custom.event&quot;)</td>
</tr>
<tr>
<td><code>.passive</code></td>
<td><code>wire:touchstart.passive</code> won't block scroll performance</td>
</tr>
<tr>
<td><code>.capture</code></td>
<td>Listen for event in the &quot;capturing&quot; phase</td>
</tr>
</tbody>
</table>
<p>Because <code>wire:</code> uses <a href="https://alpinejs.dev">Alpine's</a> <code>x-on</code> directive under the hood, these modifiers are made available to you by Alpine. For more context on when you should use these modifiers, consult the <a href="https://alpinejs.dev/essentials/events">Alpine Events documentation</a>.</p>
<h3 id="handling-third-party-events">Handling third-party events</h3>
<p>Livewire also supports listening for custom events fired by third-party libraries.</p>
<p>For example, let's imagine you're using the <a href="https://trix-editor.org/">Trix</a> rich text editor in your project and you want to listen for the <code>trix-change</code> event to capture the editor's content. You can accomplish this using the <code>wire:trix-change</code> directive:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;!-- ... --&gt;

    &lt;trix-editor
        wire:trix-change=&quot;setPostContent($event.target.value)&quot;
    &gt;&lt;/trix-editor&gt;

    &lt;!-- ... --&gt;
&lt;/form&gt;
</div></code></pre>
<p>In this example, the <code>setPostContent</code> action is called whenever the <code>trix-change</code> event is triggered, updating the <code>content</code> property in the Livewire component with the current value of the Trix editor.</p>
<blockquote>
<p>[!info] You can access the event object using <code>$event</code>
Within Livewire event handlers, you can access the event object via <code>$event</code>. This is useful for referencing information on the event. For example, you can access the element that triggered the event via <code>$event.target</code>.</p>
</blockquote>
<blockquote>
<p>[!warning]
The Trix demo code above is incomplete and only useful as a demonstration of event listeners. If used verbatim, a network request would be fired on every single keystroke. A more performant implementation would be:</p>
<pre class="hljs"><code><div>&lt;trix-editor
   x-on:trix-change=&quot;$wire.content = $event.target.value&quot;
&gt;&lt;/trix-editor&gt;
</div></code></pre>
</blockquote>
<h3 id="listening-for-dispatched-custom-events">Listening for dispatched custom events</h3>
<p>If your application dispatches custom events from Alpine, you can also listen for those using Livewire:</p>
<pre class="hljs"><code><div>&lt;div wire:custom-event=&quot;...&quot;&gt;

    &lt;!-- Deeply nested within this component: --&gt;
    &lt;button x-on:click=&quot;$dispatch('custom-event')&quot;&gt;...&lt;/button&gt;

&lt;/div&gt;
</div></code></pre>
<p>When the button is clicked in the above example, the <code>custom-event</code> event is dispatched and bubbles up to the root of the Livewire component where <code>wire:custom-event</code> catches it and invokes a given action.</p>
<p>If you want to listen for an event dispatched somewhere else in your application, you will need to wait instead for the event to bubble up to the <code>window</code> object and listen for it there. Fortunately, Livewire makes this easy by allowing you to add a simple <code>.window</code> modifier to any event listener:</p>
<pre class="hljs"><code><div>&lt;div wire:custom-event.window=&quot;...&quot;&gt;
    &lt;!-- ... --&gt;
&lt;/div&gt;

&lt;!-- Dispatched somewhere on the page outside the component: --&gt;
&lt;button x-on:click=&quot;$dispatch('custom-event')&quot;&gt;...&lt;/button&gt;
</div></code></pre>
<h3 id="disabling-inputs-while-a-form-is-being-submitted">Disabling inputs while a form is being submitted</h3>
<p>Consider the <code>CreatePost</code> example we previously discussed:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input wire:model=&quot;title&quot;&gt;

    &lt;textarea wire:model=&quot;content&quot;&gt;&lt;/textarea&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>When a user clicks &quot;Save&quot;, a network request is sent to the server to call the <code>save()</code> action on the Livewire component.</p>
<p>But, let's imagine that a user is filling out this form on a slow internet connection. The user clicks &quot;Save&quot; and nothing happens initially because the network request takes longer than usual. They might wonder if the submission failed and attempt to click the &quot;Save&quot; button again while the first request is still being handled.</p>
<p>In this case, there would be two requests for the same action being processed at the same time.</p>
<p>To prevent this scenario, Livewire automatically disables the submit button and all form inputs inside the <code>&lt;form&gt;</code> element while a <code>wire:submit</code> action is being processed. This ensures that a form isn't accidentally submitted twice.</p>
<p>To further lessen the confusion for users on slower connections, it is often helpful to show some loading indicator such as a subtle background color change or SVG animation.</p>
<p>Livewire provides a <code>wire:loading</code> directive that makes it trivial to show and hide loading indicators anywhere on a page. Here's a short example of using <code>wire:loading</code> to show a loading message below the &quot;Save&quot; button:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;textarea wire:model=&quot;content&quot;&gt;&lt;/textarea&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;

    &lt;span wire:loading&gt;Saving...&lt;/span&gt; &lt;!-- [tl! highlight] --&gt;
&lt;/form&gt;
</div></code></pre>
<p><code>wire:loading</code> is a powerful feature with a variety of more powerful features. <a href="/docs/wire-loading">Check out the full loading documentation for more information</a>.</p>
<h2 id="passing-parameters">Passing parameters</h2>
<p>Livewire allows you to pass parameters from your Blade template to the actions in your component, giving you the opportunity to provide an action additional data or state from the frontend when the action is called.</p>
<p>For example, let's imagine you have a <code>ShowPosts</code> component that allows users to delete a post. You can pass the post's ID as a parameter to the <code>delete()</code> action in your Livewire component. Then, the action can fetch the relevant post and delete it from the database:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">($id)</span>
    </span>{
        $post = Post::findOrFail($id);

        <span class="hljs-keyword">$this</span>-&gt;authorize(<span class="hljs-string">'delete'</span>, $post);

        $post-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Auth::user()-&gt;posts,
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;div wire:key=&quot;{{ $post-&gt;id }}&quot;&gt;
            &lt;h1&gt;{{ $post-&gt;title }}&lt;/h1&gt;
            &lt;span&gt;{{ $post-&gt;content }}&lt;/span&gt;

            &lt;button wire:click=&quot;delete({{ $post-&gt;id }})&quot;&gt;Delete&lt;/button&gt; &lt;!-- [tl! highlight] --&gt;
        &lt;/div&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>For a post with an ID of 2, the &quot;Delete&quot; button in the Blade template above will render in the browser as:</p>
<pre class="hljs"><code><div>&lt;button wire:click=&quot;delete(2)&quot;&gt;Delete&lt;/button&gt;
</div></code></pre>
<p>When this button is clicked, the <code>delete()</code> method will be called and <code>$id</code> will be passed in with a value of &quot;2&quot;.</p>
<blockquote>
<p>[!warning] Don't trust action parameters
Action parameters should be treated just like HTTP request input, meaning action parameter values should not be trusted. You should always authorize ownership of an entity before updating it in the database.</p>
<p>For more information, consult our documentation regarding <a href="/docs/actions#security-concerns">security concerns and best practices</a>.</p>
</blockquote>
<p>As an added convenience, you may automatically resolve Eloquent models by a corresponding model ID that is provided to an action as a parameter. This is very similar to <a href="/docs/components#using-route-model-binding">route model binding</a>. To get started, type-hint an action parameter with a model class and the appropriate model will automatically be retrieved from the database and passed to the action instead of the ID:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">(Post $post)</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>]
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;authorize(<span class="hljs-string">'delete'</span>, $post);

        $post-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Auth::user()-&gt;posts,
        ]);
    }
}
</div></code></pre>
<h2 id="dependency-injection">Dependency injection</h2>
<p>You can take advantage of <a href="https://laravel.com/docs/controllers#dependency-injection-and-controllers">Laravel's dependency injection</a> system by type-hinting parameters in your action's signature. Livewire and Laravel will automatically resolve the action's dependencies from the container:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Repositories</span>\<span class="hljs-title">PostRepository</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">(PostRepository $posts, $postId)</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>]
    </span>{
        $posts-&gt;deletePost($postId);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Auth::user()-&gt;posts,
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;div wire:key=&quot;{{ $post-&gt;id }}&quot;&gt;
            &lt;h1&gt;{{ $post-&gt;title }}&lt;/h1&gt;
            &lt;span&gt;{{ $post-&gt;content }}&lt;/span&gt;

            &lt;button wire:click=&quot;delete({{ $post-&gt;id }})&quot;&gt;Delete&lt;/button&gt; &lt;!-- [tl! highlight] --&gt;
        &lt;/div&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>In this example, the <code>delete()</code> method receives an instance of <code>PostRepository</code> resolved via <a href="https://laravel.com/docs/container#main-content">Laravel's service container</a> before receiving the provided <code>$postId</code> parameter.</p>
<h2 id="calling-actions-from-alpine">Calling actions from Alpine</h2>
<p>Livewire integrates seamlessly with <a href="https://alpinejs.dev/">Alpine</a>. In fact, under the hood, every Livewire component is also an Alpine component. This means you can take full advantage of Alpine within your components to add JavaScript powered client-side interactivity.</p>
<p>To make this pairing even more powerful, Livewire exposes a magic <code>$wire</code> object to Alpine that can be treated as a JavaScript representation of your PHP component. In addition to <a href="/docs/properties#accessing-properties-from-javascript">accessing and mutating public properties via <code>$wire</code></a>, you can call actions. When an action is invoked on the <code>$wire</code> object, the corresponding PHP method will be invoked on your backend Livewire component:</p>
<pre class="hljs"><code><div>&lt;button x-on:click=&quot;$wire.save()&quot;&gt;Save Post&lt;/button&gt;
</div></code></pre>
<p>Or, to illustrate a more complex example, you might use Alpine's <a href="https://alpinejs.dev/plugins/intersect"><code>x-intersect</code></a> utility to trigger a <code>incrementViewCount()</code> Livewire action when a given element is visible on the page:</p>
<pre class="hljs"><code><div>&lt;div x-intersect=&quot;$wire.incrementViewCount()&quot;&gt;...&lt;/div&gt;
</div></code></pre>
<h3 id="passing-parameters">Passing parameters</h3>
<p>Any parameters you pass to the <code>$wire</code> method will also be passed to the PHP class method. For example, consider the following Livewire action:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span><span class="hljs-params">($todo)</span>
</span>{
    <span class="hljs-keyword">$this</span>-&gt;todos[] = $todo;
}
</div></code></pre>
<p>Within your component's Blade template, you can invoke this action via Alpine, providing the parameter that should be given to the action:</p>
<pre class="hljs"><code><div>&lt;div x-data=&quot;{ todo: '' }&quot;&gt;
    &lt;input type=&quot;text&quot; x-model=&quot;todo&quot;&gt;

    &lt;button x-on:click=&quot;$wire.addTodo(todo)&quot;&gt;Add Todo&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>If a user had typed in &quot;Take out the trash&quot; into the text input and the pressed the &quot;Add Todo&quot; button, the <code>addTodo()</code> method will be triggered with the <code>$todo</code> parameter value being &quot;Take out the trash&quot;.</p>
<h3 id="receiving-return-values">Receiving return values</h3>
<p>For even more power, invoked <code>$wire</code> actions return a promise while the network request is processing. When the server response is received, the promise resolves with the value returned by the backend action.</p>
<p>For example, consider a Livewire component that has the following action:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPostCount</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Post::count();
}
</div></code></pre>
<p>Using <code>$wire</code>, the action may be invoked and its returned value resolved:</p>
<pre class="hljs"><code><div>&lt;span x-text=&quot;await $wire.getPostCount()&quot;&gt;&lt;/span&gt;
</div></code></pre>
<p>In this example, if the <code>getPostCount()</code> method returns &quot;10&quot;, the <code>&lt;span&gt;</code> tag will also contain &quot;10&quot;.</p>
<p>Alpine knowledge is not required when using Livewire; however, it's an extremely powerful tool and knowing Alpine will augment your Livewire experience and productivity.</p>
<h2 id="livewires-%22hybrid%22-javascript-functions">Livewire's &quot;hybrid&quot; JavaScript functions</h2>
<p>Sometimes there are actions in your component that don't need to communicate with the server and can be more efficiently written using only JavaScript.</p>
<p>In these cases, rather than writing the actions inside your Blade template or another file, your component action may return the JavaScript function as a string. If the action is marked with the <code>#[Js]</code> attribute, it will be callable from your application's frontend:</p>
<p>For example:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Js</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $query = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Js] // [tl! highlight:6]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetQuery</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&lt;&lt;&lt;'JS'
            <span class="hljs-subst">$wire</span>.query = '';
        JS;
    }

    public function render()
    {
        return view('livewire.search-posts', [
            'posts' =&gt; Post::whereTitle(<span class="hljs-subst">$this</span>-&gt;query)-&gt;get(),
        ]);
    }
}
</span></div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;input wire:model.live=&quot;query&quot;&gt;

    &lt;button wire:click=&quot;resetQuery&quot;&gt;Reset Search&lt;/button&gt; &lt;!-- [tl! highlight] --&gt;

    @foreach ($posts as $post)
        &lt;!-- ... --&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>In the above example, when the &quot;Reset Search&quot; button is pressed, the text input will be cleared without sending any requests to the server.</p>
<h3 id="evaluating-one-off-javascript-expressions">Evaluating one-off JavaScript expressions</h3>
<p>In addition to designating entire methods to be evaluated in JavaScript, you can use the <code>js()</code> method to evaluate smaller, individual expressions.</p>
<p>This is generally useful for performing some kind of client-side follow-up after a server-side action is performed.</p>
<p>For example, here is an example of a <code>CreatePost</code> component that triggers a client-side alert dialog after the post is saved to the database:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>

        <span class="hljs-keyword">$this</span>-&gt;js(<span class="hljs-string">"alert('Post saved!')"</span>); <span class="hljs-comment">// [tl! highlight:6]</span>
    }
}
</div></code></pre>
<p>The JavaScript expression <code>alert('Post saved!')</code> will now be executed on the client after the post has been saved to the database on the server.</p>
<p>Just like <code>#[Js]</code> methods, you can access the current component's <code>$wire</code> object inside the expression.</p>
<h2 id="magic-actions">Magic actions</h2>
<p>Livewire provides a set of &quot;magic&quot; actions that allow you to perform common tasks in your components without defining custom methods. These magic actions can be used within event listeners defined in your Blade templates.</p>
<h3 id="parent"><code>$parent</code></h3>
<p>The <code>$parent</code> magic variable allows you to access parent component properties and call parent component actions from a child component:</p>
<pre class="hljs"><code><div>&lt;button wire:click=&quot;$parent.removePost({{ $post-&gt;id }})&quot;&gt;Remove&lt;/button&gt;
</div></code></pre>
<p>In the above example, if a parent component has a <code>removePost()</code> action, a child can call it directly from its Blade template using <code>$parent.removePost()</code>.</p>
<h3 id="set"><code>$set</code></h3>
<p>The <code>$set</code> magic action allows you to update a property in your Livewire component directly from the Blade template. To use <code>$set</code>, provide the property you want to update and the new value as arguments:</p>
<pre class="hljs"><code><div>&lt;button wire:click=&quot;$set('query', '')&quot;&gt;Reset Search&lt;/button&gt;
</div></code></pre>
<p>In this example, when the button is clicked, a network request is dispatched that sets the <code>$query</code> property in the component to <code>''</code>.</p>
<h3 id="refresh"><code>$refresh</code></h3>
<p>The <code>$refresh</code> action triggers a re-render of your Livewire component. This can be useful when updating the component's view without changing any property values:</p>
<pre class="hljs"><code><div>&lt;button wire:click=&quot;$refresh&quot;&gt;Refresh&lt;/button&gt;
</div></code></pre>
<p>When the button is clicked, the component will re-render, allowing you to see the latest changes in the view.</p>
<h3 id="toggle"><code>$toggle</code></h3>
<p>The <code>$toggle</code> action is used to toggle the value of a boolean property in your Livewire component:</p>
<pre class="hljs"><code><div>&lt;button wire:click=&quot;$toggle('sortAsc')&quot;&gt;
    Sort {{ $sortAsc ? 'Descending' : 'Ascending' }}
&lt;/button&gt;
</div></code></pre>
<p>In this example, when the button is clicked, the <code>$sortAsc</code> property in the component will toggle between <code>true</code> and <code>false</code>.</p>
<h3 id="dispatch"><code>$dispatch</code></h3>
<p>The <code>$dispatch</code> action allows you to dispatch a Livewire event directly in the browser. Below is an example of a button that, when clicked, will dispatch the <code>post-deleted</code> event:</p>
<pre class="hljs"><code><div>&lt;button type=&quot;submit&quot; wire:click=&quot;$dispatch('post-deleted')&quot;&gt;Delete Post&lt;/button&gt;
</div></code></pre>
<h3 id="event"><code>$event</code></h3>
<p>The <code>$event</code> action may be used within event listeners like <code>wire:click</code>. This action gives you access to the actual JavaScript event that was triggered, allowing you to reference the triggering element and other relevant information:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;text&quot; wire:keydown.enter=&quot;search($event.target.value)&quot;&gt;
</div></code></pre>
<p>When the enter key is pressed while a user is typing in the input above, the contents of the input will be passed as a parameter to the <code>search()</code> action.</p>
<h3 id="using-magic-actions-from-alpine">Using magic actions from Alpine</h3>
<p>You can also call magic actions from Alpine using the <code>$wire</code> object. For example, you may use the <code>$wire</code> object to invoke the <code>$refresh</code> magic action:</p>
<pre class="hljs"><code><div>&lt;button x-on:click=&quot;$wire.$refresh()&quot;&gt;Refresh&lt;/button&gt;
</div></code></pre>
<h2 id="skipping-re-renders">Skipping re-renders</h2>
<p>Sometimes there might be an action in your component with no side effects that would change the rendered Blade template when the action is invoked. If so, you can skip the <code>render</code> portion of Livewire's lifecycle by adding the <code>#[Renderless]</code> attribute above the action method.</p>
<p>To demonstrate, in the <code>ShowPost</code> component below, the &quot;view count&quot; is logged when the user has scrolled to the bottom of the post:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Renderless</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = $post;
    }

    <span class="hljs-comment">#[Renderless] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementViewCount</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post-&gt;incrementViewCount();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-post'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;{{ $post-&gt;title }}&lt;/h1&gt;
    &lt;p&gt;{{ $post-&gt;content }}&lt;/p&gt;

    &lt;div x-intersect=&quot;$wire.incrementViewCount()&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</div></code></pre>
<p>The example above uses <a href="https://alpinejs.dev/plugins/intersect"><code>x-intersect</code></a>, an Alpine utility that calls the expression when the element enters the viewport (typically used to detect when a user scrolls to an element further down the page).</p>
<p>As you can see, when a user scrolls to the bottom of the post, <code>incrementViewCount()</code> is invoked. Since <code>#[Renderless]</code> was added to the action, the view is logged, but the template doesn't re-render and no part of the page is affected.</p>
<p>If you prefer to not utilize method attributes or need to conditionally skip rendering, you may invoke the <code>skipRender()</code> method in your component action:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = $post;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementViewCount</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post-&gt;incrementViewCount();

        <span class="hljs-keyword">$this</span>-&gt;skipRender(); <span class="hljs-comment">// [tl! highlight]</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-post'</span>);
    }
}
</div></code></pre>
<h2 id="security-concerns">Security concerns</h2>
<p>Remember that any public method in your Livewire component can be called from the client-side, even without an associated <code>wire:click</code> handler that invokes it. In these scenarios, users can still trigger the action from the browser's DevTools.</p>
<p>Below are three examples of easy-to-miss vulnerabilities in Livewire components. Each will show the vulnerable component first and the secure component after. As an exercise, try spotting the vulnerabilities in the first example before viewing the solution.</p>
<p>If you are having difficulty spotting the vulnerabilities and that makes you concerned about your ability to keep your own applications secure, remember all these vulnerabilities apply to standard web applications that use requests and controllers. If you use a component method as a proxy for a controller method, and its parameters as a proxy for request input, you should be able to apply your existing application security knowledge to your Livewire code.</p>
<h3 id="always-authorize-action-parameters">Always authorize action parameters</h3>
<p>Just like controller request input, it's imperative to authorize action parameters since they are arbitrary user input.</p>
<p>Below is a <code>ShowPosts</code> component where users can view all their posts on one page. They can delete any post they like using one of the post's &quot;Delete&quot; buttons.</p>
<p>Here is a vulnerable version of component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">($id)</span>
    </span>{
        $post = Post::find($id);

        $post-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Auth::user()-&gt;posts,
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;div wire:key=&quot;{{ $post-&gt;id }}&quot;&gt;
            &lt;h1&gt;{{ $post-&gt;title }}&lt;/h1&gt;
            &lt;span&gt;{{ $post-&gt;content }}&lt;/span&gt;

            &lt;button wire:click=&quot;delete({{ $post-&gt;id }})&quot;&gt;Delete&lt;/button&gt;
        &lt;/div&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>Remember that a malicious user can call <code>delete()</code> directly from a JavaScript console, passing any parameters they would like to the action. This means that a user viewing one of their posts can delete another user's post by passing the un-owned post ID to <code>delete()</code>.</p>
<p>To protect against this, we need to authorize that the user owns the post about to be deleted:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">($id)</span>
    </span>{
        $post = Post::find($id);

        <span class="hljs-keyword">$this</span>-&gt;authorize(<span class="hljs-string">'delete'</span>, $post); <span class="hljs-comment">// [tl! highlight]</span>

        $post-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Auth::user()-&gt;posts,
        ]);
    }
}
</div></code></pre>
<h3 id="always-authorize-server-side">Always authorize server-side</h3>
<p>Like standard Laravel controllers, Livewire actions can be called by any user, even if there isn't an affordance for invoking the action in the UI.</p>
<p>Consider the following <code>BrowsePosts</code> component where any user can view all the posts in the application, but only administrators can delete a post:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowsePosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deletePost</span><span class="hljs-params">($id)</span>
    </span>{
        $post = Post::find($id);

        $post-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.browse-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Post::all(),
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;div wire:key=&quot;{{ $post-&gt;id }}&quot;&gt;
            &lt;h1&gt;{{ $post-&gt;title }}&lt;/h1&gt;
            &lt;span&gt;{{ $post-&gt;content }}&lt;/span&gt;

            @if (Auth::user()-&gt;isAdmin())
                &lt;button wire:click=&quot;deletePost({{ $post-&gt;id }})&quot;&gt;Delete&lt;/button&gt;
            @endif
        &lt;/div&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>As you can see, only administrators can see the &quot;Delete&quot; button; however, any user can call <code>deletePost()</code> on the component from the browser's DevTools.</p>
<p>To patch this vulnerability, we need to authorize the action on the server like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowsePosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deletePost</span><span class="hljs-params">($id)</span>
    </span>{
        <span class="hljs-keyword">if</span> (! Auth::user()-&gt;isAdmin) { <span class="hljs-comment">// [tl! highlight:2]</span>
            abort(<span class="hljs-number">403</span>);
        }

        $post = Post::find($id);

        $post-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.browse-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Post::all(),
        ]);
    }
}
</div></code></pre>
<p>With this change, only administrators can delete a post from this component.</p>
<h3 id="keep-dangerous-methods-protected-or-private">Keep dangerous methods protected or private</h3>
<p>Every public method inside your Livewire component is callable from the client. Even methods you haven't referenced inside a <code>wire:click</code> handler. To prevent a user from calling a method that isn't intended to be callable client-side, you should mark them as <code>protected</code> or <code>private</code>. By doing so, you restrict the visibility of that sensitive method to the component's class and its subclasses, ensuring they cannot be called from the client-side.</p>
<p>Consider the <code>BrowsePosts</code> example that we previously discussed, where users can view all posts in your application, but only administrators can delete posts. In the <a href="/docs/actions#always-authorize-server-side">Always authorize server-side</a> section, we made the action secure by adding server-side authorization. Now imagine we refactor the actual deletion of the post into a dedicated method like you might do in order to simplify your code:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Warning: This snippet demonstrates what NOT to do...</span>
<span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowsePosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deletePost</span><span class="hljs-params">($id)</span>
    </span>{
        <span class="hljs-keyword">if</span> (! Auth::user()-&gt;isAdmin) {
            abort(<span class="hljs-number">403</span>);
        }

        <span class="hljs-keyword">$this</span>-&gt;delete($id); <span class="hljs-comment">// [tl! highlight]</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">($postId)</span>  // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:5]
    </span>{
        $post = Post::find($postId);

        $post-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.browse-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Post::all(),
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;div wire:key=&quot;{{ $post-&gt;id }}&quot;&gt;
            &lt;h1&gt;{{ $post-&gt;title }}&lt;/h1&gt;
            &lt;span&gt;{{ $post-&gt;content }}&lt;/span&gt;

            &lt;button wire:click=&quot;deletePost({{ $post-&gt;id }})&quot;&gt;Delete&lt;/button&gt;
        &lt;/div&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>As you can see, we refactored the post deletion logic into a dedicated method named <code>delete()</code>. Even though this method isn't referenced anywhere in our template, if a user gained knowledge of its existence, they would be able to call it from the browser's DevTools because it is <code>public</code>.</p>
<p>To remedy this, we can mark the method as <code>protected</code> or <code>private</code>. Once the method is marked as <code>protected</code> or <code>private</code>, an error will be thrown if a user tries to invoke it:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowsePosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deletePost</span><span class="hljs-params">($id)</span>
    </span>{
        <span class="hljs-keyword">if</span> (! Auth::user()-&gt;isAdmin) {
            abort(<span class="hljs-number">403</span>);
        }

        <span class="hljs-keyword">$this</span>-&gt;delete($id);
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">($postId)</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>]
    </span>{
        $post = Post::find($postId);

        $post-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.browse-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Post::all(),
        ]);
    }
}
</div></code></pre>
<!--
## Applying middleware

By default, Livewire re-applies authentication and authorization related middleware on subsequent requests if those middleware were applied on the initial page load request.

For example, imagine your component is loaded inside a route that is assigned the `auth` middleware and a user's session ends. When the user triggers another action, the `auth` middleware will be re-applied and the user will receive an error.

If there are specific middleware that you would like to apply to a specific action, you may do so with the `#[Middleware]` attribute. For example, we could apply a `LogPostCreation` middleware to an action that creates posts:

```php
<?php

namespace App\Livewire;

use App\Http\Middleware\LogPostCreation;
use Livewire\Component;

class CreatePost extends Component
{
    public $title;

    public $content;

    #[Middleware(LogPostCreation::class)] // [tl! highlight]
    public function save()
    {
        // Create the post...
    }

    // ...
}
```

Now, the `LogPostCreation` middleware will be applied only to the `createPost` action, ensuring that the activity is only being logged when users create a new post.

-->
<pre class="hljs"><code><div>
## File: alpine.md
```md

[AlpineJS](https://alpinejs.dev/) is a lightweight JavaScript library that makes it easy to add client-side interactivity to your web pages. It was originally built to complement tools like Livewire where a more JavaScript-centric utility is helpful for sprinkling interactivity around your app.

Livewire ships with Alpine out of the box so there is no need to install it into your project separately.

The best place to learn about using AlpineJS is [the Alpine documentation](https://alpinejs.dev).

## A Basic Alpine component

To lay a foundation for the rest of this documentation, here is one of the most simple and informative examples of an Alpine component. A small &quot;counter&quot; that shows a number on the page and allows the user to increment that number by clicking a button:

```html
&lt;!-- Declare a JavaScript object of data... --&gt;
&lt;div x-data=&quot;{ count: 0 }&quot;&gt;
    &lt;!-- Render the current &quot;count&quot; value inside an element... --&gt;
    &lt;h2 x-text=&quot;count&quot;&gt;&lt;/h2&gt;

    &lt;!-- Increment the &quot;count&quot; value by &quot;1&quot; when a click event is dispatched... --&gt;
    &lt;button x-on:click=&quot;count++&quot;&gt;+&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>The Alpine component above can be used inside any Livewire component in your application without a hitch. Livewire takes care of maintaining Alpine's state across Livewire component updates. In essence, you should feel free to use Alpine components inside Livewire as if you were using Alpine in any other non-Livewire context.</p>
<h2 id="using-alpine-inside-livewire">Using Alpine inside Livewire</h2>
<p>Let's explore a more real-life example of using an Alpine component inside a Livewire component.</p>
<p>Below is a simple Livewire component showing the details of a post model from the database. By default, only the title of the post is shown:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ $post-&gt;title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">x-data</span>=<span class="hljs-string">"{ expanded: false }"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"expanded = ! expanded"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">x-show</span>=<span class="hljs-string">"! expanded"</span>&gt;</span>Show post content...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">x-show</span>=<span class="hljs-string">"expanded"</span>&gt;</span>Hide post content...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">x-show</span>=<span class="hljs-string">"expanded"</span>&gt;</span>
            {{ $post-&gt;content }}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>By using Alpine, we can hide the content of the post until the user presses the &quot;Show post content...&quot; button. At that point, Alpine's <code>expanded</code> property will be set to <code>true</code> and the content will be shown on the page because <code>x-show=&quot;content&quot;</code> is used to give Alpine control over the visibility of the post's content.</p>
<p>This is an example of where Alpine shines: adding interactivity into your application without triggering Livewire server-roundtrips.</p>
<h2 id="controlling-livewire-from-alpine-using-wire">Controlling Livewire from Alpine using <code>$wire</code></h2>
<p>One of the most powerful features available to you as a Livewire developer is <code>$wire</code>. The <code>$wire</code> object is a magic object available to all your Alpine components that are used inside of Livewire.</p>
<p>You can think of <code>$wire</code> as a gateway from JavaScript into PHP. It allows you to access and modify Livewire component properties, call Livewire component methods, and do much more; all from inside AlpineJS.</p>
<h3 id="accessing-livewire-properties">Accessing Livewire properties</h3>
<p>Here is an example of a simple &quot;character count&quot; utility in a form for creating a post. This will instantly show a user how many characters are contained inside their post's content as they type:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">wire:submit</span>=<span class="hljs-string">"save"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- ... --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"content"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>
        Character count: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">x-text</span>=<span class="hljs-string">"$wire.content.length"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! highlight] --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>As you can see <code>x-text</code> in the above example is being used to allow Alpine to control the text content of the <code>&lt;span&gt;</code> element. <code>x-text</code> accepts any JavaScript expression inside of it and automatically reacts when any dependencies are updated. Because we are using <code>$wire.content</code> to access the value of <code>$content</code>, Alpine will automatically update the text content every time <code>$wire.content</code> is updated from Livewire; in this case by <code>wire:model=&quot;content&quot;</code>.</p>
<h3 id="mutating-livewire-properties">Mutating Livewire properties</h3>
<p>Here is an example of using <code>$wire</code> inside Alpine to clear the &quot;title&quot; field of a form for creating a post.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">wire:submit</span>=<span class="hljs-string">"save"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.title = ''"</span>&gt;</span>Clear<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! highlight] --&gt;</span>

    <span class="hljs-comment">&lt;!-- ... --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>As a user is filling out the above Livewire form, they can press &quot;Clear&quot; and the title field will be cleared without sending a network request from Livewire. The interaction will be &quot;instant&quot;.</p>
<p>Here's a brief explanation of what's going on to make that happen:</p>
<ul>
<li><code>x-on:click</code> tells Alpine to listen for a click on the button element</li>
<li>When clicked, Alpine runs the provided JS expression: <code>$wire.title = ''</code></li>
<li>Because <code>$wire</code> is a magic object representing the Livewire component, all properties from your component can be accessed or mutated straight from JavaScript</li>
<li><code>$wire.title = ''</code> sets the value of <code>$title</code> in your Livewire component to an empty string</li>
<li>Any Livewire utilities like <code>wire:model</code> will instantly react to this change, all without sending a server-roundtrip</li>
<li>On the next Livewire network request, the <code>$title</code> property will be updated to an empty string on the backend</li>
</ul>
<h3 id="calling-livewire-methods">Calling Livewire methods</h3>
<p>Alpine can also easily call any Livewire methods/actions by simply calling them directly on <code>$wire</code>.</p>
<p>Here is an example of using Alpine to listen for a &quot;blur&quot; event on an input and triggering a form save. The &quot;blur&quot; event is dispatched by the browser when a user presses &quot;tab&quot; to remove focus from the current element and focus on the next one on the page:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">wire:submit</span>=<span class="hljs-string">"save"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">x-on:blur</span>=<span class="hljs-string">"$wire.save()"</span>&gt;</span>  <span class="hljs-comment">&lt;!-- [tl! highlight] --&gt;</span>

    <span class="hljs-comment">&lt;!-- ... --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>Typically, you would just use <code>wire:model.blur=&quot;title&quot;</code> in this situation, however, it's helpful for demonstration purposes how you can achieve this using Alpine.</p>
<h4 id="passing-parameters">Passing parameters</h4>
<p>You can also pass parameters to Livewire methods by simply passing them to the <code>$wire</code> method call.</p>
<p>Consider a component with a <code>deletePost()</code> method like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deletePost</span><span class="hljs-params">($postId)</span>
</span>{
    $post = Post::find($postId);

    <span class="hljs-comment">// Authorize user can delete...</span>
    auth()-&gt;user()-&gt;can(<span class="hljs-string">'update'</span>, $post);

    $post-&gt;delete();
}
</div></code></pre>
<p>Now, you can pass a <code>$postId</code> parameter to the <code>deletePost()</code> method from Alpine like so:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.deletePost(1)"</span>&gt;</span>
</div></code></pre>
<p>In general, something like a <code>$postId</code> would be generated in Blade. Here's an example of using Blade to determine which <code>$postId</code> Alpine passes into <code>deletePost()</code>:</p>
<pre class="hljs"><code><div>@foreach ($posts as $post)
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.deletePost({{ $post-&gt;id }})"</span>&gt;</span>
        Delete "{{ $post-&gt;title }}"
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
@endforeach
</div></code></pre>
<p>If there are three posts on the page, the above Blade template will render to something like the following in the browser:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.deletePost(1)"</span>&gt;</span>
    Delete "The power of walking"
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.deletePost(2)"</span>&gt;</span>
    Delete "How to record a song"
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.deletePost(3)"</span>&gt;</span>
    Delete "Teach what you learn"
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>As you can see, we've used Blade to render different post IDs into the Alpine <code>x-on:click</code> expressions.</p>
<h4 id="blade-parameter-%22gotchas%22">Blade parameter &quot;gotchas&quot;</h4>
<p>This is an extremely powerful technique, but can be confusing when reading your Blade templates. It can be hard to know which parts are Blade and which parts are Alpine at first glance. Therefore, it's helpful to inspect the HTML rendered on the page to make sure what you are expecting to be rendered is accurate.</p>
<p>Here's an example that commonly confuses people:</p>
<p>Let's say, instead of an ID, your Post model uses UUIDs for indexes (IDs are integers, and UUIDs are long strings of characters).</p>
<p>If we render the following just like we did with an ID there will be an issue:</p>
<pre class="hljs"><code><div><span class="hljs-comment">&lt;!-- Warning: this is an example of problematic code... --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>
    <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.deletePost({{ $post-&gt;uuid }})"</span>
&gt;</span>
</div></code></pre>
<p>The above Blade template will render the following in your HTML:</p>
<pre class="hljs"><code><div><span class="hljs-comment">&lt;!-- Warning: this is an example of problematic code... --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>
    <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.deletePost(93c7b04c-c9a4-4524-aa7d-39196011b81a)"</span>
&gt;</span>
</div></code></pre>
<p>Notice the lack of quotes around the UUID string? When Alpine goes to evaluate this expression, JavaScript will throw an error: &quot;Uncaught SyntaxError: Invalid or unexpected token&quot;.</p>
<p>To fix this, we need to add quotations around the Blade expression like so:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>
    <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.deletePost('{{ $post-&gt;uuid }}')"</span>
&gt;</span>
</div></code></pre>
<p>Now the above template will render properly and everything will work as expected:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>
    <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.deletePost('93c7b04c-c9a4-4524-aa7d-39196011b81a')"</span>
&gt;</span>
</div></code></pre>
<h3 id="refreshing-a-component">Refreshing a component</h3>
<p>You can easily refresh a Livewire component (trigger network roundtrip to re-render a component's Blade view) using <code>$wire.$refresh()</code>:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.$refresh()"</span>&gt;</span>
</div></code></pre>
<h2 id="sharing-state-using-wireentangle">Sharing state using <code>$wire.entangle</code></h2>
<p>In most cases, <code>$wire</code> is all you need for interacting with Livewire state from Alpine. However, Livewire provides an additional <code>$wire.entangle()</code> utililty that can be used to keep values from Livewire in-sync with values in Alpine.</p>
<p>To demonstrate, consider this dropdown example with its <code>showDropdown</code> property entangled between Livewire and Alpine using <code>$wire.entangle()</code>. By using entanglement, we are now able to control the state of the dropdown from both Alpine and Livewire:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostDropdown</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $showDropdown = <span class="hljs-keyword">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">archive</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>

        <span class="hljs-keyword">$this</span>-&gt;showDropdown = <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>

        <span class="hljs-keyword">$this</span>-&gt;showDropdown = <span class="hljs-keyword">false</span>;
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div x-data=&quot;{ open: $wire.entangle('showDropdown') }&quot;&gt;
    &lt;button x-on:click=&quot;open = true&quot;&gt;Show More...&lt;/button&gt;

    &lt;ul x-show=&quot;open&quot; x-on:click.outside=&quot;open = false&quot;&gt;
        &lt;li&gt;&lt;button wire:click=&quot;archive&quot;&gt;Archive&lt;/button&gt;&lt;/li&gt;

        &lt;li&gt;&lt;button wire:click=&quot;delete&quot;&gt;Delete&lt;/button&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</div></code></pre>
<p>A user can now toggle the dropdown immediately with Alpine, but when they click a Livewire action like &quot;Archive&quot;, the dropdown will be told to close from Livewire. Both Alpine and Livewire are welcome to manipulate their respective properties, and the other will automatically update.</p>
<p>By default, updating the state is deferred (changes on the client, but not immediately on the server) until the next Livewire request. If you need to update the state server-side as soon as the user clicks, chain the <code>.live</code> modifier like so:</p>
<pre class="hljs"><code><div>&lt;div x-data=&quot;{ open: $wire.entangle('showDropdown').live }&quot;&gt;
    ...
&lt;/div&gt;
</div></code></pre>
<blockquote>
<p>[!tip] You might not need <code>$wire.entangle</code>
In most cases, you can achieve what you want by using <code>$wire</code> to directly access Livewire properties from Alpine rather than entangling them. Entangling two properties rather than relying on one can cause predictibility and performance issues when using deeply nested objects that change frequently. For this reason, <code>$wire.entangle</code> has been de-emphasized in Livewire's documentation starting with version 3.</p>
</blockquote>
<blockquote>
<p>[!warning] Refrain from using the @@entangle directive
In Livewire version 2, it was recommended to use Blade's <code>@@entangle</code> directive. That is no longer the case in v3. <code>$wire.entangle()</code> is preffered as it is a more robust utility and avoids certain <a href="https://github.com/livewire/livewire/pull/6833#issuecomment-1902260844">issues when removing DOM elements</a>.</p>
</blockquote>
<h2 id="manually-bundling-alpine-in-your-javascript-build">Manually bundling Alpine in your JavaScript build</h2>
<p>By default, Livewire and Alpine's JavaScript is injected onto each Livewire page automatically.</p>
<p>This is ideal for simpler setups, however, you may want to include your own Alpine components, stores, and plugins into your project.</p>
<p>To include Livewire and Alpine via your own JavaScript bundle on a page is straightforward.</p>
<p>First, you must include the <code>@livewireScriptConfig</code> directive in your layout file like so:</p>
<pre class="hljs"><code><div>&lt;html&gt;
&lt;head&gt;
    &lt;!-- ... --&gt;
    @livewireStyles
    @vite(['resources/js/app.js'])
&lt;/head&gt;
&lt;body&gt;
    {{ $slot }}

    @livewireScriptConfig &lt;!-- [tl! highlight] --&gt;
&lt;/body&gt;
&lt;/html&gt;
</div></code></pre>
<p>This allows Livewire to provide your bundle with certain configuration it needs for your app to run properly.</p>
<p>Now you can import Livewire and Alpine in your <code>resources/js/app.js</code> file like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Livewire, Alpine } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../vendor/livewire/livewire/dist/livewire.esm'</span>;

<span class="hljs-comment">// Register any Alpine directives, components, or plugins here...</span>

Livewire.start()
</div></code></pre>
<p>Here is an example of registering a custom Alpine directive called &quot;x-clipboard&quot; in your application:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Livewire, Alpine } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../vendor/livewire/livewire/dist/livewire.esm'</span>;

Alpine.directive(<span class="hljs-string">'clipboard'</span>, (el) =&gt; {
    <span class="hljs-keyword">let</span> text = el.textContent

    el.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; {
        navigator.clipboard.writeText(text)
    })
})

Livewire.start()
</div></code></pre>
<p>Now the <code>x-clipboard</code> directive will be available to all your Alpine components in your Livewire application.</p>
<pre class="hljs"><code><div>
## File: best-practices.md
```md
* Start with extracting a Blade component first, then only do a Livewire component if you need to
* 
</div></code></pre>
<h2 id="file-blade-componentsmd">File: blade-components.md</h2>
<pre class="hljs"><code><div>
<span class="hljs-code">```blade
&lt;form wire:submit="save"&gt;
    &lt;label&gt;
        &lt;span&gt;Title&lt;/span&gt;

        &lt;input type="text" wire:model="title"&gt;

        @error('title') &lt;span&gt;{{ $message }}&lt;/span&gt; @enderror
    &lt;/label&gt;

    &lt;label&gt;
        &lt;span&gt;Title&lt;/span&gt;

        &lt;input type="text" wire:model="title"&gt;

        @error('title') &lt;span&gt;{{ $message }}&lt;/span&gt; @enderror
    &lt;/label&gt;

    &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;
</span></div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;x-input-text label=&quot;Title&quot; wire:model=&quot;title&quot; :error=&quot;$error-&gt;first('title')&quot; /&gt;

    &lt;x-input-text label=&quot;Content&quot; wire:model=&quot;content&quot; :error=&quot;$error-&gt;first('content')&quot; /&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<pre class="hljs"><code><div>@props(['label', 'error'])

&lt;label&gt;
    &lt;span&gt;{{ $label }}&lt;/span&gt;

    &lt;input type=&quot;text&quot; {{ $attributes-&gt;whereStartsWith('wire:') }}&gt;

    @if($error) &lt;span&gt;{{ $error }}&lt;/span&gt; @endif
&lt;/label&gt;
</div></code></pre>
<h2 id="injecting-and-running-assets">Injecting and running assets</h2>
<pre class="hljs"><code><div>@php $key = str()-&gt;uuid(); @endphp

&lt;div&gt;
    &lt;input type=&quot;text&quot; id=&quot;{{ $key }}&quot;&gt;
&lt;/div&gt;

@assets
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/pikaday/pikaday.js&quot; defer&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css&quot;&gt;
@endassets

@script
&lt;script&gt;
    new Pikaday({ field: document.getElementById('{{ $key }}') });
&lt;/script&gt;
@endscript
</div></code></pre>
<pre class="hljs"><code><div>
## File: bundling.md
```md
Every component update in Livewire triggers a network request. By default, when multiple components trigger updates at the same time, they are bundled into a single request.

This results in fewer network connections to the server and can durastically reduce server load.

In addition to the performance gains, this also unlocks features internally that require collaboration between multiple components ([Reactive Properties](/docs/nesting#reactive-props), [Modelable Properties](/docs/nesting#binding-to-child-data-using-wiremodel), etc.)

However, there are times when disabling this bundling is desired for performance reasons. The following page outlines various ways to customize this behavior in Livewire.

## Isolating component requests

By using Livewire's `#[Isolate]` class attribute, you can mark a component as &quot;isolated&quot;. This means that whenever that component makes a server roundtrip, it will attempt to isolate itself from other component requests.

This is useful if the update is expensive and you'd rather execute this component's update in parallel with others. For example, if multiple components are using `wire:poll` or listening for an event on the page, you may want to isolate specific component's who's updates are expensive and would otherwise hold up the entire request.

```php
use Livewire\Attributes\Isolate;
use Livewire\Component;

#[Isolate] // [tl! highlight]
class ShowPost extends Component
{
    // ...
}
</div></code></pre>
<p>By adding the <code>#[Isolate]</code> attribute, this component's requests will no longer be bundled with other component updates.</p>
<h2 id="lazy-components-are-isolated-by-default">Lazy components are isolated by default</h2>
<p>When many components on a single page are &quot;lazy&quot; loaded (using the <code>#[Lazy]</code> attribute), it is often desired that their requests are isolated and sent in parallel. Therefore, Livewire isolates lazy updates by default.</p>
<p>If you wish to disable this behavior, you can pass an <code>isolate: false</code> parameter into the <code>#[Lazy]</code> attribute like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Lazy</span>;

<span class="hljs-comment">#[Lazy(isolate: false)] // [tl! highlight]</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Revenue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now, if there are multiple <code>Revenue</code> components on the same page, all ten updates will be bundled and sent the server as single, lazy-load, network request.</p>
<pre class="hljs"><code><div>
## File: component-hooks.md
```md
## Global Component Hooks

In cases where you want to add features or behavior to every single component in your application, you can use Livewire &quot;Component Hooks&quot;.

Component Hooks allow you to define a single class with the ability to hook in to a Livewire component's lifecycle externally (not on the component class itself, and not in a trait).

Before we look at an actual example of using them, here's a generic Component Hook class showing every available method you can use inside them:

```php
use Livewire\ComponentHook;

class MyComponentHook extends ComponentHook
{
    public static function provide()
    {
        // Runs once at application boot.
        // Can be used to register any services you may need.
    }

    public function mount($params, $parent)
    {
        // Called when a component is &quot;mounted&quot;
        // 
        // $params: Array of parameters passed into the component
        // $parent: The parent component object if this is a nested component
    }

    public function hydrate($memo)
    {
        // Called when a component is &quot;hydrated&quot;
        //
        // $memo: An associative array of the &quot;dehydrated&quot; metadata for this component
    }

    public function boot()
    {
        // Called when the component boots
    }

    public function update($property, $path, $value)
    {
        // Called before the component updates...

        return function () {
            // Called after the component property has updated...
        };
    }

    public function call($method, $params, $returnEarly)
    {
        // Called before a method on the component is called...

        return function ($returnValue) {
            // Called after a method is called
        };
    }

    public function render($view, $data)
    {
        // Called after &quot;render&quot; is called but before the Blade has been rendered...
        return function ($html) {
            // Called after the component's view has been rendered
        };
    }

    public function dehydrate($context)
    {
        // Called when a component &quot;dehydrates&quot;
    }

    public function exception($e, $stopPropagation)
    {
        // Called if an exception is thrown within a component...
    }
}
</div></code></pre>
<p>You can register a Component Hook from a service provider like your <code>App\Providers\AppServiceProvider</code> like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Providers</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">ServiceProvider</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppServiceProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceProvider</span>
</span>{
    <span class="hljs-comment">/**
     * Bootstrap any application services.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boot</span><span class="hljs-params">()</span>: <span class="hljs-title">void</span>
    </span>{
        Livewire::componentHook(MyComponentHook::class);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now that you've seen the broad overview of Component Hooks, here's a more practical example of using them to provide useful functionality for your application.</p>
<p>Let's say you wanted to support the ability return a CSV from any Livewire action, and it would automatically trigger a file download. For example, you could return a Csv from a method called <code>save</code> inside a <code>CreatePost</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $username = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $email = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">something</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Csv();
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">ComponentHook</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupportCsvDownloads</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHook</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span><span class="hljs-params">($method, $params, $returnEarly)</span>
    </span>{
        <span class="hljs-comment">// Called before a method on the component is called...</span>

        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($returnValue)</span> </span>{
            <span class="hljs-keyword">if</span> ($returnValue <span class="hljs-keyword">instanceof</span> Csv) {
                <span class="hljs-comment">// do something</span>
            }
        };
    }
}
</div></code></pre>
<p>You can</p>
<pre class="hljs"><code><div>
## File: components.md
```md
Components are the building blocks of your Livewire application. They combine state and behavior to create reusable pieces of UI for your front end. Here, we'll cover the basics of creating and rendering components.

## Creating components

A Livewire component is simply a PHP class that extends `Livewire\Component`. You can create component files by hand or use the following Artisan command:

```shell
php artisan make:livewire CreatePost
</div></code></pre>
<p>If you prefer kebab-cased names, you can use them as well:</p>
<pre class="hljs"><code><div>php artisan make:livewire create-post
</div></code></pre>
<p>After running this command, Livewire will create two new files in your application. The first will be the component's class: <code>app/Livewire/CreatePost.php</code></p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>);
	}
}
</div></code></pre>
<p>The second will be the component's Blade view: <code>resources/views/livewire/create-post.blade.php</code></p>
<pre class="hljs"><code><div>&lt;div&gt;
	{{-- ... --}}
&lt;/div&gt;
</div></code></pre>
<p>You may use namespace syntax or dot-notation to create your components in sub-directories. For example, the following commands will create a <code>CreatePost</code> component in the <code>Posts</code> sub-directory:</p>
<pre class="hljs"><code><div>php artisan make:livewire Posts\\CreatePost
php artisan make:livewire posts.create-post
</div></code></pre>
<h3 id="inline-components">Inline components</h3>
<p>If your component is fairly small, you may want to create an <em>inline</em> component. Inline components are single-file Livewire components whose view template is contained directly in the <code>render()</code> method rather than a separate file:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> &lt;&lt;&lt;<span class="hljs-string">'HTML'</span> <span class="hljs-comment">// [tl! highlight:4]</span>
		&lt;div&gt;
		    {{-- Your Blade template goes here... --}}
		&lt;/div&gt;
		HTML;
	}
}
</div></code></pre>
<p>You can create inline components by adding the <code>--inline</code> flag to the <code>make:livewire</code> command:</p>
<pre class="hljs"><code><div>php artisan make:livewire CreatePost --inline
</div></code></pre>
<h3 id="omitting-the-render-method">Omitting the render method</h3>
<p>To reduce boilerplate in your components, you can omit the <code>render()</code> method entirely and Livewire will use its own underlying <code>render()</code> method, which returns a view with the conventional name corresponding to your component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">//</span>
}
</div></code></pre>
<p>If the component above is rendered on a page, Livewire will automatically determine it should be rendered using the <code>livewire.create-post</code> template.</p>
<h3 id="customizing-component-stubs">Customizing component stubs</h3>
<p>You can customize the files (or <em>stubs</em>) Livewire uses to generate new components by running the following command:</p>
<pre class="hljs"><code><div>php artisan livewire:stubs
</div></code></pre>
<p>This will create four new files in your application:</p>
<ul>
<li><code>stubs/livewire.stub</code> — used for generating new components</li>
<li><code>stubs/livewire.inline.stub</code> — used for generating <em>inline</em> components</li>
<li><code>stubs/livewire.test.stub</code> — used for generating test files</li>
<li><code>stubs/livewire.view.stub</code> — used for generating component views</li>
</ul>
<p>Even though these files live in your application, you can still use the <code>make:livewire</code> Artisan command and Livewire will automatically use your custom stubs when generating files.</p>
<h2 id="setting-properties">Setting properties</h2>
<p>Livewire components have properties that store data and can be easily accessed within the component's class and Blade view. This section discusses the basics of adding a property to a component and using it in your application.</p>
<p>To add a property to a Livewire component, declare a public property in your component class. For example, let's create a <code>$title</code> property in the <code>CreatePost</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">'Post title...'</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>);
    }
}
</div></code></pre>
<h3 id="accessing-properties-in-the-view">Accessing properties in the view</h3>
<p>Component properties are automatically made available to the component's Blade view. You can reference it using standard Blade syntax. Here we'll display the value of the <code>$title</code> property:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;Title: &quot;{{ $title }}&quot;&lt;/h1&gt;
&lt;/div&gt;
</div></code></pre>
<p>The rendered output of this component would be:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;Title: &quot;Post title...&quot;&lt;/h1&gt;
&lt;/div&gt;
</div></code></pre>
<h3 id="sharing-additional-data-with-the-view">Sharing additional data with the view</h3>
<p>In addition to accessing properties from the view, you can explicitly pass data to the view from the <code>render()</code> method, like you might typically do from a controller. This can be useful when you want to pass additional data without first storing it as a property—because properties have <a href="/docs/properties#security-concerns">specific performance and security implications</a>.</p>
<p>To pass data to the view in the <code>render()</code> method, you can use the <code>with()</code> method on the view instance. For example, let's say you want to pass the post author's name to the view. In this case, the post's author is the currently authenticated user:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $title;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>)-&gt;with([
	        <span class="hljs-string">'author'</span> =&gt; Auth::user()-&gt;name,
	    ]);
    }
}
</div></code></pre>
<p>Now you may access the <code>$author</code> property from the component's Blade view:</p>
<pre class="hljs"><code><div>&lt;div&gt;
	&lt;h1&gt;Title: {{ $title }}&lt;/h1&gt;

	&lt;span&gt;Author: {{ $author }}&lt;/span&gt;
&lt;/div&gt;
</div></code></pre>
<h3 id="adding-wirekey-to-foreach-loops">Adding <code>wire:key</code> to <code>@foreach</code> loops</h3>
<p>When looping through data in a Livewire template using <code>@foreach</code>, you must add a unique <code>wire:key</code> attribute to the root element rendered by the loop.</p>
<p>Without a <code>wire:key</code> attribute present within a Blade loop, Livewire won't be able to properly match old elements to their new positions when the loop changes. This can cause many hard to diagnose issues in your application.</p>
<p>For example, if you are looping through an array of posts, you may set the <code>wire:key</code> attribute to the post's ID:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;div wire:key=&quot;{{ $post-&gt;id }}&quot;&gt; &lt;!-- [tl! highlight] --&gt;
            &lt;!-- ... --&gt;
        &lt;/div&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>If you are looping through an array that is rendering Livewire components you may set the key as a component attribute <code>:key()</code> or pass the key as a third argument when using the <code>@livewire</code> directive.</p>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;livewire:post-item :$post :key=&quot;$post-&gt;id&quot;&gt;

        @livewire(PostItem::class, ['post' =&gt; $post], key($post-&gt;id))
    @endforeach
&lt;/div&gt;
</div></code></pre>
<h3 id="binding-inputs-to-properties">Binding inputs to properties</h3>
<p>One of Livewire's most powerful features is &quot;data binding&quot;: the ability to automatically keep properties in-sync with form inputs on the page.</p>
<p>Let's bind the <code>$title</code> property from the <code>CreatePost</code> component to a text input using the <code>wire:model</code> directive:</p>
<pre class="hljs"><code><div>&lt;form&gt;
    &lt;label for=&quot;title&quot;&gt;Title:&lt;/label&gt;

    &lt;input type=&quot;text&quot; id=&quot;title&quot; wire:model=&quot;title&quot;&gt; &lt;!-- [tl! highlight] --&gt;
&lt;/form&gt;
</div></code></pre>
<p>Any changes made to the text input will be automatically synchronized with the <code>$title</code> property in your Livewire component.</p>
<blockquote>
<p>[!warning] &quot;Why isn't my component live updating as I type?&quot;
If you tried this in your browser and are confused why the title isn't automatically updating, it's because Livewire only updates a component when an &quot;action&quot; is submitted—like pressing a submit button—not when a user types into a field. This cuts down on network requests and improves performance. To enable &quot;live&quot; updating as a user types, you can use <code>wire:model.live</code> instead. <a href="/docs/properties#data-binding">Learn more about data binding</a>.</p>
</blockquote>
<p>Livewire properties are extremely powerful and are an important concept to understand. For more information, check out the <a href="/docs/properties">Livewire properties documentation</a>.</p>
<h2 id="calling-actions">Calling actions</h2>
<p>Actions are methods within your Livewire component that handle user interactions or perform specific tasks. They're often useful for responding to button clicks or form submissions on a page.</p>
<p>To learn more about actions, let's add a <code>save</code> action to the <code>CreatePost</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $title;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:8]
    </span>{
		$post = Post::create([
			<span class="hljs-string">'title'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;title
		]);

		<span class="hljs-keyword">return</span> redirect()-&gt;to(<span class="hljs-string">'/posts'</span>)
			 -&gt;with(<span class="hljs-string">'status'</span>, <span class="hljs-string">'Post created!'</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>);
    }
}
</div></code></pre>
<p>Next, let's call the <code>save</code> action from the component's Blade view by adding the <code>wire:submit</code> directive to the <code>&lt;form&gt;</code> element:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt; &lt;!-- [tl! highlight] --&gt;
    &lt;label for=&quot;title&quot;&gt;Title:&lt;/label&gt;

    &lt;input type=&quot;text&quot; id=&quot;title&quot; wire:model=&quot;title&quot;&gt;

	&lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>When the &quot;Save&quot; button is clicked, the <code>save()</code> method in your Livewire component will be executed and your component will re-render.</p>
<p>To keep learning about Livewire actions, visit the <a href="/docs/actions">actions documentation</a>.</p>
<h2 id="rendering-components">Rendering components</h2>
<p>There are two ways to render a Livewire component on a page:</p>
<ol>
<li>Include it within an existing Blade view</li>
<li>Assign it directly to a route as a full-page component</li>
</ol>
<p>Let's cover the first way to render your component, as it's simpler than the second.</p>
<p>You can include a Livewire component in your Blade templates using the <code>&lt;livewire:component-name /&gt;</code> syntax:</p>
<pre class="hljs"><code><div>&lt;livewire:create-post /&gt;
</div></code></pre>
<p>If the component class is nested deeper within the <code>app/Livewire/</code> directory, you may use the <code>.</code> character to indicate directory nesting. For example, if we assume a component is located at <code>app/Livewire/EditorPosts/CreatePost.php</code>, we may render it like so:</p>
<pre class="hljs"><code><div>&lt;livewire:editor-posts.create-post /&gt;
</div></code></pre>
<blockquote>
<p>[!warning] You must use kebab-case
As you can see in the snippets above, you must use the <em>kebab-cased</em> version of the component name. Using the <em>StudlyCase</em> version of the name (<code>&lt;livewire:CreatePost /&gt;</code>) is invalid and won't be recognized by Livewire.</p>
</blockquote>
<h3 id="passing-data-into-components">Passing data into components</h3>
<p>To pass outside data into a Livewire component, you can use attributes on the component tag. This is useful when you want to initialize a component with specific data.</p>
<p>To pass an initial value to the <code>$title</code> property of the <code>CreatePost</code> component, you can use the following syntax:</p>
<pre class="hljs"><code><div>&lt;livewire:create-post title=&quot;Initial Title&quot; /&gt;
</div></code></pre>
<p>If you need to pass dynamic values or variables to a component, you can write PHP expressions in component attributes by prefixing the attribute with a colon:</p>
<pre class="hljs"><code><div>&lt;livewire:create-post :title=&quot;$initialTitle&quot; /&gt;
</div></code></pre>
<p>Data passed into components is received through the <code>mount()</code> lifecycle hook as method parameters. In this case, to assign the <code>$title</code> parameter to a property, you would write a <code>mount()</code> method like the following:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $title;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($title = null)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;title = $title;
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>In this example, the <code>$title</code> property will be initialized with the value &quot;Initial Title&quot;.</p>
<p>You can think of the <code>mount()</code> method as a class constructor. It runs on the initial load of the component, but not on subsequent requests within a page. You can learn more about <code>mount()</code> and other helpful lifecycle hooks within the <a href="/docs/lifecycle-hooks">lifecycle documentation</a>.</p>
<p>To reduce boilerplate code in your components, you can alternatively omit the <code>mount()</code> method and Livewire will automatically set any properties on your component with names matching the passed in values:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $title; <span class="hljs-comment">// [tl! highlight]</span>

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>This is effectively the same as assigning <code>$title</code> inside a <code>mount()</code> method.</p>
<blockquote>
<p>[!warning] These properties are not reactive by default
The <code>$title</code> property will not update automatically if the outer <code>:title=&quot;$initialValue&quot;</code> changes after the initial page load. This is a common point of confusion when using Livewire, especially for developers who have used JavaScript frameworks like Vue or React and assume these &quot;parameters&quot; behave like &quot;reactive props&quot; in those frameworks. But, don't worry, Livewire allows you to opt-in to <a href="/docs/nesting#reactive-props">making your props reactive</a>.</p>
</blockquote>
<h2 id="full-page-components">Full-page components</h2>
<p>Livewire allows you to assign components directly to a route in your Laravel application. These are called &quot;full-page components&quot;. You can use them to build standalone pages with logic and views, fully encapsulated within a Livewire component.</p>
<p>To create a full-page component, define a route in your <code>routes/web.php</code> file and use the <code>Route::get()</code> method to map the component directly to a specific URL. For example, let's imagine you want to render the <code>CreatePost</code> component at the dedicated route: <code>/posts/create</code>.</p>
<p>You can accomplish this by adding the following line to your <code>routes/web.php</code> file:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;

Route::get(<span class="hljs-string">'/posts/create'</span>, CreatePost::class);
</div></code></pre>
<p>Now, when you visit the <code>/posts/create</code> path in your browser, the <code>CreatePost</code> component will be rendered as a full-page component.</p>
<h3 id="layout-files">Layout files</h3>
<p>Remember that full-page components will use your application's layout, typically defined in the <code>resources/views/components/layouts/app.blade.php</code> file.</p>
<p>You may create this file if it doesn't already exist by running the following command:</p>
<pre class="hljs"><code><div>php artisan livewire:layout
</div></code></pre>
<p>This command will generate a file called <code>resources/views/components/layouts/app.blade.php</code>.</p>
<p>Ensure you have created a Blade file at this location and included a <code>{{ $slot }}</code> placeholder:</p>
<pre class="hljs"><code><div>&lt;!-- resources/views/components/layouts/app.blade.php --&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;{{ str_replace('_', '-', app()-&gt;getLocale()) }}&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;

        &lt;title&gt;{{ $title ?? 'Page Title' }}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        {{ $slot }}
    &lt;/body&gt;
&lt;/html&gt;
</div></code></pre>
<h4 id="global-layout-configuration">Global layout configuration</h4>
<p>To use a custom layout across all your components, you can set the <code>layout</code> key in <code>config/livewire.php</code> to the path of your custom layout, relative to <code>resources/views</code>. For example:</p>
<pre class="hljs"><code><div><span class="hljs-string">'layout'</span> =&gt; <span class="hljs-string">'layouts.app'</span>,
</div></code></pre>
<p>With the above configuration, Livewire will render full-page components inside the layout file: <code>resources/views/layouts/app.blade.php</code>.</p>
<h4 id="per-component-layout-configuration">Per-component layout configuration</h4>
<p>To use a different layout for a specific component, you can place Livewire's <code>#[Layout]</code> attribute above the component's <code>render()</code> method, passing it the relative view path of your custom layout:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Layout</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-comment">// ...</span>

	<span class="hljs-comment">#[Layout('layouts.app')] // [tl! highlight]</span>
	<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
	</span>{
	    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>);
	}
}
</div></code></pre>
<p>Or if you prefer, you can use this attribute above the class declaration:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Layout</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-comment">#[Layout('layouts.app')] // [tl! highlight]</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>PHP attributes only support literal values. If you need to pass a dynamic value, or prefer this alternative syntax, you can use the fluent <code>-&gt;layout()</code> method in the component's <code>render()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>)
	     -&gt;layout(<span class="hljs-string">'layouts.app'</span>); <span class="hljs-comment">// [tl! highlight]</span>
}
</div></code></pre>
<p>Alternatively, Livewire supports using traditional Blade layout files with <code>@extends</code>.</p>
<p>Given the following layout file:</p>
<pre class="hljs"><code><div>&lt;body&gt;
    @yield('content')
&lt;/body&gt;
</div></code></pre>
<p>You can configure Livewire to reference it using <code>-&gt;extends()</code> instead of <code>-&gt;layout()</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>)
        -&gt;extends(<span class="hljs-string">'layouts.app'</span>); <span class="hljs-comment">// [tl! highlight]</span>
}
</div></code></pre>
<p>If you need to configure the <code>@section</code> for the component to use, you can configure that as well with the <code>-&gt;section()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>)
        -&gt;extends(<span class="hljs-string">'layouts.app'</span>)
        -&gt;section(<span class="hljs-string">'body'</span>); <span class="hljs-comment">// [tl! highlight]</span>
}
</div></code></pre>
<h3 id="setting-the-page-title">Setting the page title</h3>
<p>Assigning unique page titles to each page in your application is helpful for both users and search engines.</p>
<p>To set a custom page title for a full-page component, first, make sure your layout file includes a dynamic title:</p>
<pre class="hljs"><code><div>&lt;head&gt;
    &lt;title&gt;{{ $title ?? 'Page Title' }}&lt;/title&gt;
&lt;/head&gt;
</div></code></pre>
<p>Next, above your Livewire component's <code>render()</code> method, add the <code>#[Title]</code> attribute and pass it your page title:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Title</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-comment">// ...</span>

	<span class="hljs-comment">#[Title('Create Post')] // [tl! highlight]</span>
	<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
	</span>{
	    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>);
	}
}
</div></code></pre>
<p>This will set the page title for the <code>CreatePost</code> Livewire component. In this example, the page title will be &quot;Create Post&quot; when the component is rendered.</p>
<p>If you prefer, you can use this attribute above the class declaration:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Title</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-comment">#[Title('Create Post')] // [tl! highlight]</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>If you need to pass a dynamic title, such as a title that uses a component property, you can use the <code>-&gt;title()</code> fluent method in the component's <code>render()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>)
	     -&gt;title(<span class="hljs-string">'Create Post'</span>); <span class="hljs-comment">// [tl! highlight]</span>
}
</div></code></pre>
<h3 id="setting-additional-layout-file-slots">Setting additional layout file slots</h3>
<p>If your <a href="#layout-files">layout file</a> has any named slots in addition to <code>$slot</code>, you can set their content in your Blade view by defining <code>&lt;x-slot&gt;</code>s outside your root element. For example, if you want to be able to set the page language for each component individually, you can add a dynamic <code>$lang</code> slot into the opening HTML tag in your layout file:</p>
<pre class="hljs"><code><div>&lt;!-- resources/views/components/layouts/app.blade.php --&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;{{ str_replace('_', '-', $lang ?? app()-&gt;getLocale()) }}&quot;&gt; // [tl! highlight]
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;

        &lt;title&gt;{{ $title ?? 'Page Title' }}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        {{ $slot }}
    &lt;/body&gt;
&lt;/html&gt;
</div></code></pre>
<p>Then, in your component view, define an <code>&lt;x-slot&gt;</code> element outside the root element:</p>
<pre class="hljs"><code><div>&lt;x-slot:lang&gt;fr&lt;/x-slot&gt; // This component is in French [tl! highlight]

&lt;div&gt;
    // French content goes here...
&lt;/div&gt;
</div></code></pre>
<h3 id="accessing-route-parameters">Accessing route parameters</h3>
<p>When working with full-page components, you may need to access route parameters within your Livewire component.</p>
<p>To demonstrate, first, define a route with a parameter in your <code>routes/web.php</code> file:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">ShowPost</span>;

Route::get(<span class="hljs-string">'/posts/{id}'</span>, ShowPost::class);
</div></code></pre>
<p>Here, we've defined a route with an <code>id</code> parameter which represents a post's ID.</p>
<p>Next, update your Livewire component to accept the route parameter in the <code>mount()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($id)</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>]
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = Post::findOrFail($id);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-post'</span>);
    }
}
</div></code></pre>
<p>In this example, because the parameter name <code>$id</code> matches the route parameter <code>{id}</code>, if the <code>/posts/1</code> URL is visited, Livewire will pass the value of &quot;1&quot; as <code>$id</code>.</p>
<h3 id="using-route-model-binding">Using route model binding</h3>
<p>Laravel's route model binding allows you to automatically resolve Eloquent models from route parameters.</p>
<p>After defining a route with a model parameter in your <code>routes/web.php</code> file:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">ShowPost</span>;

Route::get(<span class="hljs-string">'/posts/{post}'</span>, ShowPost::class);
</div></code></pre>
<p>You can now accept the route model parameter through the <code>mount()</code> method of your component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>]
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = $post;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-post'</span>);
    }
}
</div></code></pre>
<p>Livewire knows to use &quot;route model binding&quot; because the <code>Post</code> type-hint is prepended to the <code>$post</code> parameter in <code>mount()</code>.</p>
<p>Like before, you can reduce boilerplate by omitting the <code>mount()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post; <span class="hljs-comment">// [tl! highlight]</span>

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-post'</span>);
    }
}
</div></code></pre>
<p>The <code>$post</code> property will automatically be assigned to the model bound via the route's <code>{post}</code> parameter.</p>
<h3 id="modifying-the-response">Modifying the response</h3>
<p>In some scenarios you might want to modify the response and set a custom response header. You can hook into the response object by calling the <code>response()</code> method on the view and use a closure to modify the response object:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Http</span>\<span class="hljs-title">Response</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-post'</span>)
            -&gt;response(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(Response $response)</span> </span>{
                $response-&gt;header(<span class="hljs-string">'X-Custom-Header'</span>, <span class="hljs-keyword">true</span>);
            });
    }
}
</div></code></pre>
<h2 id="using-javascript">Using JavaScript</h2>
<p>There are many instances where the built-in Livewire and Alpine utilities aren't enough to accomplish your goals inside your Livewire components.</p>
<p>Fortunately, Livewire provides many useful extension points and utilities to interact with bespoke JavaScript. You can learn from the exhaustive reference on <a href="/docs/javascript">the JavaScript documentation page</a>. But for now, here are a few useful ways to use your own JavaScript inside your Livewire components.</p>
<h3 id="executing-scripts">Executing scripts</h3>
<p>Livewire provides a helpful <code>@script</code> directive that, when wrapping a <code>&lt;script&gt;</code> element, will execute the given JavaScript when your component is initialized on the page.</p>
<p>Here is an example of a simple <code>@script</code> that uses JavaScript's <code>setInterval()</code> to refresh your component every two seconds:</p>
<pre class="hljs"><code><div>@script
&lt;script&gt;
    setInterval(() =&gt; {
        $wire.$refresh()
    }, 2000)
&lt;/script&gt;
@endscript
</div></code></pre>
<p>You'll notice we are using an object called <code>$wire</code> inside the <code>&lt;script&gt;</code> to control the component. Livewire automatically makes this object available inside any <code>@script</code>s. If you're unfamiliar with <code>$wire</code>, you can learn more about <code>$wire</code> in the following documentation:</p>
<ul>
<li><a href="/docs/properties#accessing-properties-from-javascript">Accessing properties from JavaScript</a></li>
<li><a href="/docs/actions#calling-actions-from-alpine">Calling Livewire actions from JS/Alpine</a></li>
<li><a href="/docs/javascript#the-wire-object">The <code>$wire</code> object reference</a></li>
</ul>
<h3 id="loading-assets">Loading assets</h3>
<p>In addition to one-off <code>@script</code>s, Livewire provides a helpful <code>@assets</code> utility to easily load any script/style dependencies on the page.</p>
<p>It also ensures that the provided assets are loaded only once per browser page, unlike <code>@script</code>, which executes every time a new instance of that Livewire component is initialized.</p>
<p>Here is an example of using <code>@assets</code> to load a date picker library called <a href="https://github.com/Pikaday/Pikaday">Pikaday</a> and initialize it inside your component using <code>@script</code>:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;input type=&quot;text&quot; data-picker&gt;
&lt;/div&gt;

@assets
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/pikaday/pikaday.js&quot; defer&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css&quot;&gt;
@endassets

@script
&lt;script&gt;
    new Pikaday({ field: $wire.$el.querySelector('[data-picker]') });
&lt;/script&gt;
@endscript
</div></code></pre>
<blockquote>
<p>[!info] Using <code>@verbatim@script@endverbatim</code> and <code>@verbatim@assets@endverbatim</code> inside Blade components
If you are using <a href="https://laravel.com/docs/blade#components">Blade components</a> to extract parts of your markup, you can use <code>@verbatim@script@endverbatim</code> and <code>@verbatim@assets@endverbatim</code> inside them as well; even if there are multiple Blade components inside the same Livewire component. However, <code>@verbatim@script@endverbatim</code> and <code>@verbatim@assets@endverbatim</code> are currently only supported in the context of a Livewire component, meaning if you use the given Blade component outside of Livewire entirely, those scripts and assets won't be loaded on the page.</p>
</blockquote>
<pre class="hljs"><code><div>
## File: computed-properties.md
```md
Computed properties are a way to create &quot;derived&quot; properties in Livewire. Like accessors on an Eloquent model, computed properties allow you to access values and cache them for future access during the request.

Computed properties are particularly useful in combination with component's public properties.

## Basic usage

To create a computed property, you can add the `#[Computed]` attribute above any method in your Livewire component. Once the attribute has been added to the method, you can access it like any other property.

&gt; [!warning] Make sure you import attribute classes
&gt; Make sure you import any attribute classes. For example, the below `#[Computed]` attribute requires the following import `use Livewire\Attributes\Computed;`.

For example, here's a `ShowUser` component that uses a computed property named `user()` to access a `User` Eloquent model based on a property named `$userId`:

```php
&lt;?php

use Illuminate\Support\Facades\Auth;
use Livewire\Attributes\Computed;
use Livewire\Component;
use App\Models\User;

class ShowUser extends Component
{
    public $userId;

    #[Computed]
    public function user()
    {
        return User::find($this-&gt;userId);
    }

    public function follow()
    {
        Auth::user()-&gt;follow($this-&gt;user);
    }

    public function render()
    {
        return view('livewire.show-user');
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;{{ $this-&gt;user-&gt;name }}&lt;/h1&gt;

    &lt;span&gt;{{ $this-&gt;user-&gt;email }}&lt;/span&gt;

    &lt;button wire:click=&quot;follow&quot;&gt;Follow&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>Because the <code>#[Computed]</code> attribute has been added to the <code>user()</code> method, the value is accessible in other methods in the component and within the Blade template.</p>
<blockquote>
<p>[!info] Must use <code>$this</code> in your template
Unlike normal properties, computed properties aren't directly available inside your component's template. Instead, you must access them on the <code>$this</code> object. For example, a computed property named <code>posts()</code> must be accessed via <code>$this-&gt;posts</code> inside your template.</p>
</blockquote>
<blockquote>
<p>[!warning] Computed properties are not supported on <code>Livewire\Form</code> objects.
Trying to use a Computed property within a <a href="https://livewire.laravel.com/docs/forms">Form</a> will result in an error when you attempt to access the property in blade using $form-&gt;property syntax.</p>
</blockquote>
<h2 id="performance-advantage">Performance advantage</h2>
<p>You may be asking yourself: why use computed properties at all? Why not just call the method directly?</p>
<p>Accessing a method as a computed property offers a performance advantage over calling a method. Internally, when a computed property is executed for the first time, Livewire caches the returned value. This way, any subsequent accesses in the request will return the cached value instead of executing multiple times.</p>
<p>This allows you to freely access a derived value and not worry about the performance implications.</p>
<blockquote>
<p>[!warning] Computed properties are only cached for a single request
It's a common misconception that Livewire caches computed properties for the entire lifespan of your Livewire component on a page. However, this isn't the case. Instead, Livewire only caches the result for the duration of a single component request. This means that if your computed property method contains an expensive database query, it will be executed every time your Livewire component performs an update.</p>
</blockquote>
<h3 id="busting-the-cache">Busting the cache</h3>
<p>Consider the following problematic scenario:</p>
<ol>
<li>You access a computed property that depends on a certain property or database state</li>
<li>The underlying property or database state changes</li>
<li>The cached value for the property becomes stale and needs to be re-computed</li>
</ol>
<p>To clear, or &quot;bust&quot;, the stored cache, you can use PHP's <code>unset()</code> function.</p>
<p>Below is an example of an action called <code>createPost()</code> that, by creating a new post in the application, makes the <code>posts()</code> computed stale — meaning the computed property <code>posts()</code> needs to be re-computed to include the newly added post:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPost</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;posts-&gt;count() &gt; <span class="hljs-number">10</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> \<span class="hljs-keyword">Exception</span>(<span class="hljs-string">'Maximum post count exceeded'</span>);
        }

        Auth::user()-&gt;posts()-&gt;create(...);

        <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;posts); <span class="hljs-comment">// [tl! highlight]</span>
    }

    <span class="hljs-comment">#[Computed]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">posts</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> Auth::user()-&gt;posts;
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>In the above component, the computed property is cached before a new post is created because the <code>createPost()</code> method accesses <code>$this-&gt;posts</code> before the new post is created. To ensure that <code>$this-&gt;posts</code> contains the most up-to-date contents when accessed inside the view, the cache is invalidated using <code>unset($this-&gt;posts)</code>.</p>
<h3 id="caching-between-requests">Caching between requests</h3>
<p>Sometimes you would like to cache the value of a computed property for the lifespan of a Livewire component, rather than it being cleared after every request. In these cases, you can use <a href="https://laravel.com/docs/cache#retrieve-store">Laravel's caching utilities</a>.</p>
<p>Below is an example of a computed property named <code>user()</code>, where instead of executing the Eloquent query directly, we wrap the query in <code>Cache::remember()</code> to ensure that any future requests retrieve it from Laravel's cache instead of re-executing the query:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Cache</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $userId;

    <span class="hljs-comment">#[Computed]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">user</span><span class="hljs-params">()</span>
    </span>{
        $key = <span class="hljs-string">'user'</span>.<span class="hljs-keyword">$this</span>-&gt;getId();
        $seconds = <span class="hljs-number">3600</span>; <span class="hljs-comment">// 1 hour...</span>

        <span class="hljs-keyword">return</span> Cache::remember($key, $seconds, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> User::find(<span class="hljs-keyword">$this</span>-&gt;userId);
        });
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Because each unique instance of a Livewire component has a unique ID, we can use <code>$this-&gt;getId()</code> to generate a unique cache key that will only be applied to future requests for this same component instance.</p>
<p>But, as you may have noticed, most of this code is predictable and can easily be abstracted. Because of this, Livewire's <code>#[Computed]</code> attribute provides a helpful <code>persist</code> parameter. By applying <code>#[Computed(persist: true)]</code> to a method, you can achieve the same result without any extra code:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;

<span class="hljs-comment">#[Computed(persist: true)]</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">user</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> User::find(<span class="hljs-keyword">$this</span>-&gt;userId);
}
</div></code></pre>
<p>In the example above, when <code>$this-&gt;user</code> is accessed from your component, it will continue to be cached for the duration of the Livewire component on the page. This means the actual Eloquent query will only be executed once.</p>
<p>Livewire caches persisted values for 3600 seconds (one hour). You can override this default by passing an additional <code>seconds</code> parameter to the <code>#[Computed]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-comment">#[Computed(persist: true, seconds: 7200)]</span>
</div></code></pre>
<blockquote>
<p>[!tip] Calling <code>unset()</code> will bust this cache
As previously discussed, you can clear a computed property's cache using PHP's <code>unset()</code> method. This also applies to computed properties using the <code>persist: true</code> parameter. When calling <code>unset()</code> on a cached computed property, Livewire will clear not only the computed property cache, but also the underlying cached value in Laravel's cache.</p>
</blockquote>
<h2 id="caching-across-all-components">Caching across all components</h2>
<p>Instead of caching the value of a computed property for the duration of a single component's lifecycle, you can cache the value of a computed across all components in your application using the <code>cache: true</code> parameter provided by the <code>#[Computed]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-comment">#[Computed(cache: true)]</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">posts</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Post::all();
}
</div></code></pre>
<p>In the above example, until the cache expires or is busted, every instance of this component in your application will share the same cached value for <code>$this-&gt;posts</code>.</p>
<p>If you need to manually clear the cache for a computed property, you may set a custom cache key using the <code>key</code> parameter:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-comment">#[Computed(cache: true, key: 'homepage-posts')]</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">posts</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Post::all();
}
</div></code></pre>
<h2 id="when-to-use-computed-properties">When to use computed properties?</h2>
<p>In addition to offering performance advantages, there are a few other scenarios where computed properties are helpful.</p>
<p>Specifically, when passing data into your component's Blade template, there are a few occasions where a computed property is a better alternative. Below is an example of a simple component's <code>render()</code> method passing a collection of <code>posts</code> to a Blade template:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>, [
        <span class="hljs-string">'posts'</span> =&gt; Post::all(),
    ]);
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;!-- ... --&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>Although this is sufficient for many use cases, here are three scenarios where a computed property would be a better alternative:</p>
<h3 id="conditionally-accessing-values">Conditionally accessing values</h3>
<p>If you are conditionally accessing a value that is computationally expensive to retrieve in your Blade template, you can reduce performance overhead using a computed property.</p>
<p>Consider the following template without a computed property:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    @if (Auth::user()-&gt;can_see_posts)
        @foreach ($posts as $post)
            &lt;!-- ... --&gt;
        @endforeach
    @endif
&lt;/div&gt;
</div></code></pre>
<p>If a user is restricted from viewing posts, the database query to retrieve the posts has already been made, yet the posts are never used in the template.</p>
<p>Here's a version of the above scenario using a computed property instead:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-comment">#[Computed]</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">posts</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Post::all();
}

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>);
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    @if (Auth::user()-&gt;can_see_posts)
        @foreach ($this-&gt;posts as $post)
            &lt;!-- ... --&gt;
        @endforeach
    @endif
&lt;/div&gt;
</div></code></pre>
<p>Now, because we are providing the posts to the template using a computed property, we only execute the database query when the data is needed.</p>
<h3 id="using-inline-templates">Using inline templates</h3>
<p>Another scenario when computed properties are helpful is using <a href="/docs/components#inline-components">inline templates</a> in your component.</p>
<p>Below is an example of an inline component where, because we are returning a template string directly inside <code>render()</code>, we never have an opportunity to pass data into the view:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Computed]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">posts</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> Post::all();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&lt;&lt;&lt;HTML
        &lt;div&gt;
            @foreach (<span class="hljs-subst">$this</span>-&gt;posts as <span class="hljs-subst">$post</span>)
                &lt;!-- ... --&gt;
            @endforeach
        &lt;/div&gt;
        HTML;
    }
}
</span></div></code></pre>
<p>In the above example, without a computed property, we would have no way to explicitly pass data into the Blade template.</p>
<h3 id="omitting-the-render-method">Omitting the render method</h3>
<p>In Livewire, another way to cut down on boilerplate in your components is by omitting the <code>render()</code> method entirely. When omitted, Livewire will use its own <code>render()</code> method returning the corresponding Blade view by convention.</p>
<p>In these case, you obviously don't have a <code>render()</code> method from which you can pass data into a Blade view.</p>
<p>Rather than re-introducing the <code>render()</code> method into your component, you can instead provide that data to the view via computed properties:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Computed]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">posts</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> Post::all();
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($this-&gt;posts as $post)
        &lt;!-- ... --&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: contribution-guide.md
```md
Hi there and welcome to the Livewire contribution guide. In this guide, we are going to take a look at how you can contribute to Livewire by submitting new features, fixing failing tests, or resolving bugs.

## Setting up Livewire and Alpine locally
To contribute, the easiest way is to ensure that the Livewire and Alpine repositories are set up on your local machine. This will allow you to make changes and run the test suite with ease.

### Forking and cloning the repositories
To get started, the first step is to fork and clone the repositories. The easiest way to do this is by using the [Github CLI](https://cli.github.com/), but you can also perform these steps manually by clicking the &quot;Fork&quot; button on the Github [repository page](https://github.com/livewire/livewire).

```shell
# Fork and clone Livewire
gh repo fork livewire/livewire --default-branch-only --clone=true --remote=false -- livewire

# Switch the working directory to livewire
cd livewire

# Install all composer dependencies
composer install

# Ensure Dusk is correctly configured
vendor/bin/dusk-updater detect --no-interaction
</div></code></pre>
<p>To set up Alpine, make sure you have <a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">NPM</a> installed, and then run the following commands. If you prefer to fork manually, you can visit the <a href="https://github.com/alpinejs/alpine">repository page</a>.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#</span><span class="bash"> Fork and <span class="hljs-built_in">clone</span> Alpine</span>
gh repo fork alpinejs/alpine --default-branch-only --clone=true --remote=false -- alpine
<span class="hljs-meta">
#</span><span class="bash"> Switch the working directory to alpine</span>
cd alpine
<span class="hljs-meta">
#</span><span class="bash"> Install all npm dependencies</span>
npm install
<span class="hljs-meta">
#</span><span class="bash"> Build all Alpine packages</span>
npm run build
<span class="hljs-meta">
#</span><span class="bash"> Link all Alpine packages locally</span>
cd alpine/packages/alpinejs &amp;&amp; npm link
cd alpine/packages/anchor &amp;&amp; npm link
cd alpine/packages/collapse &amp;&amp; npm link
cd alpine/packages/csp &amp;&amp; npm link
cd alpine/packages/docs &amp;&amp; npm link
cd alpine/packages/focus &amp;&amp; npm link
cd alpine/packages/history &amp;&amp; npm link
cd alpine/packages/intersect &amp;&amp; npm link
cd alpine/packages/mask &amp;&amp; npm link
cd alpine/packages/morph &amp;&amp; npm link
cd alpine/packages/navigate &amp;&amp; npm link
cd alpine/packages/persist &amp;&amp; npm link
<span class="hljs-meta">
#</span><span class="bash"> Switch the working directory back to livewire</span>
cd ../livewire
<span class="hljs-meta">
#</span><span class="bash"> Link all packages</span>
npm link alpinejs @alpinejs/anchor @alpinejs/collapse @alpinejs/csp @alpinejs/docs @alpinejs/focus @alpinejs/history @alpinejs/intersect @alpinejs/mask @alpinejs/morph @alpinejs/navigate @alpinejs
<span class="hljs-meta">
#</span><span class="bash"> Build Livewire</span>
npm run build
</div></code></pre>
<h2 id="contributing-a-failing-test">Contributing a Failing Test</h2>
<p>If you're encountering a bug and are unsure about how to solve it, especially given the complexity of the Livewire core, you might be wondering where to start. In such cases, the easiest approach is to contribute a failing test. This way, someone with more experience can assist in identifying and fixing the bug. Nonetheless, we do recommend that you also explore the core to gain a better understanding of how Livewire operates.</p>
<p>Let's take a step-by-step approach.</p>
<h4 id="1-determine-where-to-add-your-test">1. Determine where to add your test</h4>
<p>The Livewire core is divided into different folders, each corresponding to specific Livewire features. For example:</p>
<pre class="hljs"><code><div>src/Features/SupportAccessingParent
src/Features/SupportAttributes
src/Features/SupportAutoInjectedAssets
src/Features/SupportBladeAttributes
src/Features/SupportChecksumErrorDebugging
src/Features/SupportComputed
src/Features/SupportConsoleCommands
src/Features/SupportDataBinding
//...
</div></code></pre>
<p>Try to locate a feature that is related to the bug you are experiencing. If you can't find an appropriate folder or if you're unsure about which one to select, you can simply choose one and mention in your pull request that you require assistance with placing the test in the correct feature set.</p>
<h4 id="2-determine-the-type-of-test">2. Determine the type of test</h4>
<p>The Livewire test suite consists of two types of tests:</p>
<ol>
<li><strong>Unit tests</strong>: These tests focus on the PHP implementation of Livewire.</li>
<li><strong>Browser tests</strong>: These tests run a series of steps inside a real browser and assert the correct outcome. They mainly focus on the Javascript implementation of Livewire.</li>
</ol>
<p>If you're unsure about which type of test to choose or if you're unfamiliar with writing tests for Livewire, you can start with a browser test. Implement the steps you perform in your application and browser to reproduce the bug.</p>
<p>Unit tests should be added to the <code>UnitTest.php</code> file, and browser tests should be added to <code>BrowserTest.php</code>. If one or both of these files do not exist, you can create them yourself.</p>
<p><strong>Unit test</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnitTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">livewire_can_run_action</span><span class="hljs-params">()</span>: <span class="hljs-title">void</span>
    </span>{
       <span class="hljs-comment">// ...</span>
    }
}
</div></code></pre>
<p><strong>Browser test</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">BrowserTestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BrowserTestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">livewire_can_run_action</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>
    }
}
</div></code></pre>
<blockquote>
<p>[!tip] Not sure how to write tests?
You can learn a lot by explore existing Unit and Browser tests to learn how tests are written. Even copying and pasting an existing test is a great starting point for writing your own test.</p>
</blockquote>
<h4 id="3-preparing-your-pull-request-branch">3. Preparing your pull request branch</h4>
<p>Once you have completed your feature or failing test, it's time to submit your Pull Request (PR) to the Livewire repository. First, ensure that you commit your changes to a separate branch (avoid using <code>main</code>). To create a new branch, you can use the <code>git</code> command:</p>
<pre class="hljs"><code><div>git checkout -b my-feature
</div></code></pre>
<p>You can name your branch anything you want, but for future reference, it's helpful to use a descriptive name that reflects your feature or failing test.</p>
<p>Next, commit your changes to your branch. You can use <code>git add .</code> to stage all changes and then <code>git commit -m &quot;Add my feature&quot;</code> to commit all changes with a descriptive commit message.</p>
<p>However, your branch is currently only available on your local machine. To create a Pull Request, you need to push your branch to your forked Livewire repository using <code>git push</code>.</p>
<pre class="hljs"><code><div>git push origin my-feature

Enumerating objects: 13, done.
Counting objects: 100% (13/13), done.
Delta compression using up to 8 threads
Compressing objects: 100% (6/6), done.

To github.com:Username/livewire.git
 * [new branch]        my-feature -&gt; my-feature
</div></code></pre>
<h4 id="4-submitting-your-pull-request">4. Submitting your pull request</h4>
<p>We're almost there! Open your web browser and navigate to your forked Livewire repository (<code>https://github.com/&lt;your-username&gt;/livewire</code>). In the center of your screen, you will see a new notification: &quot;<strong>my-feature had recent pushes 1 minute ago</strong>&quot; along with a button that says &quot;<strong>Compare &amp; pull request</strong>.&quot; Click the button to open the pull request form.</p>
<p>In the form, provide a title that describes your pull request and then proceed to the description section. The text area already contains a predefined template. Try to answer every question:</p>
<pre class="hljs"><code><div>Review the contribution guide first at: https://livewire.laravel.com/docs/contribution-guide

1️⃣ Is this something that is wanted/needed? Did you create a discussion about it first?
Yes, you can find the discussion here: https://github.com/livewire/livewire/discussions/999999

2️⃣ Did you create a branch for your fix/feature? (Main branch PR's will be closed)
Yes, the branch is named `my-feature`

3️⃣ Does it contain multiple, unrelated changes? Please separate the PRs out.
No, the changes are only related to my feature.

4️⃣ Does it include tests? (Required)
Yes

5️⃣ Please include a thorough description (including small code snippets if possible) of the improvement and reasons why it's useful.

These changes will improve memory usage. You can see the benchmark results here:

// ...

</div></code></pre>
<p>All set? Click on <strong>Create pull request</strong> 🚀 Congratulations! You've successfully created your first contribution 🎉</p>
<p>The maintainers will review your PR and may provide feedback or request changes. Please make an effort to address any feedback as soon as possible.</p>
<p>Thank you for contributing to Livewire!</p>
<pre class="hljs"><code><div>
## File: dirty.md
```md

In a traditional HTML page containing a form, the form is only ever submitted when the user presses the &quot;Submit&quot; button.

However, Livewire is capable of much more than traditional form submissions. You can validate form inputs in real-time or even save the form as a user types.

In these &quot;real-time&quot; update scenarios, it can be helpful to signal to your users when a form or subset of a form has been changed, but hasn't been saved to the database.

When a form contains un-saved input, that form is considered &quot;dirty&quot;. It only becomes &quot;clean&quot; when a network request has been triggered to synchronize the server state with the client-side state.

## Basic usage

Livewire allows you to easily toggle visual elements on the page using the `wire:dirty` directive.

By adding `wire:dirty` to an element, you are instructing Livewire to only show the element when the client-side state diverges from the server-side state.

To demonstrate, here is an example of an `UpdatePost` form containing a visual &quot;Unsaved changes...&quot; indication that signals to the user that the form contains input that has not been saved:

```blade
&lt;form wire:submit=&quot;update&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;

    &lt;!-- ... --&gt;

    &lt;button type=&quot;submit&quot;&gt;Update&lt;/button&gt;

    &lt;div wire:dirty&gt;Unsaved changes...&lt;/div&gt; &lt;!-- [tl! highlight] --&gt;
&lt;/form&gt;
</div></code></pre>
<p>Because <code>wire:dirty</code> has been added to the &quot;Unsaved changes...&quot; message, the message will be hidden by default. Livewire will automatically display the message when the user starts modifying the form inputs.</p>
<p>When the user submits the form, the message will disappear again, since the server / client data is back in sync.</p>
<h3 id="removing-elements">Removing elements</h3>
<p>By adding the <code>.remove</code> modifier to <code>wire:dirty</code>, you can instead show an element by default and only hide it when the component has &quot;dirty&quot; state:</p>
<pre class="hljs"><code><div>&lt;div wire:dirty.remove&gt;The data is in-sync...&lt;/div&gt;
</div></code></pre>
<h2 id="targeting-property-updates">Targeting property updates</h2>
<p>Imagine you are using <code>wire:model.blur</code> to update a property on the server immediately after a user leaves an input field. In this scenario, you can provide a &quot;dirty&quot; indication for only that property by adding <code>wire:target</code> to the element that contains the <code>wire:dirty</code> directive.</p>
<p>Here is an example of only showing a dirty indication when the title property has been changed:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;update&quot;&gt;
    &lt;input wire:model.blur=&quot;title&quot;&gt;

    &lt;div wire:dirty wire:target=&quot;title&quot;&gt;Unsaved title...&lt;/div&gt; &lt;!-- [tl! highlight] --&gt;

    &lt;button type=&quot;submit&quot;&gt;Update&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<h2 id="toggling-classes">Toggling classes</h2>
<p>Often, instead of toggling entire elements, you may want to toggle individual CSS classes on an input when its state is &quot;dirty&quot;.</p>
<p>Below is an example where a user types into an input field and the border becomes yellow, indicating an &quot;unsaved&quot; state. Then, when the user tabs away from the field, the border is removed, indicating that the state has been saved on the server:</p>
<pre class="hljs"><code><div>&lt;input wire:model.blur=&quot;title&quot; wire:dirty.class=&quot;border-yellow-500&quot;&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: downloads.md
```md

File downloads in Livewire work much the same as in Laravel itself. Typically, you can use any Laravel download utility inside a Livewire component, and it should work as expected.

However, behind the scenes, file downloads are handled differently than in a standard Laravel application. When using Livewire, the file's contents are Base64 encoded, sent to the frontend, and decoded back into binary to be downloaded directly from the client.

## Basic usage

Triggering a file download in Livewire is as simple as returning a standard Laravel download response.

Below is an example of a `ShowInvoice` component that contains a &quot;Download&quot; button to download the invoice PDF:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;
use App\Models\Invoice;

class ShowInvoice extends Component
{
    public Invoice $invoice;

    public function mount(Invoice $invoice)
    {
        $this-&gt;invoice = $invoice;
    }

    public function download()
    {
        return response()-&gt;download( // [tl! highlight:2]
            $this-&gt;invoice-&gt;file_path, 'invoice.pdf'
        );
    }

    public function render()
    {
        return view('livewire.show-invoice');
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;{{ $invoice-&gt;title }}&lt;/h1&gt;

    &lt;span&gt;{{ $invoice-&gt;date }}&lt;/span&gt;
    &lt;span&gt;{{ $invoice-&gt;amount }}&lt;/span&gt;

    &lt;button type=&quot;button&quot; wire:click=&quot;download&quot;&gt;Download&lt;/button&gt; &lt;!-- [tl! highlight] --&gt;
&lt;/div&gt;
</div></code></pre>
<p>Just like in a Laravel controller, you can also use the <code>Storage</code> facade to initiate downloads:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Storage::disk(<span class="hljs-string">'invoices'</span>)-&gt;download(<span class="hljs-string">'invoice.csv'</span>);
}
</div></code></pre>
<h2 id="streaming-downloads">Streaming downloads</h2>
<p>Livewire can also stream downloads; however, they aren't truly streamed. The download isn't triggered until the file's contents are collected and delivered to the browser:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> response()-&gt;streamDownload(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">echo</span> <span class="hljs-string">'...'</span>; <span class="hljs-comment">// Echo download contents directly...</span>
    }, <span class="hljs-string">'invoice.pdf'</span>);
}
</div></code></pre>
<h2 id="testing-file-downloads">Testing file downloads</h2>
<p>Livewire also provides a <code>-&gt;assertFileDownloaded()</code> method to easily test that a file was downloaded with a given name:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Invoice</span>;

<span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">can_download_invoice</span><span class="hljs-params">()</span>
</span>{
    $invoice = Invoice::factory();

    Livewire::test(ShowInvoice::class)
        -&gt;call(<span class="hljs-string">'download'</span>)
        -&gt;assertFileDownloaded(<span class="hljs-string">'invoice.pdf'</span>);
}
</div></code></pre>
<p>You can also test to ensure a file was not downloaded using the <code>-&gt;assertNoFileDownloaded()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Invoice</span>;

<span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">does_not_download_invoice_if_unauthorised</span><span class="hljs-params">()</span>
</span>{
    $invoice = Invoice::factory();

    Livewire::test(ShowInvoice::class)
        -&gt;call(<span class="hljs-string">'download'</span>)
        -&gt;assertNoFileDownloaded();
}
</div></code></pre>
<pre class="hljs"><code><div>
## File: events.md
```md
Livewire offers a robust event system that you can use to communicate between different components on the page. Because it uses browser events under the hood, you can also use Livewire's event system to communicate with Alpine components or even plain, vanilla JavaScript.

To trigger an event, you may use the `dispatch()` method from anywhere inside your component and listen for that event from any other component on the page.

## Dispatching events

To dispatch an event from a Livewire component, you can call the `dispatch()` method, passing it the event name and any additional data you want to send along with the event.

Below is an example of dispatching a `post-created` event from a `CreatePost` component:

```php
use Livewire\Component;

class CreatePost extends Component
{
    public function save()
    {
		// ...

		$this-&gt;dispatch('post-created'); // [tl! highlight]
    }
}
</div></code></pre>
<p>In this example, when the <code>dispatch()</code> method is called, the <code>post-created</code> event will be dispatched, and every other component on the page that is listening for this event will be notified.</p>
<p>You can pass additional data with the event by passing the data as the second parameter to the <code>dispatch()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>, title: $post-&gt;title);
</div></code></pre>
<h2 id="listening-for-events">Listening for events</h2>
<p>To listen for an event in a Livewire component, add the <code>#[On]</code> attribute above the method you want to be called when a given event is dispatched:</p>
<blockquote>
<p>[!warning] Make sure you import attribute classes
Make sure you import any attribute classes. For example, the below <code>#[On()]</code> attributes requires the following import <code>use Livewire\Attributes\On;</code>.</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">On</span>; <span class="hljs-comment">// [tl! highlight]</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dashboard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-comment">#[On('post-created')] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePostList</span><span class="hljs-params">($title)</span>
    </span>{
		<span class="hljs-comment">// ...</span>
    }
}
</div></code></pre>
<p>Now, when the <code>post-created</code> event is dispatched from <code>CreatePost</code>, a network request will be triggered and the <code>updatePostList()</code> action will be invoked.</p>
<p>As you can see, additional data sent with the event will be provided to the action as its first argument.</p>
<h3 id="listening-for-dynamic-event-names">Listening for dynamic event names</h3>
<p>Occasionally, you may want to dynamically generate event listener names at run-time using data from your component.</p>
<p>For example, if you wanted to scope an event listener to a specific Eloquent model, you could append the model's ID to the event name like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">On</span>; <span class="hljs-comment">// [tl! highlight]</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

	<span class="hljs-comment">#[On('post-updated.{post.id}')] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refreshPost</span><span class="hljs-params">()</span>
    </span>{
		<span class="hljs-comment">// ...</span>
    }
}
</div></code></pre>
<p>If the above <code>$post</code> model had an ID of <code>3</code>, the <code>refreshPost()</code> method would only be triggered by an event named: <code>post-updated.3</code>.</p>
<h3 id="listening-for-events-from-specific-child-components">Listening for events from specific child components</h3>
<p>Livewire allows you to listen for events directly on individual child components in your Blade template like so:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;livewire:edit-post @saved=&quot;$refresh&quot;&gt;

    &lt;!-- ... --&gt;
&lt;/div&gt;
</div></code></pre>
<p>In the above scenario, if the <code>edit-post</code> child component dispatches a <code>saved</code> event, the parent's <code>$refresh</code> will be called and the parent will be refreshed.</p>
<p>Instead of passing <code>$refresh</code>, you can pass any method you normally would to something like <code>wire:click</code>. Here's an example of calling a <code>close()</code> method that might do something like close a modal dialog:</p>
<pre class="hljs"><code><div>&lt;livewire:edit-post @saved=&quot;close&quot;&gt;
</div></code></pre>
<p>If the child dispatched parameters along with the request, for example <code>$this-&gt;dispatch('close', postId: 1)</code>, you can forward those values to the parent method using the following syntax:</p>
<pre class="hljs"><code><div>&lt;livewire:edit-post @saved=&quot;close($event.detail.postId)&quot;&gt;
</div></code></pre>
<h2 id="using-javascript-to-interact-with-events">Using JavaScript to interact with events</h2>
<p>Livewire's event system becomes much more powerful when you interact with it from JavaScript inside your application. This unlocks the ability for any other JavaScript in your app to communicate with Livewire components on the page.</p>
<h3 id="listening-for-events-inside-component-scripts">Listening for events inside component scripts</h3>
<p>You can easily listen for the <code>post-created</code> event inside your component's template from a <code>@script</code> directive like so:</p>
<pre class="hljs"><code><div>@script
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
    $wire.on(<span class="hljs-string">'post-created'</span>, () =&gt; {
        <span class="hljs-comment">//</span>
    });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
@endscript
</div></code></pre>
<p>The above snippet would listen for the <code>post-created</code> from the component it's registered within. If the component is no longer on the page, the event listener will no longer be triggered.</p>
<p><a href="/docs/javascript#using-javascript-in-livewire-components">Read more about using JavaScript inside your Livewire components →</a></p>
<h3 id="dispatching-events-from-component-scripts">Dispatching events from component scripts</h3>
<p>Additionally, you can dispatch events from within a component's <code>@script</code> like so:</p>
<pre class="hljs"><code><div>@script
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
    $wire.dispatch(<span class="hljs-string">'post-created'</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
@endscript
</div></code></pre>
<p>When the above <code>@script</code> is run, the <code>post-created</code> event will be dispatched to the component it's defined within.</p>
<p>To dispatch the event only to the component where the script resides and not other components on the page (preventing the event from &quot;bubbling&quot; up), you can use <code>dispatchSelf()</code>:</p>
<pre class="hljs"><code><div>$wire.dispatchSelf(<span class="hljs-string">'post-created'</span>);
</div></code></pre>
<p>You can pass any additional parameters to the event by passing an object as a second argument to <code>dispatch()</code>:</p>
<pre class="hljs"><code><div>@script
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
    $wire.dispatch(<span class="hljs-string">'post-created'</span>, { refreshPosts: <span class="hljs-literal">true</span> });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
@endscript
</div></code></pre>
<p>You can now access those event parameters from both your Livewire class and also other JavaScript event listeners.</p>
<p>Here's an example of receiving the <code>refreshPosts</code> parameter within a Livewire class:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">On</span>;

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">#[On('post-created')]</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleNewPost</span><span class="hljs-params">($refreshPosts = false)</span>
</span>{
    <span class="hljs-comment">//</span>
}
</div></code></pre>
<p>You can also access the <code>refreshPosts</code> parameter from a JavaScript event listener from the event's <code>detail</code> property:</p>
<pre class="hljs"><code><div>@script
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    $wire.on(<span class="hljs-string">'post-created'</span>, (event) =&gt; {
        <span class="hljs-keyword">let</span> refreshPosts = event.detail.refreshPosts

        <span class="hljs-comment">// ...</span>
    });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
@endscript
</div></code></pre>
<p><a href="/docs/javascript#using-javascript-in-livewire-components">Read more about using JavaScript inside your Livewire components →</a></p>
<h3 id="listening-for-livewire-events-from-global-javascript">Listening for Livewire events from global JavaScript</h3>
<p>Alternatively, you can listen for Livewire events globally using <code>Livewire.on</code> from any script in your application:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:init'</span>, () =&gt; {
       Livewire.on(<span class="hljs-string">'post-created'</span>, (event) =&gt; {
           <span class="hljs-comment">//</span>
       });
    });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<p>The above snippet would listen for the <code>post-created</code> event dispatched from any component on the page.</p>
<p>If you wish to remove this event listener for any reason, you can do so using the returned <code>cleanup</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:init'</span>, () =&gt; {
        <span class="hljs-keyword">let</span> cleanup = Livewire.on(<span class="hljs-string">'post-created'</span>, (event) =&gt; {
            <span class="hljs-comment">//</span>
        });

        <span class="hljs-comment">// Calling "cleanup()" will un-register the above event listener...</span>
        cleanup();
    });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<h2 id="events-in-alpine">Events in Alpine</h2>
<p>Because Livewire events are plain browser events under the hood, you can use Alpine to listen for them or even dispatch them.</p>
<h3 id="listening-for-livewire-events-in-alpine">Listening for Livewire events in Alpine</h3>
<p>For example, we may easily listen for the <code>post-created</code> event using Alpine:</p>
<pre class="hljs"><code><div>&lt;div x-on:post-created=&quot;...&quot;&gt;&lt;/div&gt;
</div></code></pre>
<p>The above snippet would listen for the <code>post-created</code> event from any Livewire components that are children of the HTML element that the <code>x-on</code> directive is assigned to.</p>
<p>To listen for the event from any Livewire component on the page, you can add <code>.window</code> to the listener:</p>
<pre class="hljs"><code><div>&lt;div x-on:post-created.window=&quot;...&quot;&gt;&lt;/div&gt;
</div></code></pre>
<p>If you want to access additional data that was sent with the event, you can do so using <code>$event.detail</code>:</p>
<pre class="hljs"><code><div>&lt;div x-on:post-created=&quot;notify('New post: ' + $event.detail.title)&quot;&gt;&lt;/div&gt;
</div></code></pre>
<p>The Alpine documentation provides further information on <a href="https://alpinejs.dev/directives/on">listening for events</a>.</p>
<h3 id="dispatching-livewire-events-from-alpine">Dispatching Livewire events from Alpine</h3>
<p>Any event dispatched from Alpine is capable of being intercepted by a Livewire component.</p>
<p>For example, we may easily dispatch the <code>post-created</code> event from Alpine:</p>
<pre class="hljs"><code><div>&lt;button @click=&quot;$dispatch('post-created')&quot;&gt;...&lt;/button&gt;
</div></code></pre>
<p>Like Livewire's <code>dispatch()</code> method, you can pass additional data along with the event by passing the data as the second parameter to the method:</p>
<pre class="hljs"><code><div>&lt;button @click=&quot;$dispatch('post-created', { title: 'Post Title' })&quot;&gt;...&lt;/button&gt;
</div></code></pre>
<p>To learn more about dispatching events using Alpine, consult the <a href="https://alpinejs.dev/magics/dispatch">Alpine documentation</a>.</p>
<blockquote>
<p>[!tip] You might not need events
If you are using events to call behavior on a parent from a child, you can instead call the action directly from the child using <code>$parent</code> in your Blade template. For example:</p>
<pre class="hljs"><code><div>&lt;button wire:click=&quot;$parent.showCreatePostForm()&quot;&gt;Create Post&lt;/button&gt;
</div></code></pre>
<p><a href="/docs/nesting#directly-accessing-the-parent-from-the-child">Learn more about $parent</a>.</p>
</blockquote>
<h2 id="dispatching-directly-to-another-component">Dispatching directly to another component</h2>
<p>If you want to use events for communicating directly between two components on the page, you can use the <code>dispatch()-&gt;to()</code> modifier.</p>
<p>Below is an example of the <code>CreatePost</code> component dispatching the <code>post-created</code> event directly to the <code>Dashboard</code> component, skipping any other components listening for that specific event:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
		<span class="hljs-comment">// ...</span>

		<span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>)-&gt;to(Dashboard::class);
    }
}
</div></code></pre>
<h2 id="dispatching-a-component-event-to-itself">Dispatching a component event to itself</h2>
<p>Using the <code>dispatch()-&gt;self()</code> modifier, you can restrict an event to only being intercepted by the component it was triggered from:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
		<span class="hljs-comment">// ...</span>

		<span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>)-&gt;self();
    }
}
</div></code></pre>
<h2 id="dispatching-events-from-blade-templates">Dispatching events from Blade templates</h2>
<p>You can dispatch events directly from your Blade templates using the <code>$dispatch</code> JavaScript function. This is useful when you want to trigger an event from a user interaction, such as a button click:</p>
<pre class="hljs"><code><div>&lt;button wire:click=&quot;$dispatch('show-post-modal', { id: {{ $post-&gt;id }} })&quot;&gt;
    EditPost
&lt;/button&gt;
</div></code></pre>
<p>In this example, when the button is clicked, the <code>show-post-modal</code> event will be dispatched with the specified data.</p>
<p>If you want to dispatch an event directly to another component you can use the <code>$dispatchTo()</code> JavaScript function:</p>
<pre class="hljs"><code><div>&lt;button wire:click=&quot;$dispatchTo('posts', 'show-post-modal', { id: {{ $post-&gt;id }} })&quot;&gt;
    EditPost
&lt;/button&gt;
</div></code></pre>
<p>In this example, when the button is clicked, the <code>show-post-modal</code> event will be dispatched directly to the <code>Posts</code> component.</p>
<h2 id="testing-dispatched-events">Testing dispatched events</h2>
<p>To test events dispatched by your component, use the <code>assertDispatched()</code> method in your Livewire test. This method checks that a specific event has been dispatched during the component's lifecycle:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Foundation</span>\<span class="hljs-title">Testing</span>\<span class="hljs-title">RefreshDatabase</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">RefreshDatabase</span>;

    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">it_dispatches_post_created_event</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(CreatePost::class)
            -&gt;call(<span class="hljs-string">'save'</span>)
            -&gt;assertDispatched(<span class="hljs-string">'post-created'</span>);
    }
}
</div></code></pre>
<p>In this example, the test ensures that the <code>post-created</code> event is dispatched with the specified data when the <code>save()</code> method is called on the <code>CreatePost</code> component.</p>
<h3 id="testing-event-listeners">Testing Event Listeners</h3>
<p>To test event listeners, you can dispatch events from the test environment and assert that the expected actions are performed in response to the event:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Foundation</span>\<span class="hljs-title">Testing</span>\<span class="hljs-title">RefreshDatabase</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Dashboard</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DashboardTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">RefreshDatabase</span>;

    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">it_updates_post_count_when_a_post_is_created</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(Dashboard::class)
            -&gt;assertSee(<span class="hljs-string">'Posts created: 0'</span>)
            -&gt;dispatch(<span class="hljs-string">'post-created'</span>)
            -&gt;assertSee(<span class="hljs-string">'Posts created: 1'</span>);
    }
}
</div></code></pre>
<p>In this example, the test dispatches the <code>post-created</code> event, then checks that the <code>Dashboard</code> component properly handles the event and displays the updated count.</p>
<h2 id="real-time-events-using-laravel-echo">Real-time events using Laravel Echo</h2>
<p>Livewire pairs nicely with <a href="https://laravel.com/docs/broadcasting#client-side-installation">Laravel Echo</a> to provide real-time functionality on your web-pages using WebSockets.</p>
<blockquote>
<p>[!warning] Installing Laravel Echo is a prerequisite
This feature assumes you have installed Laravel Echo and the <code>window.Echo</code> object is globally available in your application. For more information on installing echo, check out the <a href="https://laravel.com/docs/broadcasting#client-side-installation">Laravel Echo documentation</a>.</p>
</blockquote>
<h3 id="listening-for-echo-events">Listening for Echo events</h3>
<p>Imagine you have an event in your Laravel application named <code>OrderShipped</code>:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Events</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Order</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Broadcasting</span>\<span class="hljs-title">Channel</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Broadcasting</span>\<span class="hljs-title">InteractsWithSockets</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Contracts</span>\<span class="hljs-title">Broadcasting</span>\<span class="hljs-title">ShouldBroadcast</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Foundation</span>\<span class="hljs-title">Events</span>\<span class="hljs-title">Dispatchable</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Queue</span>\<span class="hljs-title">SerializesModels</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderShipped</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ShouldBroadcast</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">Dispatchable</span>, <span class="hljs-title">InteractsWithSockets</span>, <span class="hljs-title">SerializesModels</span>;

    <span class="hljs-keyword">public</span> Order $order;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">broadcastOn</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Channel(<span class="hljs-string">'orders'</span>);
    }
}
</div></code></pre>
<p>You might dispatch this event from another part of your application like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Events</span>\<span class="hljs-title">OrderShipped</span>;

OrderShipped::dispatch();
</div></code></pre>
<p>If you were to listen for this event in JavaScript using only Laravel Echo, it would look something like this:</p>
<pre class="hljs"><code><div>Echo.channel(<span class="hljs-string">'orders'</span>)
    .listen(<span class="hljs-string">'OrderShipped'</span>, e =&gt; {
        <span class="hljs-built_in">console</span>.log(e.order)
    })
</div></code></pre>
<p>Assuming you have Laravel Echo installed and configured, you can listen for this event from inside a Livewire component.</p>
<p>Below is an example of an <code>OrderTracker</code> component that is listening for the <code>OrderShipped</code> event in order to show users a visual indication of a new order:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">On</span>; <span class="hljs-comment">// [tl! highlight]</span>
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderTracker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $showNewOrderNotification = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">#[On('echo:orders,OrderShipped')]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyNewOrder</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;showNewOrderNotification = <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>If you have Echo channels with variables embedded in them (such as an Order ID), you can define listeners via the <code>getListeners()</code> method instead of the <code>#[On]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">On</span>; <span class="hljs-comment">// [tl! highlight]</span>
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Order</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderTracker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Order $order;

    <span class="hljs-keyword">public</span> $showOrderShippedNotification = <span class="hljs-keyword">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListeners</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">"echo:orders.{$this-&gt;order-&gt;id},OrderShipped"</span> =&gt; <span class="hljs-string">'notifyShipped'</span>,
        ];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyShipped</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;showOrderShippedNotification = <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Or, if you prefer, you can use the dynamic event name syntax:</p>
<pre class="hljs"><code><div><span class="hljs-comment">#[On('echo:orders.{order.id},OrderShipped')]</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyNewOrder</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">$this</span>-&gt;showNewOrderNotification = <span class="hljs-keyword">true</span>;
}
</div></code></pre>
<p>If you need to access the event payload, you can do so via the passed in <code>$event</code> parameter:</p>
<pre class="hljs"><code><div><span class="hljs-comment">#[On('echo:orders.{order.id},OrderShipped')]</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyNewOrder</span><span class="hljs-params">($event)</span>
</span>{
    $order = Order::find($event[<span class="hljs-string">'orderId'</span>]);

    <span class="hljs-comment">//</span>
}
</div></code></pre>
<h3 id="private--presence-channels">Private &amp; presence channels</h3>
<p>You may also listen to events broadcast to private and presence channels:</p>
<blockquote>
<p>[!info]
Before proceeding, ensure you have defined <a href="https://laravel.com/docs/master/broadcasting#defining-authorization-callbacks">Authentication Callbacks</a> for your broadcast channels.</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderTracker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $showNewOrderNotification = <span class="hljs-keyword">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListeners</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-comment">// Public Channel</span>
            <span class="hljs-string">"echo:orders,OrderShipped"</span> =&gt; <span class="hljs-string">'notifyNewOrder'</span>,

            <span class="hljs-comment">// Private Channel</span>
            <span class="hljs-string">"echo-private:orders,OrderShipped"</span> =&gt; <span class="hljs-string">'notifyNewOrder'</span>,

            <span class="hljs-comment">// Presence Channel</span>
            <span class="hljs-string">"echo-presence:orders,OrderShipped"</span> =&gt; <span class="hljs-string">'notifyNewOrder'</span>,
            <span class="hljs-string">"echo-presence:orders,here"</span> =&gt; <span class="hljs-string">'notifyNewOrder'</span>,
            <span class="hljs-string">"echo-presence:orders,joining"</span> =&gt; <span class="hljs-string">'notifyNewOrder'</span>,
            <span class="hljs-string">"echo-presence:orders,leaving"</span> =&gt; <span class="hljs-string">'notifyNewOrder'</span>,
        ];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyNewOrder</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;showNewOrderNotification = <span class="hljs-keyword">true</span>;
    }
}
</div></code></pre>
<pre class="hljs"><code><div>
## File: forms.md
```md
Because forms are the backbone of most web applications, Livewire provides loads of helpful utilities for building them. From handling simple input elements to complex things like real-time validation or file uploading, Livewire has simple, well-documented tools to make your life easier and delight your users.

Let's dive in.

## Submitting a form

Let's start by looking at a very simple form in a `CreatePost` component. This form will have two simple text inputs and a submit button, as well as some code on the backend to manage the form's state and submission:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;
use App\Models\Post;

class CreatePost extends Component
{
    public $title = '';

    public $content = '';

    public function save()
    {
        Post::create(
            $this-&gt;only(['title', 'content'])
        );

        return $this-&gt;redirect('/posts')
            -&gt;with('status', 'Post successfully created.');
    }

    public function render()
    {
        return view('livewire.create-post');
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;

    &lt;input type=&quot;text&quot; wire:model=&quot;content&quot;&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>As you can see, we are &quot;binding&quot; the public <code>$title</code> and <code>$content</code> properties in the form above using <code>wire:model</code>. This is one of the most commonly used and powerful features of Livewire.</p>
<p>In addition to binding <code>$title</code> and <code>$content</code>, we are using <code>wire:submit</code> to capture the <code>submit</code> event when the &quot;Save&quot; button is clicked and invoking the <code>save()</code> action. This action will persist the form input to the database.</p>
<p>After the new post is created in the database, we redirect the user to the <code>ShowPosts</code> component page and show them a &quot;flash&quot; message that the new post was created.</p>
<h3 id="adding-validation">Adding validation</h3>
<p>To avoid storing incomplete or dangerous user input, most forms need some sort of input validation.</p>
<p>Livewire makes validating your forms as simple as adding <code>#[Validate]</code> attributes above the properties you want to be validated.</p>
<p>Once a property has a <code>#[Validate]</code> attribute attached to it, the validation rule will be applied to the property's value any time it's updated server-side.</p>
<p>Let's add some basic validation rules to the <code>$title</code> and <code>$content</code> properties in our <code>CreatePost</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>; <span class="hljs-comment">// [tl! highlight]</span>
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Validate('required')] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required')] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate(); <span class="hljs-comment">// [tl! highlight]</span>

        Post::create(
            <span class="hljs-keyword">$this</span>-&gt;only([<span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>])
        );

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;redirect(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>);
    }
}
</div></code></pre>
<p>We'll also modify our Blade template to show any validation errors on the page.</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;
    &lt;div&gt;
        @error('title') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror &lt;!-- [tl! highlight] --&gt;
    &lt;/div&gt;

    &lt;input type=&quot;text&quot; wire:model=&quot;content&quot;&gt;
    &lt;div&gt;
        @error('content') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror &lt;!-- [tl! highlight] --&gt;
    &lt;/div&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>Now, if the user tries to submit the form without filling in any of the fields, they will see validation messages telling them which fields are required before saving the post.</p>
<p>Livewire has a lot more validation features to offer. For more information, visit our <a href="/docs/validation">dedicated documentation page on Validation</a>.</p>
<h3 id="extracting-a-form-object">Extracting a form object</h3>
<p>If you are working with a large form and prefer to extract all of its properties, validation logic, etc., into a separate class, Livewire offers form objects.</p>
<p>Form objects allow you to re-use form logic across components and provide a nice way to keep your component class cleaner by grouping all form-related code into a separate class.</p>
<p>You can either create a form class by hand or use the convenient artisan command:</p>
<pre class="hljs"><code><div>php artisan livewire:form PostForm
</div></code></pre>
<p>The above command will create a file called <code>app/Livewire/Forms/PostForm.php</code>.</p>
<p>Let's rewrite the <code>CreatePost</code> component to use a <code>PostForm</code> class:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Form</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Form</span>
</span>{
    <span class="hljs-comment">#[Validate('required|min:5')]</span>
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required|min:5')]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>\<span class="hljs-title">PostForm</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> PostForm $form; <span class="hljs-comment">// [tl! highlight]</span>

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate();

        Post::create(
            <span class="hljs-keyword">$this</span>-&gt;form-&gt;all() <span class="hljs-comment">// [tl! highlight]</span>
        );

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;redirect(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;form.title&quot;&gt;
    &lt;div&gt;
        @error('form.title') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror
    &lt;/div&gt;

    &lt;input type=&quot;text&quot; wire:model=&quot;form.content&quot;&gt;
    &lt;div&gt;
        @error('form.content') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror
    &lt;/div&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>If you'd like, you can also extract the post creation logic into the form object like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Form</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Form</span>
</span>{
    <span class="hljs-comment">#[Validate('required|min:5')]</span>
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required|min:5')]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">store</span><span class="hljs-params">()</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:5]
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate();

        Post::create(<span class="hljs-keyword">$this</span>-&gt;all());
    }
}
</div></code></pre>
<p>Now you can call <code>$this-&gt;form-&gt;store()</code> from the component:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> PostForm $form;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;form-&gt;store(); <span class="hljs-comment">// [tl! highlight]</span>

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;redirect(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>If you want to use this form object for both a create and update form, you can easily adapt it to handle both use cases.</p>
<p>Here's what it would look like to use this same form object for an <code>UpdatePost</code> component and fill it with initial data:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>\<span class="hljs-title">PostForm</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> PostForm $form;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;form-&gt;setPost($post);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;form-&gt;update();

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;redirect(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Form</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Form</span>
</span>{
    <span class="hljs-keyword">public</span> ?Post $post;

    <span class="hljs-comment">#[Validate('required|min:5')]</span>
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required|min:5')]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setPost</span><span class="hljs-params">(Post $post)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = $post;

        <span class="hljs-keyword">$this</span>-&gt;title = $post-&gt;title;

        <span class="hljs-keyword">$this</span>-&gt;content = $post-&gt;content;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">store</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate();

        Post::create(<span class="hljs-keyword">$this</span>-&gt;only([<span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>]));
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post-&gt;update(
            <span class="hljs-keyword">$this</span>-&gt;all()
        );
    }
}
</div></code></pre>
<p>As you can see, we've added a <code>setPost()</code> method to the <code>PostForm</code> object to optionally allow for filling the form with existing data as well as storing the post on the form object for later use. We've also added an <code>update()</code> method for updating the existing post.</p>
<p>Form objects are not required when working with Livewire, but they do offer a nice abstraction for keeping your components free of repetitive boilerplate.</p>
<h3 id="resetting-form-fields">Resetting form fields</h3>
<p>If you are using a form object, you may want to reset the form after it has been submitted. This can be done by calling the <code>reset()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Form</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Form</span>
</span>{
    <span class="hljs-comment">#[Validate('required|min:5')]</span>
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required|min:5')]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">store</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate();

        Post::create(<span class="hljs-keyword">$this</span>-&gt;all());

        <span class="hljs-keyword">$this</span>-&gt;reset(); <span class="hljs-comment">// [tl! highlight]</span>
    }
}
</div></code></pre>
<p>You can also reset specific properties by passing the property names into the <code>reset()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;reset(<span class="hljs-string">'title'</span>);

<span class="hljs-comment">// Or multiple at once...</span>

<span class="hljs-keyword">$this</span>-&gt;reset(<span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>);
</div></code></pre>
<h3 id="using-rule-objects">Using Rule objects</h3>
<p>If you have more sophisticated validation scenarios where Laravel's <code>Rule</code> objects are necessary, you can alternatively define a <code>rules()</code> method to declare your validation rules like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Validation</span>\<span class="hljs-title">Rule</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Form</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Form</span>
</span>{
    <span class="hljs-keyword">public</span> ?Post $post;

    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rules</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'title'</span> =&gt; [
                <span class="hljs-string">'required'</span>,
                Rule::unique(<span class="hljs-string">'posts'</span>)-&gt;ignore(<span class="hljs-keyword">$this</span>-&gt;post), <span class="hljs-comment">// [tl! highlight]</span>
            ],
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-string">'required|min:5'</span>,
        ];
    }

    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate();

        <span class="hljs-keyword">$this</span>-&gt;post-&gt;update(<span class="hljs-keyword">$this</span>-&gt;all());

        <span class="hljs-keyword">$this</span>-&gt;reset();
    }
}
</div></code></pre>
<p>When using a <code>rules()</code> method instead of <code>#[Validate]</code>, Livewire will only run the validation rules when you call <code>$this-&gt;validate()</code>, rather than every time a property is updated.</p>
<p>If you are using real-time validation or any other scenario where you'd like Livewire to validate specific fields after every request, you can use <code>#[Validate]</code> without any provided rules like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Validation</span>\<span class="hljs-title">Rule</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Form</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Form</span>
</span>{
    <span class="hljs-keyword">public</span> ?Post $post

    <span class="hljs-comment">#[Validate] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rules</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'title'</span> =&gt; [
                <span class="hljs-string">'required'</span>,
                Rule::unique(<span class="hljs-string">'posts'</span>)-&gt;ignore(<span class="hljs-keyword">$this</span>-&gt;post),
            ],
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-string">'required|min:5'</span>,
        ];
    }

    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate();

        <span class="hljs-keyword">$this</span>-&gt;post-&gt;update(<span class="hljs-keyword">$this</span>-&gt;all());

        <span class="hljs-keyword">$this</span>-&gt;reset();
    }
}
</div></code></pre>
<p>Now if the <code>$title</code> property is updated before the form is submitted—like when using <a href="/docs/wire-model#updating-on-blur-event"><code>wire:model.blur</code></a>—the validation for <code>$title</code> will be run.</p>
<h3 id="showing-a-loading-indicator">Showing a loading indicator</h3>
<p>By default, Livewire will automatically disable submit buttons and mark inputs as <code>readonly</code> while a form is being submitted, preventing the user from submitting the form again while the first submission is being handled.</p>
<p>However, it can be difficult for users to detect this &quot;loading&quot; state without extra affordances in your application's UI.</p>
<p>Here's an example of adding a small loading spinner to the &quot;Save&quot; button via <code>wire:loading</code> so that a user understands that the form is being submitted:</p>
<pre class="hljs"><code><div>&lt;button type=&quot;submit&quot;&gt;
    Save

    &lt;div wire:loading&gt;
        &lt;svg&gt;...&lt;/svg&gt; &lt;!-- SVG loading spinner --&gt;
    &lt;/div&gt;
&lt;/button&gt;
</div></code></pre>
<p>Now, when a user presses &quot;Save&quot;, a small, inline spinner will show up.</p>
<p>Livewire's <code>wire:loading</code> feature has a lot more to offer. Visit the <a href="/docs/wire-loading">Loading documentation to learn more.</a></p>
<h2 id="live-updating-fields">Live-updating fields</h2>
<p>By default, Livewire only sends a network request when the form is submitted (or any other <a href="/docs/actions">action</a> is called), not while the form is being filled out.</p>
<p>Take the <code>CreatePost</code> component, for example. If you want to make sure the &quot;title&quot; input field is synchronized with the <code>$title</code> property on the backend as the user types, you may add the <code>.live</code> modifier to <code>wire:model</code> like so:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;text&quot; wire:model.live=&quot;title&quot;&gt;
</div></code></pre>
<p>Now, as a user types into this field, network requests will be sent to the server to update <code>$title</code>. This is useful for things like a real-time search, where a dataset is filtered as a user types into a search box.</p>
<h2 id="only-updating-fields-on-blur">Only updating fields on <em>blur</em></h2>
<p>For most cases, <code>wire:model.live</code> is fine for real-time form field updating; however, it can be overly network resource-intensive on text inputs.</p>
<p>If instead of sending network requests as a user types, you want to instead only send the request when a user &quot;tabs&quot; out of the text input (also referred to as &quot;blurring&quot; an input), you can use the <code>.blur</code> modifier instead:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;text&quot; wire:model.blur=&quot;title&quot; &gt;
</div></code></pre>
<p>Now the component class on the server won't be updated until the user presses tab or clicks away from the text input.</p>
<h2 id="real-time-validation">Real-time validation</h2>
<p>Sometimes, you may want to show validation errors as the user fills out the form. This way, they are alerted early that something is wrong instead of having to wait until the entire form is filled out.</p>
<p>Livewire handles this sort of thing automatically. By using <code>.live</code> or <code>.blur</code> on <code>wire:model</code>, Livewire will send network requests as the user fills out the form. Each of those network requests will run the appropriate validation rules before updating each property. If validation fails, the property won't be updated on the server and a validation message will be shown to the user:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;text&quot; wire:model.blur=&quot;title&quot;&gt;

&lt;div&gt;
    @error('title') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror
&lt;/div&gt;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">#[Validate('required|min:5')]</span>
<span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;
</div></code></pre>
<p>Now, if the user only types three characters into the &quot;title&quot; input, then clicks on the next input in the form, a validation message will be shown to them indicating there is a five character minimum for that field.</p>
<p>For more information, check out the <a href="/docs/validation">validation documentation page</a>.</p>
<h2 id="real-time-form-saving">Real-time form saving</h2>
<p>If you want to automatically save a form as the user fills it out rather than wait until the user clicks &quot;submit&quot;, you can do so using Livewire's <code>updated()</code> hook:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-comment">#[Validate('required')]</span>
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required')]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = $post;
        <span class="hljs-keyword">$this</span>-&gt;title = $post-&gt;title;
        <span class="hljs-keyword">$this</span>-&gt;content = $post-&gt;content;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updated</span><span class="hljs-params">($name, $value)</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:5]
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post-&gt;update([
            $name =&gt; $value,
        ]);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.create-post'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit&gt;
    &lt;input type=&quot;text&quot; wire:model.blur=&quot;title&quot;&gt;
    &lt;div&gt;
        @error('title') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror
    &lt;/div&gt;

    &lt;input type=&quot;text&quot; wire:model.blur=&quot;content&quot;&gt;
    &lt;div&gt;
        @error('content') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror
    &lt;/div&gt;
&lt;/form&gt;
</div></code></pre>
<p>In the above example, when a user completes a field (by clicking or tabbing to the next field), a network request is sent to update that property on the component. Immediately after the property is updated on the class, the <code>updated()</code> hook is called for that specific property name and its new value.</p>
<p>We can use this hook to update only that specific field in the database.</p>
<p>Additionally, because we have the <code>#[Validate]</code> attributes attached to those properties, the validation rules will be run before the property is updated and the <code>updated()</code> hook is called.</p>
<p>To learn more about the &quot;updated&quot; lifecycle hook and other hooks, <a href="/docs/lifecycle-hooks">visit the lifecycle hooks documentation</a>.</p>
<h2 id="showing-dirty-indicators">Showing dirty indicators</h2>
<p>In the real-time saving scenario discussed above, it may be helpful to indicate to users when a field hasn't been persisted to the database yet.</p>
<p>For example, if a user visits an <code>UpdatePost</code> page and starts modifying the title of the post in a text input, it may be unclear to them when the title is actually being updated in the database, especially if there is no &quot;Save&quot; button at the bottom of the form.</p>
<p>Livewire provides the <code>wire:dirty</code> directive to allow you to toggle elements or modify classes when an input's value diverges from the server-side component:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;text&quot; wire:model.blur=&quot;title&quot; wire:dirty.class=&quot;border-yellow&quot;&gt;
</div></code></pre>
<p>In the above example, when a user types into the input field, a yellow border will appear around the field. When the user tabs away, the network request is sent and the border will disappear; signaling to them that the input has been persisted and is no longer &quot;dirty&quot;.</p>
<p>If you want to toggle an entire element's visibility, you can do so by using <code>wire:dirty</code> in conjunction with <code>wire:target</code>. <code>wire:target</code> is used to specify which piece of data you want to watch for &quot;dirtiness&quot;. In this case, the &quot;title&quot; field:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;

&lt;div wire:dirty wire:target=&quot;title&quot;&gt;Unsaved...&lt;/div&gt;
</div></code></pre>
<h2 id="debouncing-input">Debouncing input</h2>
<p>When using <code>.live</code> on a text input, you may want more fine-grained control over how often a network request is sent. By default, a debounce of &quot;250ms&quot; is applied to the input; however, you can customize this using the <code>.debounce</code> modifier:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;text&quot; wire:model.live.debounce.150ms=&quot;title&quot; &gt;
</div></code></pre>
<p>Now that <code>.debounce.150ms</code> has been added to the field, a shorter debounce of &quot;150ms&quot; will be used when handling input updates for this field. In other words, as a user types, a network request will only be sent if the user stops typing for at least 150 milliseconds.</p>
<h2 id="throttling-input">Throttling input</h2>
<p>As stated previously, when an input debounce is applied to a field, a network request will not be sent until the user has stopped typing for a certain amount of time. This means if the user continues typing a long message, a network request won't be sent until the user is finished.</p>
<p>Sometimes this isn't the desired behavior, and you would rather send a request as the user types, not when they've finished or taken a break.</p>
<p>In these cases, you can instead use <code>.throttle</code> to signify a time interval to send network requests:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;text&quot; wire:model.live.throttle.150ms=&quot;title&quot; &gt;
</div></code></pre>
<p>In the above example, as a user is typing continuously in the &quot;title&quot; field, a network request will be sent every 150 milliseconds until the user is finished.</p>
<h2 id="extracting-input-fields-to-blade-components">Extracting input fields to Blade components</h2>
<p>Even in a small component such as the <code>CreatePost</code> example we've been discussing, we end up duplicating lots of form field boilerplate like validation messages and labels.</p>
<p>It can be helpful to extract repetitive UI elements such as these into dedicated <a href="https://laravel.com/docs/blade#components">Blade components</a> to be shared across your application.</p>
<p>For example, below is the original Blade template from the <code>CreatePost</code> component. We will be extracting the following two text inputs into dedicated Blade components:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt; &lt;!-- [tl! highlight:3] --&gt;
    &lt;div&gt;
        @error('title') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror
    &lt;/div&gt;

    &lt;input type=&quot;text&quot; wire:model=&quot;content&quot;&gt; &lt;!-- [tl! highlight:3] --&gt;
    &lt;div&gt;
        @error('content') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror
    &lt;/div&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>Here's what the template will look like after extracting a re-usable Blade component called <code>&lt;x-input-text&gt;</code>:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;x-input-text name=&quot;title&quot; wire:model=&quot;title&quot; /&gt; &lt;!-- [tl! highlight] --&gt;

    &lt;x-input-text name=&quot;content&quot; wire:model=&quot;content&quot; /&gt; &lt;!-- [tl! highlight] --&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>Next, here's the source for the <code>x-input-text</code> component:</p>
<pre class="hljs"><code><div>&lt;!-- resources/views/components/input-text.blade.php --&gt;

@props(['name'])

&lt;input type=&quot;text&quot; name=&quot;{{ $name }}&quot; {{ $attributes }}&gt;

&lt;div&gt;
    @error($name) &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror
&lt;/div&gt;
</div></code></pre>
<p>As you can see, we took the repetitive HTML and placed it inside a dedicated Blade component.</p>
<p>For the most part, the Blade component contains only the extracted HTML from the original component. However, we have added two things:</p>
<ul>
<li>The <code>@props</code> directive</li>
<li>The <code>{{ $attributes }}</code> statement on the input</li>
</ul>
<p>Let's discuss each of these additions:</p>
<p>By specifying <code>name</code> as a &quot;prop&quot; using <code>@props(['name'])</code> we are telling Blade: if an attribute called &quot;name&quot; is set on this component, take its value and make it available inside this component as <code>$name</code>.</p>
<p>For other attributes that don't have an explicit purpose, we used the <code>{{ $attributes }}</code> statement. This is used for &quot;attribute forwarding&quot;, or in other words, taking any HTML attributes written on the Blade component and forwarding them onto an element within the component.</p>
<p>This ensures <code>wire:model=&quot;title&quot;</code> and any other extra attributes such as <code>disabled</code>, <code>class=&quot;...&quot;</code>, or <code>required</code> still get forwarded to the actual <code>&lt;input&gt;</code> element.</p>
<h3 id="custom-form-controls">Custom form controls</h3>
<p>In the previous example, we &quot;wrapped&quot; an input element into a re-usable Blade component we can use as if it was a native HTML input element.</p>
<p>This pattern is very useful; however, there might be some cases where you want to create an entire input component from scratch (without an underlying native input element), but still be able to bind its value to Livewire properties using <code>wire:model</code>.</p>
<p>For example, let's imagine you wanted to create an <code>&lt;x-input-counter /&gt;</code> component that was a simple &quot;counter&quot; input written in Alpine.</p>
<p>Before we create a Blade component, let's first look at a simple, pure-Alpine, &quot;counter&quot; component for reference:</p>
<pre class="hljs"><code><div>&lt;div x-data=&quot;{ count: 0 }&quot;&gt;
    &lt;button x-on:click=&quot;count--&quot;&gt;-&lt;/button&gt;

    &lt;span x-text=&quot;count&quot;&gt;&lt;/span&gt;

    &lt;button x-on:click=&quot;count++&quot;&gt;+&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>As you can see, the component above shows a number alongside two buttons to increment and decrement that number.</p>
<p>Now, let's imagine we want to extract this component into a Blade component called <code>&lt;x-input-counter /&gt;</code> that we would use within a component like so:</p>
<pre class="hljs"><code><div>&lt;x-input-counter wire:model=&quot;quantity&quot; /&gt;
</div></code></pre>
<p>Creating this component is mostly simple. We take the HTML of the counter and place it inside a Blade component template like <code>resources/views/components/input-counter.blade.php</code>.</p>
<p>However, making it work with <code>wire:model=&quot;quantity&quot;</code> so that you can easily bind data from your Livewire component to the &quot;count&quot; inside this Alpine component needs one extra step.</p>
<p>Here's the source for the component:</p>
<pre class="hljs"><code><div>&lt;!-- resources/view/components/input-counter.blade.php --&gt;

&lt;div x-data=&quot;{ count: 0 }&quot; x-modelable=&quot;count&quot; {{ $attributes}}&gt;
    &lt;button x-on:click=&quot;count--&quot;&gt;-&lt;/button&gt;

    &lt;span x-text=&quot;count&quot;&gt;&lt;/span&gt;

    &lt;button x-on:click=&quot;count++&quot;&gt;+&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>As you can see, the only different bit about this HTML is the <code>x-modelable=&quot;count&quot;</code> and <code>{{ $attributes }}</code>.</p>
<p><code>x-modelable</code> is a utility in Alpine that tells Alpine to make a certain piece of data available for binding from outside. <a href="https://alpinejs.dev/directives/modelable">The Alpine documentation has more information on this directive.</a></p>
<p><code>{{ $attributes }}</code>, as we explored earlier, forwards any attributes passed into the Blade component from outside. In this case, the <code>wire:model</code> directive will be forwarded.</p>
<p>Because of <code>{{ $attributes }}</code>, when the HTML is rendered in the browser, <code>wire:model=&quot;quantity&quot;</code> will be rendered alongside <code>x-modelable=&quot;count&quot;</code> on the root <code>&lt;div&gt;</code> of the Alpine component like so:</p>
<pre class="hljs"><code><div>&lt;div x-data=&quot;{ count: 0 }&quot; x-modelable=&quot;count&quot; wire:model=&quot;quantity&quot;&gt;
</div></code></pre>
<p><code>x-modelable=&quot;count&quot;</code> tells Alpine to look for any <code>x-model</code> or <code>wire:model</code> statements and use &quot;count&quot; as the data to bind them to.</p>
<p>Because <code>x-modelable</code> works for both <code>wire:model</code> and <code>x-model</code>, you can also use this Blade component interchangeably with Livewire and Alpine. For example, here's an example of using this Blade component in a purely Alpine context:</p>
<pre class="hljs"><code><div>&lt;x-input-counter x-model=&quot;quantity&quot; /&gt;
</div></code></pre>
<p>Creating custom input elements in your application is extremely powerful but requires a deeper understanding of the utilities Livewire and Alpine provide and how they interact with each other.</p>
<pre class="hljs"><code><div>
## File: how-livewire-works.md
```md

* The component
    * Counter component
* Rendering the component
    * Mount
        * New up class
        * Dehydrate state
        * Embed inside HTML
        * Return HTML
* Initializing the component in JS
    * Finding wire:id elements
    * Extracting id and snapshot
    * Newing up object
* Sending an update
    * Registering event listeners
    * Sending a fetch request with updates and snapshot
* Receiving an update
    * Converting snapshot to component (hydrate)
    * Applying updates
    * Rendering component
    * Returning HTML and new snapshot
* Processing an update
    * Replacing with new snapshot
    * Replacing HTML with new HTML
        * Morphing

## The component

```php
&lt;?php

use Livewire\Component;

class Counter extends Component
{
    public $count = 1;

    public function increment()
    {
        $this-&gt;count++;
    }

    public function render()
    {
        return view('livewire.counter');
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;button wire:click=&quot;increment&quot;&gt;Increment&lt;/button&gt;

    &lt;span&gt;{{ $count }}&lt;/span&gt;
&lt;/div&gt;
</div></code></pre>
<h2 id="rendering-the-component">Rendering the component</h2>
<pre class="hljs"><code><div>&lt;livewire:counter /&gt;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> Livewire::mount(<span class="hljs-string">'counter'</span>); <span class="hljs-meta">?&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($name)</span>
</span>{
    $class = Livewire::getComponentClassByName();

    $component = <span class="hljs-keyword">new</span> $class;

    $id = str()-&gt;random(<span class="hljs-number">20</span>);

    $component-&gt;setId($id);

    $data = $component-&gt;getData();

    $view = $component-&gt;render();

    $html = $view-&gt;render($data);

    $snapshot = [
        <span class="hljs-string">'data'</span> =&gt; $data,
        <span class="hljs-string">'memo'</span> =&gt; [
            <span class="hljs-string">'id'</span> =&gt; $component-&gt;getId(),
            <span class="hljs-string">'name'</span> =&gt; $component-&gt;getName(),
        ]
    ];

    <span class="hljs-keyword">return</span> Livewire::embedSnapshotInsideHtml($html, $snapshot);
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div wire:id=&quot;123456789&quot; wire:snapshot=&quot;{ data: { count: 0 }, memo: { 'id': '123456789', 'name': 'counter' }&quot;&gt;
    &lt;button wire:click=&quot;increment&quot;&gt;Increment&lt;/button&gt;

    &lt;span&gt;1&lt;/span&gt;
&lt;/div&gt;
</div></code></pre>
<h2 id="javascript-initialization">JavaScript initialization</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'wire\\:id'</span>)

<span class="hljs-keyword">let</span> id = el.getAttribute(<span class="hljs-string">'wire:id'</span>)
<span class="hljs-keyword">let</span> jsonSnapshot = el.getAttribute(<span class="hljs-string">'wire:snapshot'</span>)
<span class="hljs-keyword">let</span> snapshot = <span class="hljs-built_in">JSON</span>.parse(jsonSnapshot)

<span class="hljs-keyword">let</span> component = { id, snapshot }

walk(el, el =&gt; {
    el.hasAttribute(<span class="hljs-string">'wire:click'</span>) {
        <span class="hljs-keyword">let</span> action = el.getAttribute(<span class="hljs-string">'wire:click'</span>)

        el.addEventListener(<span class="hljs-string">'click'</span>, e =&gt; {
            updateComponent(el, component, action)
        })
    }
})

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateComponent</span>(<span class="hljs-params">el, component, action</span>) </span>{
    <span class="hljs-keyword">let</span> response fetch(<span class="hljs-string">'/livewire/update'</span>, {
        <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({
            <span class="hljs-string">"snapshot"</span>: snapshot,
            <span class="hljs-string">"calls"</span>: [
                [<span class="hljs-string">"method"</span>: action, <span class="hljs-string">"params"</span>: []],
            ]
        })
    })

    <span class="hljs-comment">// To be continued...</span>
}
</div></code></pre>
<h2 id="receiving-an-update">Receiving an update</h2>
<pre class="hljs"><code><div>Route::post(<span class="hljs-string">'/livewire/update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    $snapshot = request(<span class="hljs-string">'snapshot'</span>);
    $calls = requets(<span class="hljs-string">'calls'</span>);

    $component = Livewire::fromSnapshot($snapshot);

    <span class="hljs-keyword">foreach</span> ($calls <span class="hljs-keyword">as</span> $call) {
        $component-&gt;{$call[<span class="hljs-string">'method'</span>]}(...$call[<span class="hljs-string">'params'</span>]);
    }

    [$html, $snapshot] = Livewire::snapshot($component);

    <span class="hljs-keyword">return</span> [
        <span class="hljs-string">'snapshot'</span> =&gt; $snapshot,
        <span class="hljs-string">'html'</span> =&gt; $html,
    ];
});
</div></code></pre>
<h2 id="handling-an-update">Handling an update</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateComponent</span>(<span class="hljs-params">el, component, action</span>) </span>{
    fetch(<span class="hljs-string">'/livewire/update'</span>, {
        <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({
            <span class="hljs-string">"snapshot"</span>: snapshot,
            <span class="hljs-string">"calls"</span>: [
                [<span class="hljs-string">"method"</span>: action, <span class="hljs-string">"params"</span>: []],
            ]
        })
    }).then(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.json()).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        <span class="hljs-keyword">let</span> { html, snapshot } = response

        component.snapshot = snapshot

        el.outerHTML = html
    })
}
</div></code></pre>
<pre class="hljs"><code><div>
## File: hydration.md
```md

Using Livewire feels like attaching a server-side PHP class directly to a web browser. Things like calling server-side functions directly from button presses support this illusion. But in reality, it is just that: an illusion.

In the background, Livewire actually behaves much more like a standard web application. It renders static HTML to the browser, listens for browser events, then makes AJAX requests to invoke server-side code.

Because each AJAX request Livewire makes to the server is &quot;stateless&quot; (meaning there isn't a long running backend process keeping the state of a component alive), Livewire must re-create the last-known state of a component before making any updates.

It does this by taking &quot;snapshots&quot; of the PHP component after each server-side update so that the component can be re-created or _resumed_ on the next request.

Throughout this documentation, we will refer to the process of taking the snapshot as &quot;dehydration&quot; and the process of re-creating a component from a snapshot as &quot;hydration&quot;.

## Dehydrating

When Livewire _dehydrates_ a server-side component, it does two things:

* Renders the component's template to HTML
* Creates a JSON snapshot of the component

### Rendering HTML

After a component is mounted or an update has been made, Livewire calls a component's `render()` method to convert the Blade template to raw HTML.

Take the following `Counter` component for example:

```php
class Counter extends Component
{
    public $count = 1;

    public function increment()
    {
        $this-&gt;count++;
    }

    public function render()
    {
        return &lt;&lt;&lt;'HTML'
        &lt;div&gt;
            Count: {{ $count }}

            &lt;button wire:click=&quot;increment&quot;&gt;+&lt;/button&gt;
        &lt;/div&gt;
        HTML;
    }
}
</div></code></pre>
<p>After each mount or update, Livewire would render the above <code>Counter</code> component to the following HTML:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    Count: 1

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"increment"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h3 id="the-snapshot">The snapshot</h3>
<p>In order to re-create the <code>Counter</code> component on the server during the next request, a JSON snapshot is created, attempting to capture as much of the state of the component as possible:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">state</span>: {
        <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,
    },

    <span class="hljs-attr">memo</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'counter'</span>,

        <span class="hljs-attr">id</span>: <span class="hljs-string">'1526456'</span>,
    },
}
</div></code></pre>
<p>Notice two different portions of the snapshot: <code>memo</code>, and <code>state</code>.</p>
<p>The <code>memo</code> portion is used to store the information needed to identify and re-create the component, while the <code>state</code> portion stores the values of all the component's public properties.</p>
<blockquote>
<p>[!info]
The above snapshot is a condensed version of an actual snapshot in Livewire. In live applications, the snapshot contains much more information, such as validation errors, a list of child components, locales, and much more. For a more detailed look at a snapshot object you may reference the <a href="/docs/javascript#the-snapshot-object">snapshot schema documentation</a>.</p>
</blockquote>
<h3 id="embedding-the-snapshot-in-the-html">Embedding the snapshot in the HTML</h3>
<p>When a component is first rendered, Livewire stores the snapshot as JSON inside an HTML attribute called <code>wire:snapshot</code>. This way, Livewire's JavaScript core can extract the JSON and turn it into a run-time object:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:id</span>=<span class="hljs-string">"..."</span> <span class="hljs-attr">wire:snapshot</span>=<span class="hljs-string">"{ state: {...}, memo: {...} }"</span>&gt;</span>
    Count: 1

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"increment"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h2 id="hydrating">Hydrating</h2>
<p>When a component update is triggered, for example, the &quot;+&quot; button is pressed in the <code>Counter</code> component, a payload like the following is sent to the server:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">calls</span>: [
        { <span class="hljs-attr">method</span>: <span class="hljs-string">'increment'</span>, <span class="hljs-attr">params</span>: [] },
    ],

    <span class="hljs-attr">snapshot</span>: {
        <span class="hljs-attr">state</span>: {
            <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,
        },

        <span class="hljs-attr">memo</span>: {
            <span class="hljs-attr">name</span>: <span class="hljs-string">'counter'</span>,

            <span class="hljs-attr">id</span>: <span class="hljs-string">'1526456'</span>,
        },
    }
}
</div></code></pre>
<p>Before Livewire can call the <code>increment</code> method, it must first create a new <code>Counter</code> instance and seed it with the snapshot's state.</p>
<p>Here is some PHP pseudo-code that achieves this result:</p>
<pre class="hljs"><code><div>$state = request(<span class="hljs-string">'snapshot.state'</span>);
$memo = request(<span class="hljs-string">'snapshot.memo'</span>);

$instance = Livewire::new($memo[<span class="hljs-string">'name'</span>], $memo[<span class="hljs-string">'id'</span>]);

<span class="hljs-keyword">foreach</span> ($state <span class="hljs-keyword">as</span> $property =&gt; $value) {
    $instance[$property] = $value;
}
</div></code></pre>
<p>If you follow the above script, you will see that after creating a <code>Counter</code> object, its public properties are set based on the state provided from the snapshot.</p>
<h2 id="advanced-hydration">Advanced hydration</h2>
<p>The above <code>Counter</code> example works well to demonstrate the concept of hydration; however, it only demonstrates how Livewire handles hydrating simple values like integers (<code>1</code>).</p>
<p>As you may know, Livewire supports many more sophisticated property types beyond integers.</p>
<p>Let's take a look at a slightly more complex example - a <code>Todos</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $todos;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">$this</span>-&gt;todos = collect([
            <span class="hljs-string">'first'</span>,
            <span class="hljs-string">'second'</span>,
            <span class="hljs-string">'third'</span>,
        ]);
    }
}
</div></code></pre>
<p>As you can see, we are setting the <code>$todos</code> property to a <a href="https://laravel.com/docs/collections#main-content">Laravel collection</a> with three strings as its content.</p>
<p>JSON alone has no way of representing Laravel collections, so instead, Livewire has created its own pattern of associating metadata with pure data inside a snapshot.</p>
<p>Here is the snapshot's state object for this <code>Todos</code> component:</p>
<pre class="hljs"><code><div>state: {
    <span class="hljs-attr">todos</span>: [
        [ <span class="hljs-string">'first'</span>, <span class="hljs-string">'second'</span>, <span class="hljs-string">'third'</span> ],
        { <span class="hljs-attr">s</span>: <span class="hljs-string">'clctn'</span>, <span class="hljs-attr">class</span>: <span class="hljs-string">'Illuminate\\Support\\Collection'</span> },
    ],
},
</div></code></pre>
<p>This may be confusing to you if you were expecting something more straightforward like:</p>
<pre class="hljs"><code><div>state: {
    <span class="hljs-attr">todos</span>: [ <span class="hljs-string">'first'</span>, <span class="hljs-string">'second'</span>, <span class="hljs-string">'third'</span> ],
},
</div></code></pre>
<p>However, if Livewire were hydrating a component based on this data, it would have no way of knowing it's a collection and not a plain array.</p>
<p>Therefore, Livewire supports an alternate state syntax in the form of a tuple (an array of two items):</p>
<pre class="hljs"><code><div>todos: [
    [ <span class="hljs-string">'first'</span>, <span class="hljs-string">'second'</span>, <span class="hljs-string">'third'</span> ],
    { <span class="hljs-attr">s</span>: <span class="hljs-string">'clctn'</span>, <span class="hljs-attr">class</span>: <span class="hljs-string">'Illuminate\\Support\\Collection'</span> },
],
</div></code></pre>
<p>When Livewire encounters a tuple when hydrating a component's state, it uses information stored in the second element of the tuple to more intelligently hydrate the state stored in the first.</p>
<p>To demonstrate more clearly, here is simplified code showing how Livewire might re-create a collection property based on the above snapshot:</p>
<pre class="hljs"><code><div>[ $state, $metadata ] = request(<span class="hljs-string">'snapshot.state.todos'</span>);

$collection = <span class="hljs-keyword">new</span> $metadata[<span class="hljs-string">'class'</span>]($state);
</div></code></pre>
<p>As you can see, Livewire uses the metadata associated with the state to derive the full collection class.</p>
<h3 id="deeply-nested-tuples">Deeply nested tuples</h3>
<p>One distinct advantage of this approach is the ability to dehydrate and hydrate deeply nested properties.</p>
<p>For example, consider the above <code>Todos</code> example, except now with a <a href="https://laravel.com/docs/helpers#method-str">Laravel Stringable</a> instead of a plain string as the third item in the collection:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $todos;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">$this</span>-&gt;todos = collect([
            <span class="hljs-string">'first'</span>,
            <span class="hljs-string">'second'</span>,
            str(<span class="hljs-string">'third'</span>),
        ]);
    }
}
</div></code></pre>
<p>The dehydrated snapshot for this component's state would now look like this:</p>
<pre class="hljs"><code><div>todos: [
    [
        <span class="hljs-string">'first'</span>,
        <span class="hljs-string">'second'</span>,
        [ <span class="hljs-string">'third'</span>, { <span class="hljs-attr">s</span>: <span class="hljs-string">'str'</span> } ],
    ],
    { <span class="hljs-attr">s</span>: <span class="hljs-string">'clctn'</span>, <span class="hljs-attr">class</span>: <span class="hljs-string">'Illuminate\\Support\\Collection'</span> },
],
</div></code></pre>
<p>As you can see, the third item in the collection has been dehydrated into a metadata tuple. The first element in the tuple being the plain string value, and the second being a flag denoting to Livewire that this string is a <em>stringable</em>.</p>
<h3 id="supporting-custom-property-types">Supporting custom property types</h3>
<p>Internally, Livewire has hydration support for the most common PHP and Laravel types. However, if you wish to support un-supported types, you can do so using <a href="/docs/synthesizers">Synthesizers</a> — Livewire's internal mechanism for hydrating/dehydrating non-primitive property types.</p>
<pre class="hljs"><code><div>
## File: installation.md
```md
Livewire is a Laravel package, so you will need to have a Laravel application up and running before you can install and use Livewire. If you need help setting up a new Laravel application, please see the [official Laravel documentation](https://laravel.com/docs/installation).

To install Livewire, open your terminal and navigate to your Laravel application directory, then run the following command:

```shell
composer require livewire/livewire
</div></code></pre>
<p>That's it — really. If you want more customization options, keep reading. Otherwise, you can jump right into using Livewire.</p>
<blockquote>
<p>[!warning] <code>/livewire/livewire.js</code> returning a 404 status code
By default, Livewire exposes a route in your application to serve its JavaScript assets from: <code>/livewire/livewire.js</code>. This is fine for most applications, however, if you are using Nginx with a custom configuration, you may receive a 404 from this endpoint. To fix this issue, you can either <a href="#manually-bundling-livewire-and-alpine">compile Livewire's JavaScript assets yourself</a>, or <a href="https://benjamincrozat.com/livewire-js-404-not-found">configure Nginx to allow for this</a>.</p>
</blockquote>
<h2 id="publishing-the-configuration-file">Publishing the configuration file</h2>
<p>Livewire is &quot;zero-config&quot;, meaning you can use it by following conventions, without any additional configuration. However, if needed, you can publish and customize Livewire's configuration file by running the following Artisan command:</p>
<pre class="hljs"><code><div>php artisan livewire:publish --config
</div></code></pre>
<p>This will create a new <code>livewire.php</code> file in your Laravel application's <code>config</code> directory.</p>
<h2 id="manually-including-livewires-frontend-assets">Manually including Livewire's frontend assets</h2>
<p>By default, Livewire injects the JavaScript and CSS assets it needs into each page that includes a Livewire component.</p>
<p>If you want more control over this behavior, you can manually include the assets on a page using the following Blade directives:</p>
<pre class="hljs"><code><div>&lt;html&gt;
&lt;head&gt;
	...
	@livewireStyles
&lt;/head&gt;
&lt;body&gt;
	...
	@livewireScripts
&lt;/body&gt;
&lt;/html&gt;
</div></code></pre>
<p>By including these assets manually on a page, Livewire knows not to inject the assets automatically.</p>
<blockquote>
<p>[!warning] AlpineJS is bundled with Livewire
Because Alpine is bundled with Livewire's JavaScript assets, you must include @verbatim<code>@livewireScripts</code>@endverbatim on every page you wish to use Alpine. Even if you're not using Livewire on that page.</p>
</blockquote>
<p>Though rarely required, you may disable Livewire's auto-injecting asset behavior by updating the <code>inject_assets</code> <a href="#publishing-config">configuration option</a> in your application's <code>config/livewire.php</code> file:</p>
<pre class="hljs"><code><div><span class="hljs-string">'inject_assets'</span> =&gt; <span class="hljs-keyword">false</span>,
</div></code></pre>
<p>If you'd rather force Livewire to inject its assets on a single page or multiple pages, you can call the following global method from the current route or from a service provider.</p>
<pre class="hljs"><code><div>\Livewire\Livewire::forceAssetInjection();
</div></code></pre>
<h2 id="configuring-livewires-update-endpoint">Configuring Livewire's update endpoint</h2>
<p>Every update in a Livewire component sends a network request to the server at the following endpoint: <code>https://example.com/livewire/update</code></p>
<p>This can be a problem for some applications that use localization or multi-tenancy.</p>
<p>In those cases, you can register your own endpoint however you like, and as long as you do it inside <code>Livewire::setUpdateRoute()</code>,  Livewire will know to use this endpoint for all component updates:</p>
<pre class="hljs"><code><div>Livewire::setUpdateRoute(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($handle)</span> </span>{
	<span class="hljs-keyword">return</span> Route::post(<span class="hljs-string">'/custom/livewire/update'</span>, $handle);
});
</div></code></pre>
<p>Now, instead of using <code>/livewire/update</code>, Livewire will send component updates to <code>/custom/livewire/update</code>.</p>
<p>Because Livewire allows you to register your own update route, you can declare any additional middleware you want Livewire to use directly inside <code>setUpdateRoute()</code>:</p>
<pre class="hljs"><code><div>Livewire::setUpdateRoute(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($handle)</span> </span>{
	<span class="hljs-keyword">return</span> Route::post(<span class="hljs-string">'/custom/livewire/update'</span>, $handle)
        -&gt;middleware([...]); <span class="hljs-comment">// [tl! highlight]</span>
});
</div></code></pre>
<h2 id="customizing-the-asset-url">Customizing the asset URL</h2>
<p>By default, Livewire will serve its JavaScript assets from the following URL: <code>https://example.com/livewire/livewire.js</code>. Additionally, Livewire will reference this asset from a script tag like so:</p>
<pre class="hljs"><code><div>&lt;script src=&quot;/livewire/livewire.js&quot; ...
</div></code></pre>
<p>If your application has global route prefixes due to localization or multi-tenancy, you can register your own endpoint that Livewire should use internally when fetching its JavaScript.</p>
<p>To use a custom JavaScript asset endpoint, you can register your own route inside <code>Livewire::setScriptRoute()</code>:</p>
<pre class="hljs"><code><div>Livewire::setScriptRoute(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($handle)</span> </span>{
    <span class="hljs-keyword">return</span> Route::get(<span class="hljs-string">'/custom/livewire/livewire.js'</span>, $handle);
});
</div></code></pre>
<p>Now, Livewire will load its JavaScript like so:</p>
<pre class="hljs"><code><div>&lt;script src=&quot;/custom/livewire/livewire.js&quot; ...
</div></code></pre>
<h2 id="manually-bundling-livewire-and-alpine">Manually bundling Livewire and Alpine</h2>
<p>By default, Alpine and Livewire are loaded using the <code>&lt;script src=&quot;livewire.js&quot;&gt;</code> tag, which means you have no control over the order in which these libraries are loaded. Consequently, importing and registering Alpine plugins, as shown in the example below, will no longer function:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Warning: This snippet demonstrates what NOT to do...</span>

<span class="hljs-keyword">import</span> Alpine <span class="hljs-keyword">from</span> <span class="hljs-string">'alpinejs'</span>
<span class="hljs-keyword">import</span> Clipboard <span class="hljs-keyword">from</span> <span class="hljs-string">'@ryangjchandler/alpine-clipboard'</span>

Alpine.plugin(Clipboard)
Alpine.start()
</div></code></pre>
<p>To address this issue, we need to inform Livewire that we want to use the ESM (ECMAScript module) version ourselves and prevent the injection of the <code>livewire.js</code> script tag. To achieve this, we must add the <code>@livewireScriptConfig</code> directive to our layout file (<code>resources/views/components/layouts/app.blade.php</code>):</p>
<pre class="hljs"><code><div>&lt;html&gt;
&lt;head&gt;
    &lt;!-- ... --&gt;
    @livewireStyles
    @vite(['resources/js/app.js'])
&lt;/head&gt;
&lt;body&gt;
    {{ $slot }}

    @livewireScriptConfig &lt;!-- [tl! highlight] --&gt;
&lt;/body&gt;
&lt;/html&gt;
</div></code></pre>
<p>When Livewire detects the <code>@livewireScriptConfig</code> directive, it will refrain from injecting the Livewire and Alpine scripts. If you are using the <code>@livewireScripts</code> directive to manually load Livewire, be sure to remove it. Make sure to add the <code>@livewireStyles</code> directive if it is not already present.</p>
<p>The final step is importing Alpine and Livewire in our <code>app.js</code> file, allowing us to register any custom resources, and ultimately starting Livewire and Alpine:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Livewire, Alpine } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../vendor/livewire/livewire/dist/livewire.esm'</span>;
<span class="hljs-keyword">import</span> Clipboard <span class="hljs-keyword">from</span> <span class="hljs-string">'@ryangjchandler/alpine-clipboard'</span>

Alpine.plugin(Clipboard)

Livewire.start()
</div></code></pre>
<blockquote>
<p>[!tip] Rebuild your assets after composer update
Make sure that if you are manually bundling Livewire and Alpine, that you rebuild your assets whenever you run <code>composer update</code>.</p>
</blockquote>
<blockquote>
<p>[!warning] Not compatible with Laravel Mix
Laravel Mix will not work if you are manually bundling Livewire and AlpineJS. Instead, we recommend that you <a href="https://laravel.com/docs/vite">switch to Vite</a>.</p>
</blockquote>
<h2 id="publishing-livewires-frontend-assets">Publishing Livewire's frontend assets</h2>
<blockquote>
<p>[!warning] Publishing assets isn't necessary
Publishing Livewire's assets isn't necessary for Livewire to run. Only do this if you have a specific need for it.</p>
</blockquote>
<p>If you prefer the JavaScript assets to be served by your web server not through Laravel, use the <code>livewire:publish</code> command:</p>
<pre class="hljs"><code><div>php artisan livewire:publish --assets
</div></code></pre>
<p>To keep assets up-to-date and avoid issues in future updates, we strongly recommend that you add the following command to your composer.json file:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"scripts"</span>: {
        <span class="hljs-attr">"post-update-cmd"</span>: [
            <span class="hljs-comment">// Other scripts</span>
            <span class="hljs-string">"@php artisan vendor:publish --tag=livewire:assets --ansi --force"</span>
        ]
    }
}
</div></code></pre>
<pre class="hljs"><code><div>
## File: javascript.md
```md

## Using JavaScript in Livewire components

Livewire and Alpine provide plenty of utilities for building dynamic components directly in your HTML, however, there are times when it's helpful to break out of the HTML and execute plain JavaScript for your component. Livewire's `@script` and `@assets` directive allow you to do this in a predictable, maintainable way.

### Executing scripts

To execute bespoke JavaScript in your Livewire component, simply wrap a `&lt;script&gt;` element with `@script` and `@endscript`. This will tell Livewire to handle the execution of this JavaScript.

Because scripts inside `@script` are handled by Livewire, they are executed at the perfect time after the page has loaded, but before the Livewire component has rendered. This means you no longer need to wrap your scripts in `document.addEventListener('...')` to load them properly.

This also means that lazily or conditionally loaded Livewire components are still able to execute JavaScript after the page has initialized.

```blade
&lt;div&gt;
    ...
&lt;/div&gt;

@script
&lt;script&gt;
    // This Javascript will get executed every time this component is loaded onto the page...
&lt;/script&gt;
@endscript
</div></code></pre>
<p>Here's a more full example where you can do something like register a one-off Alpine component that is used in your Livewire component.</p>
<pre class="hljs"><code><div>&lt;div&gt;
    Counter component in Alpine:

    &lt;div x-data=&quot;counter&quot;&gt;
        &lt;h1 x-text=&quot;count&quot;&gt;&lt;/h1&gt;
        &lt;button x-on:click=&quot;increment&quot;&gt;+&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;

@script
&lt;script&gt;
    Alpine.data('counter', () =&gt; {
        return {
            count: 0,
            increment() {
                this.count++
            },
        }
    })
&lt;/script&gt;
@endscript
</div></code></pre>
<h3 id="using-wire-from-scripts">Using <code>$wire</code> from scripts</h3>
<p>Another helpful feature of using <code>@script</code> for your JavaScript is that you automatically have access to your Livewire component's <code>$wire</code> object.</p>
<p>Here's an example of using a simple <code>setInterval</code> to refresh the component every 2 seconds (You could easily do this with <a href="/docs/wire-poll"><code>wire:poll</code></a>, but it's a simple way to demonstrate the point):</p>
<p>You can learn more about <code>$wire</code> on the <a href="#the-wire-object"><code>$wire</code> documentation</a>.</p>
<pre class="hljs"><code><div>@script
&lt;script&gt;
    setInterval(() =&gt; {
        $wire.$refresh()
    }, 2000)
&lt;/script&gt;
@endscript
</div></code></pre>
<h3 id="loading-assets">Loading assets</h3>
<p>The <code>@script</code> directive is useful for executing a bit of JavaScript every time a Livewire component loads, however, there are times you might want to load entire script and style assets on the page along with the component.</p>
<p>Here is an example of using <code>@assets</code> to load a date picker library called <a href="https://github.com/Pikaday/Pikaday">Pikaday</a> and initialize it inside your component using <code>@script</code>:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;input type=&quot;text&quot; data-picker&gt;
&lt;/div&gt;

@assets
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/pikaday/pikaday.js&quot; defer&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css&quot;&gt;
@endassets

@script
&lt;script&gt;
    new Pikaday({ field: $wire.$el.querySelector('[data-picker]') });
&lt;/script&gt;
@endscript
</div></code></pre>
<p>When this component loads, Livewire will make sure any <code>@assets</code> are loaded on that page before evaluating <code>@script</code>s. In addition, it will ensure the provided <code>@assets</code> are only loaded once per page no matter how many instances of this component there are, unlike <code>@script</code>, which will evaluate for every component instance on the page.</p>
<h2 id="global-livewire-events">Global Livewire events</h2>
<p>Livewire dispatches two helpful browser events for you to register any custom extension points from outside scripts:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:init'</span>, () =&gt; {
        <span class="hljs-comment">// Runs after Livewire is loaded but before it's initialized</span>
        <span class="hljs-comment">// on the page...</span>
    })

    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:initialized'</span>, () =&gt; {
        <span class="hljs-comment">// Runs immediately after Livewire has finished initializing</span>
        <span class="hljs-comment">// on the page...</span>
    })
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<blockquote>
<p>[!info]
It is often beneficial to register any <a href="#registering-custom-directives">custom directives</a> or <a href="#javascript-hooks">lifecycle hooks</a> inside of <code>livewire:init</code> so that they are available before Livewire begins initializing on the page.</p>
</blockquote>
<h2 id="the-livewire-global-object">The <code>Livewire</code> global object</h2>
<p>Livewire's global object is the best starting point for interacting with Livewire from external scripts.</p>
<p>You can access the global <code>Livewire</code> JavaScript object on <code>window</code> from anywhere inside your client-side code.</p>
<p>It is often helpful to use <code>window.Livewire</code> inside a <code>livewire:init</code> event listener</p>
<h3 id="accessing-components">Accessing components</h3>
<p>You can use the following methods to access specific Livewire components loaded on the current page:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Retrieve the $wire object for the first component on the page...</span>
<span class="hljs-keyword">let</span> component = Livewire.first()

<span class="hljs-comment">// Retrieve a given component's `$wire` object by its ID...</span>
<span class="hljs-keyword">let</span> component = Livewire.find(id)

<span class="hljs-comment">// Retrieve an array of component `$wire` objects by name...</span>
<span class="hljs-keyword">let</span> components = Livewire.getByName(name)

<span class="hljs-comment">// Retrieve $wire objects for every component on the page...</span>
<span class="hljs-keyword">let</span> components = Livewire.all()
</div></code></pre>
<blockquote>
<p>[!info]
Each of these methods returns a <code>$wire</code> object representing the component's state in Livewire.
<br><br>
You can learn more about these objects in <a href="#the-wire-object">the <code>$wire</code> documentation</a>.</p>
</blockquote>
<h3 id="interacting-with-events">Interacting with events</h3>
<p>In addition to dispatching and listening for events from individual components in PHP, the global <code>Livewire</code> object allows you to interact with <a href="/docs/events">Livewire's event system</a> from anywhere in your application:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Dispatch an event to any Livewire components listening...</span>
Livewire.dispatch(<span class="hljs-string">'post-created'</span>, { <span class="hljs-attr">postId</span>: <span class="hljs-number">2</span> })

<span class="hljs-comment">// Dispatch an event to a given Livewire component by name...</span>
Livewire.dispatchTo(<span class="hljs-string">'dashboard'</span>, <span class="hljs-string">'post-created'</span>, { <span class="hljs-attr">postId</span>: <span class="hljs-number">2</span> })

<span class="hljs-comment">// Listen for events dispatched from Livewire components...</span>
Livewire.on(<span class="hljs-string">'post-created'</span>, ({ postId }) =&gt; {
    <span class="hljs-comment">// ...</span>
})
</div></code></pre>
<p>In certain scenarios, you might need to unregister global Livewire events. For instance, when working with Alpine components and <code>wire:navigate</code>, multiple listeners may be registered as <code>init</code> is called when navigating between pages. To address this, utilize the <code>destroy</code> function, automatically invoked by Alpine. Loop through all your listeners within this function to unregister them and prevent any unwanted accumulation.</p>
<pre class="hljs"><code><div>Alpine.data(<span class="hljs-string">'MyComponent'</span>, () =&gt; ({
    <span class="hljs-attr">listeners</span>: [],
    init() {
        <span class="hljs-keyword">this</span>.listeners.push(  
            Livewire.on(<span class="hljs-string">'post-created'</span>, (options) =&gt; {  
                <span class="hljs-comment">// Do something...</span>
            })
        );
    },
    destroy() {
        <span class="hljs-keyword">this</span>.listeners.forEach(<span class="hljs-function">(<span class="hljs-params">listener</span>) =&gt;</span> {  
            listener();  
        });
    }
});
</div></code></pre>
<h3 id="using-lifecycle-hooks">Using lifecycle hooks</h3>
<p>Livewire allows you to hook into various parts of its global lifecycle using <code>Livewire.hook()</code>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Register a callback to execute on a given internal Livewire hook...</span>
Livewire.hook(<span class="hljs-string">'component.init'</span>, ({ component, cleanup }) =&gt; {
    <span class="hljs-comment">// ...</span>
})
</div></code></pre>
<p>More information about Livewire's JavaScript hooks can be <a href="#javascript-hooks">found below</a>.</p>
<h3 id="registering-custom-directives">Registering custom directives</h3>
<p>Livewire allows you to register custom directives using <code>Livewire.directive()</code>.</p>
<p>Below is an example of a custom <code>wire:confirm</code> directive that uses JavaScript's <code>confirm()</code> dialog to confirm or cancel an action before it is sent to the server:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:confirm</span>=<span class="hljs-string">"Are you sure?"</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"delete"</span>&gt;</span>Delete post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>Here is the implementation of <code>wire:confirm</code> using <code>Livewire.directive()</code>:</p>
<pre class="hljs"><code><div>Livewire.directive(<span class="hljs-string">'confirm'</span>, ({ el, directive, component, cleanup }) =&gt; {
    <span class="hljs-keyword">let</span> content =  directive.expression

    <span class="hljs-comment">// The "directive" object gives you access to the parsed directive.</span>
    <span class="hljs-comment">// For example, here are its values for: wire:click.prevent="deletePost(1)"</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// directive.raw = wire:click.prevent</span>
    <span class="hljs-comment">// directive.value = "click"</span>
    <span class="hljs-comment">// directive.modifiers = ['prevent']</span>
    <span class="hljs-comment">// directive.expression = "deletePost(1)"</span>

    <span class="hljs-keyword">let</span> onClick = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (! confirm(content)) {
            e.preventDefault()
            e.stopImmediatePropagation()
        }
    }

    el.addEventListener(<span class="hljs-string">'click'</span>, onClick, { <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> })

    <span class="hljs-comment">// Register any cleanup code inside `cleanup()` in the case</span>
    <span class="hljs-comment">// where a Livewire component is removed from the DOM while</span>
    <span class="hljs-comment">// the page is still active.</span>
    cleanup(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        el.removeEventListener(<span class="hljs-string">'click'</span>, onClick)
    })
})
</div></code></pre>
<h2 id="object-schemas">Object schemas</h2>
<p>When extending Livewire's JavaScript system, it's important to understand the different objects you might encounter.</p>
<p>Here is an exhaustive reference of each of Livewire's relevant internal properties.</p>
<p>As a reminder, the average Livewire user may never interact with these. Most of these objects are available for Livewire's internal system or advanced users.</p>
<h3 id="the-wire-object">The <code>$wire</code> object</h3>
<p>Given the following generic <code>Counter</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $count = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;count++;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.counter'</span>);
    }
}
</div></code></pre>
<p>Livewire exposes a JavaScript representation of the server-side component in the form of an object that is commonly referred to as <code>$wire</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> $wire = {
    <span class="hljs-comment">// All component public properties are directly accessible on $wire...</span>
    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,

    <span class="hljs-comment">// All public methods are exposed and callable on $wire...</span>
    increment() { ... },

    <span class="hljs-comment">// Access the `$wire` object of the parent component if one exists...</span>
    $parent,

    <span class="hljs-comment">// Access the root DOM element of the Livewire component...</span>
    $el,

    <span class="hljs-comment">// Access the ID of the current Livewire component...</span>
    $id,

    <span class="hljs-comment">// Get the value of a property by name...</span>
    <span class="hljs-comment">// Usage: $wire.$get('count')</span>
    $<span class="hljs-keyword">get</span>(name) { ... },

    <span class="hljs-comment">// Set a property on the component by name...</span>
    <span class="hljs-comment">// Usage: $wire.$set('count', 5)</span>
    $<span class="hljs-keyword">set</span>(name, value, live = true) { ... },

    <span class="hljs-comment">// Toggle the value of a boolean property...</span>
    $toggle(name, live = <span class="hljs-literal">true</span>) { ... },

    <span class="hljs-comment">// Call the method</span>
    <span class="hljs-comment">// Usage: $wire.$call('increment')</span>
    $call(method, ...params) { ... },

    <span class="hljs-comment">// Entangle the value of a Livewire property with a different,</span>
    <span class="hljs-comment">// arbitrary, Alpine property...</span>
    <span class="hljs-comment">// Usage: &lt;div x-data="{ count: $wire.$entangle('count') }"&gt;</span>
    $entangle(name, live = <span class="hljs-literal">false</span>) { ... },

    <span class="hljs-comment">// Watch the value of a property for changes...</span>
    <span class="hljs-comment">// Usage: Alpine.$watch('count', (value, old) =&gt; { ... })</span>
    $watch(name, callback) { ... },

    <span class="hljs-comment">// Refresh a component by sending a commit to the server</span>
    <span class="hljs-comment">// to re-render the HTML and swap it into the page...</span>
    $refresh() { ... },

    <span class="hljs-comment">// Identical to the above `$refresh`. Just a more technical name...</span>
    $commit() { ... },

    <span class="hljs-comment">// Listen for a an event dispatched from this component or its children...</span>
    <span class="hljs-comment">// Usage: $wire.$on('post-created', () =&gt; { ... })</span>
    $on(event, callback) { ... },

    <span class="hljs-comment">// Dispatch an event from this component...</span>
    <span class="hljs-comment">// Usage: $wire.$dispatch('post-created', { postId: 2 })</span>
    $dispatch(event, params = {}) { ... },

    <span class="hljs-comment">// Dispatch an event onto another component...</span>
    <span class="hljs-comment">// Usage: $wire.$dispatchTo('dashboard', 'post-created', { postId: 2 })</span>
    $dispatchTo(otherComponentName, event, params = {}) { ... },

    <span class="hljs-comment">// Dispatch an event onto this component and no others...</span>
    $dispatchSelf(event, params = {}) { ... },

    <span class="hljs-comment">// A JS API to upload a file directly to component</span>
    <span class="hljs-comment">// rather than through `wire:model`...</span>
    $upload(
        name, <span class="hljs-comment">// The property name</span>
        file, <span class="hljs-comment">// The File JavaScript object</span>
        finish = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { ... }, <span class="hljs-comment">// Runs when the upload is finished...</span>
        error = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { ... }, <span class="hljs-comment">// Runs if an error is triggered mid-upload...</span>
        progress = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> { <span class="hljs-comment">// Runs as the upload progresses...</span>
            event.detail.progress <span class="hljs-comment">// An integer from 1-100...</span>
        },
    ) { ... },

    <span class="hljs-comment">// API to upload multiple files at the same time...</span>
    $uploadMultiple(name, files, finish, error, progress) { },

    <span class="hljs-comment">// Remove an upload after it's been temporarily uploaded but not saved...</span>
    $removeUpload(name, tmpFilename, finish, error) { ... },

    <span class="hljs-comment">// Retrieve the underlying "component" object...</span>
    __instance() { ... },
}
</div></code></pre>
<p>You can learn more about <code>$wire</code> in <a href="/docs/properties#accessing-properties-from-javascript">Livewire's documentation on accessing properties in JavaScript</a>.</p>
<h3 id="the-snapshot-object">The <code>snapshot</code> object</h3>
<p>Between each network request, Livewire serializes the PHP component into an object that can be consumed in JavaScript. This snapshot is used to unserialize the component back into a PHP object and therefore has mechanisms built in to prevent tampering:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> snapshot = {
    <span class="hljs-comment">// The serialized state of the component (public properties)...</span>
    <span class="hljs-attr">data</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> },

    <span class="hljs-comment">// Long-standing information about the component...</span>
    <span class="hljs-attr">memo</span>: {
        <span class="hljs-comment">// The component's unique ID...</span>
        <span class="hljs-attr">id</span>: <span class="hljs-string">'0qCY3ri9pzSSMIXPGg8F'</span>,

        <span class="hljs-comment">// The component's name. Ex. &lt;livewire:[name] /&gt;</span>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'counter'</span>,

        <span class="hljs-comment">// The URI, method, and locale of the web page that the</span>
        <span class="hljs-comment">// component was originally loaded on. This is used</span>
        <span class="hljs-comment">// to re-apply any middleware from the original request</span>
        <span class="hljs-comment">// to subsequent component update requests (commits)...</span>
        <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
        <span class="hljs-attr">locale</span>: <span class="hljs-string">'en'</span>,

        <span class="hljs-comment">// A list of any nested "child" components. Keyed by</span>
        <span class="hljs-comment">// internal template ID with the component ID as the values...</span>
        <span class="hljs-attr">children</span>: [],

        <span class="hljs-comment">// Weather or not this component was "lazy loaded"...</span>
        <span class="hljs-attr">lazyLoaded</span>: <span class="hljs-literal">false</span>,

        <span class="hljs-comment">// A list of any validation errors thrown during the</span>
        <span class="hljs-comment">// last request...</span>
        <span class="hljs-attr">errors</span>: [],
    },

    <span class="hljs-comment">// A securely encryped hash of this snapshot. This way,</span>
    <span class="hljs-comment">// if a malicous user tampers with the snapshot with</span>
    <span class="hljs-comment">// the goal of accessing un-owned resources on the server,</span>
    <span class="hljs-comment">// the checksum validation will fail and an error will</span>
    <span class="hljs-comment">// be thrown...</span>
    <span class="hljs-attr">checksum</span>: <span class="hljs-string">'1bc274eea17a434e33d26bcaba4a247a4a7768bd286456a83ea6e9be2d18c1e7'</span>,
}
</div></code></pre>
<h3 id="the-component-object">The <code>component</code> object</h3>
<p>Every component on a page has a corresponding component object behind the scenes keeping track of its state and exposing its underlying functionality. This is one layer deeper than <code>$wire</code>. It is only meant for advanced usage.</p>
<p>Here's an actual component object for the above <code>Counter</code> component with descriptions of relevant properties in JS comments:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> component = {
    <span class="hljs-comment">// The root HTML element of the component...</span>
    <span class="hljs-attr">el</span>: HTMLElement,

    <span class="hljs-comment">// The unique ID of the component...</span>
    <span class="hljs-attr">id</span>: <span class="hljs-string">'0qCY3ri9pzSSMIXPGg8F'</span>,

    <span class="hljs-comment">// The component's "name" (&lt;livewire:[name] /&gt;)...</span>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'counter'</span>,

    <span class="hljs-comment">// The latest "effects" object. Effects are "side-effects" from server</span>
    <span class="hljs-comment">// round-trips. These include redirects, file downloads, etc...</span>
    <span class="hljs-attr">effects</span>: {},

    <span class="hljs-comment">// The component's last-known server-side state...</span>
    <span class="hljs-attr">canonical</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> },

    <span class="hljs-comment">// The component's mutable data object representing its</span>
    <span class="hljs-comment">// live client-side state...</span>
    <span class="hljs-attr">ephemeral</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> },

    <span class="hljs-comment">// A reactive version of `this.ephemeral`. Changes to</span>
    <span class="hljs-comment">// this object will be picked up by AlpineJS expressions...</span>
    <span class="hljs-attr">reactive</span>: <span class="hljs-built_in">Proxy</span>,

    <span class="hljs-comment">// A Proxy object that is typically used inside Alpine</span>
    <span class="hljs-comment">// expressions as `$wire`. This is meant to provide a</span>
    <span class="hljs-comment">// friendly JS object interface for Livewire components...</span>
    <span class="hljs-attr">$wire</span>: <span class="hljs-built_in">Proxy</span>,

    <span class="hljs-comment">// A list of any nested "child" components. Keyed by</span>
    <span class="hljs-comment">// internal template ID with the component ID as the values...</span>
    <span class="hljs-attr">children</span>: [],

    <span class="hljs-comment">// The last-known "snapshot" representation of this component.</span>
    <span class="hljs-comment">// Snapshots are taken from the server-side component and used</span>
    <span class="hljs-comment">// to re-create the PHP object on the backend...</span>
    <span class="hljs-attr">snapshot</span>: {...},

    <span class="hljs-comment">// The un-parsed version of the above snapshot. This is used to send back to the</span>
    <span class="hljs-comment">// server on the next roundtrip because JS parsing messes with PHP encoding</span>
    <span class="hljs-comment">// which often results in checksum mis-matches.</span>
    <span class="hljs-attr">snapshotEncoded</span>: <span class="hljs-string">'{"data":{"count":0},"memo":{"id":"0qCY3ri9pzSSMIXPGg8F","name":"counter","path":"\/","method":"GET","children":[],"lazyLoaded":true,"errors":[],"locale":"en"},"checksum":"1bc274eea17a434e33d26bcaba4a247a4a7768bd286456a83ea6e9be2d18c1e7"}'</span>,
}
</div></code></pre>
<h3 id="the-commit-payload">The <code>commit</code> payload</h3>
<p>When an action is performed on a Livewire component in the browser, a network request is triggered. That network request contains one or many components and various instructions for the server. Internally, these component network payloads are called &quot;commits&quot;.</p>
<p>The term &quot;commit&quot; was chosen as a helpful way to think about Livewire's relationship between frontend and backend. A component is rendered and manipulated on the frontend until an action is performed that requires it to &quot;commit&quot; its state and updates to the backend.</p>
<p>You will recognize this schema from the payload in the network tab of your browser's DevTools, or <a href="#javascript-hooks">Livewire's JavaScript hooks</a>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> commit = {
    <span class="hljs-comment">// Snapshot object...</span>
    <span class="hljs-attr">snapshot</span>: { ... },

    <span class="hljs-comment">// A key-value pair list of properties</span>
    <span class="hljs-comment">// to update on the server...</span>
    <span class="hljs-attr">updates</span>: {},

    <span class="hljs-comment">// An array of methods (with parameters) to call server-side...</span>
    <span class="hljs-attr">calls</span>: [
        { <span class="hljs-attr">method</span>: <span class="hljs-string">'increment'</span>, <span class="hljs-attr">params</span>: [] },
    ],
}
</div></code></pre>
<h2 id="javascript-hooks">JavaScript hooks</h2>
<p>For advanced users, Livewire exposes its internal client-side &quot;hook&quot; system. You can use the following hooks to extend Livewire's functionality or gain more information about your Livewire application.</p>
<h3 id="component-initialization">Component initialization</h3>
<p>Every time a new component is discovered by Livewire — whether on the initial page load or later on — the <code>component.init</code> event is triggered. You can hook into <code>component.init</code> to intercept or initialize anything related to the new component:</p>
<pre class="hljs"><code><div>Livewire.hook(<span class="hljs-string">'component.init'</span>, ({ component, cleanup }) =&gt; {
    <span class="hljs-comment">//</span>
})
</div></code></pre>
<p>For more information, please consult the <a href="#the-component-object">documentation on the component object</a>.</p>
<h3 id="dom-element-initialization">DOM element initialization</h3>
<p>In addition to triggering an event when new components are initialized, Livewire triggers an event for each DOM element within a given Livewire component.</p>
<p>This can be used to provide custom Livewire HTML attributes within your application:</p>
<pre class="hljs"><code><div>Livewire.hook(<span class="hljs-string">'element.init'</span>, ({ component, el }) =&gt; {
    <span class="hljs-comment">//</span>
})
</div></code></pre>
<h3 id="dom-morph-hooks">DOM Morph hooks</h3>
<p>During the DOM morphing phase—which occurs after Livewire completes a network roundtrip—Livewire triggers a series of events for every element that is mutated.</p>
<pre class="hljs"><code><div>Livewire.hook(<span class="hljs-string">'morph.updating'</span>,  ({ el, component, toEl, skip, childrenOnly }) =&gt; {
	<span class="hljs-comment">//</span>
})

Livewire.hook(<span class="hljs-string">'morph.updated'</span>, ({ el, component }) =&gt; {
	<span class="hljs-comment">//</span>
})

Livewire.hook(<span class="hljs-string">'morph.removing'</span>, ({ el, component, skip }) =&gt; {
	<span class="hljs-comment">//</span>
})

Livewire.hook(<span class="hljs-string">'morph.removed'</span>, ({ el, component }) =&gt; {
	<span class="hljs-comment">//</span>
})

Livewire.hook(<span class="hljs-string">'morph.adding'</span>,  ({ el, component }) =&gt; {
	<span class="hljs-comment">//</span>
})

Livewire.hook(<span class="hljs-string">'morph.added'</span>,  ({ el }) =&gt; {
	<span class="hljs-comment">//</span>
})
</div></code></pre>
<h3 id="commit-hooks">Commit hooks</h3>
<p>Because Livewire requests contain multiple components, <em>request</em> is too broad of a term to refer to an individual component's request and response payload. Instead, internally, Livewire refers to component updates as <em>commits</em> — in reference to <em>committing</em> component state to the server.</p>
<p>These hooks expose <code>commit</code> objects. You can learn more about their schema by reading <a href="#the-commit-payload">the commit object documentation</a>.</p>
<h4 id="preparing-commits">Preparing commits</h4>
<p>The <code>commit.prepare</code> hook will be triggered immediately before a request is sent to the server. This gives you a chance to add any last minute updates or actions to the outgoing request:</p>
<pre class="hljs"><code><div>Livewire.hook(<span class="hljs-string">'commit.prepare'</span>, ({ component, commit }) =&gt; {
    <span class="hljs-comment">// Runs before commit payloads are collected and sent to the server...</span>
})
</div></code></pre>
<h4 id="intercepting-commits">Intercepting commits</h4>
<p>Every time a Livewire component is sent to the server, a <em>commit</em> is made. To hook into the lifecycle and contents of an individual commit, Livewire exposes a <code>commit</code> hook.</p>
<p>This hook is extremely powerful as it provides methods for hooking into both the request and response of a Livewire commit:</p>
<pre class="hljs"><code><div>Livewire.hook(<span class="hljs-string">'commit'</span>, ({ component, commit, respond, succeed, fail }) =&gt; {
    <span class="hljs-comment">// Runs immediately before a commit's payload is sent to the server...</span>

    respond(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-comment">// Runs after a response is received but before it's processed...</span>
    })

    succeed(<span class="hljs-function">(<span class="hljs-params">{ snapshot, effect }</span>) =&gt;</span> {
        <span class="hljs-comment">// Runs after a successful response is received and processed</span>
        <span class="hljs-comment">// with a new snapshot and list of effects...</span>
    })

    fail(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-comment">// Runs if some part of the request failed...</span>
    })
})
</div></code></pre>
<h2 id="request-hooks">Request hooks</h2>
<p>If you would like to instead hook into the entire HTTP request going and returning from the server, you can do so using the <code>request</code> hook:</p>
<pre class="hljs"><code><div>Livewire.hook(<span class="hljs-string">'request'</span>, ({ uri, options, payload, respond, succeed, fail }) =&gt; {
    <span class="hljs-comment">// Runs after commit payloads are compiled, but before a network request is sent...</span>

    respond(<span class="hljs-function">(<span class="hljs-params">{ status, response }</span>) =&gt;</span> {
        <span class="hljs-comment">// Runs when the response is received...</span>
        <span class="hljs-comment">// "response" is the raw HTTP response object</span>
        <span class="hljs-comment">// before await response.text() is run...</span>
    })

    succeed(<span class="hljs-function">(<span class="hljs-params">{ status, json }</span>) =&gt;</span> {
        <span class="hljs-comment">// Runs when the response is received...</span>
        <span class="hljs-comment">// "json" is the JSON response object...</span>
    })

    fail(<span class="hljs-function">(<span class="hljs-params">{ status, content, preventDefault }</span>) =&gt;</span> {
        <span class="hljs-comment">// Runs when the response has an error status code...</span>
        <span class="hljs-comment">// "preventDefault" allows you to disable Livewire's</span>
        <span class="hljs-comment">// default error handling...</span>
        <span class="hljs-comment">// "content" is the raw response content...</span>
    })
})
</div></code></pre>
<h3 id="customizing-page-expiration-behavior">Customizing page expiration behavior</h3>
<p>If the default page expired dialog isn't suitable for your application, you can implement a custom solution using the <code>request</code> hook:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:init'</span>, () =&gt; {
        Livewire.hook(<span class="hljs-string">'request'</span>, ({ fail }) =&gt; {
            fail(<span class="hljs-function">(<span class="hljs-params">{ status, preventDefault }</span>) =&gt;</span> {
                <span class="hljs-keyword">if</span> (status === <span class="hljs-number">419</span>) {
                    confirm(<span class="hljs-string">'Your custom page expiration behavior...'</span>)

                    preventDefault()
                }
            })
        })
    })
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<p>With the above code in your application, users will receive a custom dialog when their session has expired.</p>
<pre class="hljs"><code><div>
## File: lazy.md
```md
Livewire allows you to lazy load components that would otherwise slow down the initial page load.

For example, imagine you have a `Revenue` component which contains a slow database query in `mount()`:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;
use App\Models\Transaction;

class Revenue extends Component
{
    public $amount;

    public function mount()
    {
        // Slow database query...
        $this-&gt;amount = Transaction::monthToDate()-&gt;sum('amount');
    }

    public function render()
    {
        return view('livewire.revenue');
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    Revenue this month: {{ $amount }}
&lt;/div&gt;
</div></code></pre>
<p>Without lazy loading, this component would delay the loading of the entire page and make your entire application feel slow.</p>
<p>To enable lazy loading, you can pass the <code>lazy</code> parameter into the component:</p>
<pre class="hljs"><code><div>&lt;livewire:revenue lazy /&gt;
</div></code></pre>
<p>Now, instead of loading the component right away, Livewire will skip this component, loading the page without it. Then, when the component is visible in the viewport, Livewire will make a network request to fully load this component on the page.</p>
<blockquote>
<p>[!info] Lazy requests are isolated by default
Unlike other network requests in Livewire, lazy loading updates are isolated from each other when sent to the server. This keeps lazy loading fast, by loading each component in parrallel when a page loads. <a href="#disabling-request-isolation">Read more on disabling this behavior here →</a></p>
</blockquote>
<h2 id="rendering-placeholder-html">Rendering placeholder HTML</h2>
<p>By default, Livewire will insert an empty <code>&lt;div&gt;&lt;/div&gt;</code> for your component before it is fully loaded. As the component will initially be invisible to users, it can be jarring when the component suddenly appears on the page.</p>
<p>To signal to your users that the component is being loaded, you can define a <code>placeholder()</code> method to render any kind of placeholder HTML you like, including loading spinners and skeleton placeholders:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Transaction</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Revenue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $amount;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// Slow database query...</span>
        <span class="hljs-keyword">$this</span>-&gt;amount = Transaction::monthToDate()-&gt;sum(<span class="hljs-string">'amount'</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">placeholder</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&lt;&lt;&lt;'HTML'
        &lt;div&gt;
            &lt;!-- Loading spinner... --&gt;
            &lt;svg&gt;...&lt;/svg&gt;
        &lt;/div&gt;
        HTML;
    }

    public function render()
    {
        return view('livewire.revenue');
    }
}
</span></div></code></pre>
<p>Because the above component specifies a &quot;placeholder&quot; by returning HTML from a <code>placeholder()</code> method, the user will see an SVG loading spinner on the page until the component is fully loaded.</p>
<blockquote>
<p>[!warning] The placeholder and the component must share the same element type
For instance, if your placeholder's root element type is a 'div,' your component must also use a 'div' element.</p>
</blockquote>
<h3 id="rendering-a-placeholder-via-a-view">Rendering a placeholder via a view</h3>
<p>For more complex loaders (such as skeletons) you can return a <code>view</code> from the <code>placeholder()</code> similar to <code>render()</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">placeholder</span><span class="hljs-params">(array $params = [])</span>
</span>{
    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.placeholders.skeleton'</span>, $params);
}
</div></code></pre>
<p>Any parameters from the component being lazy loaded will be available as an <code>$params</code> argument passed to the <code>placeholder()</code> method.</p>
<h2 id="lazy-loading-outside-of-the-viewport">Lazy loading outside of the viewport</h2>
<p>By default, Lazy-loaded components aren't full loaded until they enter the browser's viewport, for example when a user scrolls to one.</p>
<p>If you'd rather lazy load all components on a page as soon as the page is loaded, without waiting for them to enter the viewport, you can do so by passing &quot;on-load&quot; into the <code>lazy</code> parameter:</p>
<pre class="hljs"><code><div>&lt;livewire:revenue lazy=&quot;on-load&quot; /&gt;
</div></code></pre>
<p>Now this component will load after the page is ready without waiting for it to be inside the viewport.</p>
<h2 id="passing-in-props">Passing in props</h2>
<p>In general, you can treat <code>lazy</code> components the same as normal components, since you can still pass data into them from outside.</p>
<p>For example, here's a scenario where you might pass a time interval into the <code>Revenue</code> component from a parent component:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;date&quot; wire:model=&quot;start&quot;&gt;
&lt;input type=&quot;date&quot; wire:model=&quot;end&quot;&gt;

&lt;livewire:revenue lazy :$start :$end /&gt;
</div></code></pre>
<p>You can accept this data in <code>mount()</code> just like any other component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Transaction</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Revenue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $amount;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($start, $end)</span>
    </span>{
        <span class="hljs-comment">// Expensive database query...</span>
        <span class="hljs-keyword">$this</span>-&gt;amount = Transactions::between($start, $end)-&gt;sum(<span class="hljs-string">'amount'</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">placeholder</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&lt;&lt;&lt;'HTML'
        &lt;div&gt;
            &lt;!-- Loading spinner... --&gt;
            &lt;svg&gt;...&lt;/svg&gt;
        &lt;/div&gt;
        HTML;
    }

    public function render()
    {
        return view('livewire.revenue');
    }
}
</span></div></code></pre>
<p>However, unlike a normal component load, a <code>lazy</code> component has to serialize or &quot;dehydrate&quot; any passed-in properties and temporarily store them on the client-side until the component is fully loaded.</p>
<p>For example, you might want to pass in an Eloquent model to the <code>Revenue</code> component like so:</p>
<pre class="hljs"><code><div>&lt;livewire:revenue lazy :$user /&gt;
</div></code></pre>
<p>In a normal component, the actual PHP in-memory <code>$user</code> model would be passed into the <code>mount()</code> method of <code>Revenue</code>. However, because we won't run <code>mount()</code> until the next network request, Livewire will internally serialize <code>$user</code> to JSON and then re-query it from the database before the next request is handled.</p>
<p>Typically, this serialization should not cause any behavioral differences in your application.</p>
<h2 id="lazy-load-by-default">Lazy load by default</h2>
<p>If you want to enforce that all usages of a component will be lazy-loaded, you can add the <code>#[Lazy]</code> attribute above the component class:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Lazy</span>;

<span class="hljs-comment">#[Lazy]</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Revenue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>If you want to override lazy loading you can set the <code>lazy</code> parameter to <code>false</code>:</p>
<pre class="hljs"><code><div>&lt;livewire:revenue :lazy=&quot;false&quot; /&gt;
</div></code></pre>
<h3 id="disabling-request-isolation">Disabling request isolation</h3>
<p>If there are multiple lazy-loaded components on the page, each component will make an independant network request, rather than each lazy update being bundled into a single request.</p>
<p>If you want to disabled this isolation behavior and instead bundle all updates together in a single network request you can do so with the <code>isolate: false</code> parameter:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Lazy</span>;

<span class="hljs-comment">#[Lazy(isolate: false)] // [tl! highlight]</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Revenue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now, if there are ten <code>Revenue</code> components on the same page, when the page loads, all ten updates will be bundled and sent the server as single network request.</p>
<h2 id="full-page-lazy-loading">Full-page lazy loading</h2>
<p>You may want to lazy load full-page Livewire components. You can do this by calling <code>-&gt;lazy()</code> on the route like so:</p>
<pre class="hljs"><code><div>Route::get(<span class="hljs-string">'/dashboard'</span>, \App\Livewire\Dashboard::class)-&gt;lazy();
</div></code></pre>
<p>Or alternatively, if there is a component that is lazy-loaded by default, and you would like to opt-out of lazy-loading, you can use the following <code>enabled: false</code> parameter:</p>
<pre class="hljs"><code><div>Route::get(<span class="hljs-string">'/dashboard'</span>, \App\Livewire\Dashboard::class)-&gt;lazy(enabled: <span class="hljs-keyword">false</span>);
</div></code></pre>
<h2 id="default-placeholder-view">Default placeholder view</h2>
<p>If you want to set a default placeholder view for all your components you can do so by referencing the view in the <code>/config/livewire.php</code> config file:</p>
<pre class="hljs"><code><div><span class="hljs-string">'lazy_placeholder'</span> =&gt; <span class="hljs-string">'livewire.placeholder'</span>,
</div></code></pre>
<p>Now, when a component is lazy-loaded and no <code>placeholder()</code> is defined, Livewire will use the configured Blade view (<code>livewire.placeholder</code> in this case.)</p>
<pre class="hljs"><code><div>
## File: lifecycle-hooks.md
```md
Livewire provides a variety of lifecycle hooks that allow you to execute code at specific points during a component's lifecycle. These hooks enable you to perform actions before or after particular events, such as initializing the component, updating properties, or rendering the template.

Here's a list of all the available component lifecycle hooks:

| Hook Method      | Description                                                                     |
|------------------|---------------------------------------------------------------------------------|
| `mount()`        | Called when a component is created                                              |
| `hydrate()`      | Called when a component is re-hydrated at the beginning of a subsequent request |
| `boot()`         | Called at the beginning of every request. Both initial, and subsequent          |
| `updating()`     | Called before updating a component property                                     |
| `updated()`      | Called after updating a property                                                |
| `rendering()`    | Called before `render()` is called                                              |
| `rendered()`     | Called after `render()` is called                                               |
| `dehydrate()`    | Called at the end of every component request                                    |

## Mount

In a standard PHP class, a constructor (`__construct()`) takes in outside parameters and initializes the object's state. However, in Livewire, you use the `mount()` method for accepting parameters and initializing the state of your component.

Livewire components don't use `__construct()` because Livewire components are _re-constructed_ on subsequent network requests, and we only want to initialize the component once when it is first created.

Here's an example of using the `mount()` method to initialize the `name` and `email` properties of an `UpdateProfile` component:

```php
use Illuminate\Support\Facades\Auth;
use Livewire\Component;

class UpdateProfile extends Component
{
    public $name;

    public $email;

    public function mount()
    {
        $this-&gt;name = Auth::user()-&gt;name;

        $this-&gt;email = Auth::user()-&gt;email;
    }

    // ...
}
</div></code></pre>
<p>As mentioned earlier, the <code>mount()</code> method receives data passed into the component as method parameters:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $title;

    <span class="hljs-keyword">public</span> $content;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;title = $post-&gt;title;

        <span class="hljs-keyword">$this</span>-&gt;content = $post-&gt;content;
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<blockquote>
<p>[!tip] You can use dependency injection with all hook methods
Livewire allows you to resolve dependencies out of <a href="https://laravel.com/docs/container#automatic-injection">Laravel's service container</a> by type-hinting method parameters on lifecycle hooks.</p>
</blockquote>
<p>The <code>mount()</code> method is a crucial part of using Livewire. The following documentation provides further examples of using the <code>mount()</code> method to accomplish common tasks:</p>
<ul>
<li><a href="/docs/properties#initializing-properties">Initializing properties</a></li>
<li><a href="/docs/nesting#passing-props-to-children">Receiving data from parent components</a></li>
<li><a href="/docs/components#accessing-route-parameters">Accessing route parameters</a></li>
</ul>
<h2 id="boot">Boot</h2>
<p>As helpful as <code>mount()</code> is, it only runs once per component lifecycle, and you may want to run logic at the beginning of every single request to the server for a given component.</p>
<p>For these cases, Livewire provides a <code>boot()</code> method where you can write component setup code that you intend to run every single time the component class is booted: both on initialization and on subsequent requests.</p>
<p>The <code>boot()</code> method can be useful for things like initializing protected properties, which are not persisted between requests. Below is an example of initializing a protected property as an Eloquent model:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Locked</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Locked]</span>
    <span class="hljs-keyword">public</span> $postId = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">protected</span> Post $post;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boot</span><span class="hljs-params">()</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:3]
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = Post::find(<span class="hljs-keyword">$this</span>-&gt;postId);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>You can use this technique to have complete control over initializing a component property in your Livewire component.</p>
<blockquote>
<p>[!tip] Most of the time, you can use a computed property instead
The technique used above is powerful; however, it's often better to use <a href="/docs/computed-properties">Livewire's computed properties</a> to solve this use case.</p>
</blockquote>
<blockquote>
<p>[!warning] Always lock sensitive public properties
As you can see above, we are using the <code>#[Locked]</code> attribute on the <code>$postId</code> property. In a scenario like the above, where you want to ensure the <code>$postId</code> property isn't tampered with by users on the client-side, it's important to authorize the property's value before using it or add <code>#[Locked]</code> to the property ensure it is never changed.</p>
<p>For more information, check out the <a href="/docs/locked">documentation on Locked properties</a>.</p>
</blockquote>
<h2 id="update">Update</h2>
<p>Client-side users can update public properties in many different ways, most commonly by modifying an input with <code>wire:model</code> on it.</p>
<p>Livewire provides convenient hooks to intercept the updating of a public property so that you can validate or authorize a value before it's set, or ensure a property is set in a given format.</p>
<p>Below is an example of using <code>updating</code> to prevent the modification of the <code>$postId</code> property.</p>
<p>It's worth noting that for this particular example, in an actual application, you should use the <a href="/docs/locked"><code>#[Locked]</code> attribute</a> instead, like in the above example.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Exception</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $postId = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updating</span><span class="hljs-params">($property, $value)</span>
    </span>{
        <span class="hljs-comment">// $property: The name of the current property being updated</span>
        <span class="hljs-comment">// $value: The value about to be set to the property</span>

        <span class="hljs-keyword">if</span> ($property === <span class="hljs-string">'postId'</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">Exception</span>;
        }
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>The above <code>updating()</code> method runs before the property is updated, allowing you to catch invalid input and prevent the property from updating. Below is an example of using <code>updated()</code> to ensure a property's value stays consistent:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $username = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $email = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updated</span><span class="hljs-params">($property)</span>
    </span>{
        <span class="hljs-comment">// $property: The name of the current property that was updated</span>

        <span class="hljs-keyword">if</span> ($property === <span class="hljs-string">'username'</span>) {
            <span class="hljs-keyword">$this</span>-&gt;username = strtolower(<span class="hljs-keyword">$this</span>-&gt;username);
        }
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now, anytime the <code>$username</code> property is updated client-side, we will ensure that the value will always be lowercase.</p>
<p>Because you are often targeting a specific property when using update hooks, Livewire allows you to specify the property name directly as part of the method name. Here's the same example from above but rewritten utilizing this technique:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $username = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $email = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatedUsername</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;username = strtolower(<span class="hljs-keyword">$this</span>-&gt;username);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Of course, you can also apply this technique to the <code>updating</code> hook.</p>
<h3 id="arrays">Arrays</h3>
<p>Array properties have an additional <code>$key</code> argument passed to these functions to specify the changing element.</p>
<p>Note that when the array itself is updated instead of a specific key, the <code>$key</code> argument is null.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePreferences</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $preferences = [];

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatedPreferences</span><span class="hljs-params">($value, $key)</span>
    </span>{
        <span class="hljs-comment">// $value = 'dark'</span>
        <span class="hljs-comment">// $key   = 'theme'</span>
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h2 id="hydrate--dehydrate">Hydrate &amp; Dehydrate</h2>
<p>Hydrate and dehydrate are lesser-known and lesser-utilized hooks. However, there are specific scenarios where they can be powerful.</p>
<p>The terms &quot;dehydrate&quot; and &quot;hydrate&quot; refer to a Livewire component being serialized to JSON for the client-side and then unserialized back into a PHP object on the subsequent request.</p>
<p>We often use the terms &quot;hydrate&quot; and &quot;dehydrate&quot; to refer to this process throughout Livewire's codebase and the documentation. If you'd like more clarity on these terms, you can learn more by <a href="/docs/hydration">consulting our hydration documentation</a>.</p>
<p>Let's look at an example that uses both <code>mount()</code> , <code>hydrate()</code>, and <code>dehydrate()</code> all together to support using a custom <a href="https://en.wikipedia.org/wiki/Data_transfer_object">data transfer object (DTO)</a> instead of an Eloquent model to store the post data in the component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $post;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($title, $content)</span>
    </span>{
        <span class="hljs-comment">// Runs at the beginning of the first initial request...</span>

        <span class="hljs-keyword">$this</span>-&gt;post = <span class="hljs-keyword">new</span> PostDto([
            <span class="hljs-string">'title'</span> =&gt; $title,
            <span class="hljs-string">'content'</span> =&gt; $content,
        ]);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hydrate</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// Runs at the beginning of every "subsequent" request...</span>
        <span class="hljs-comment">// This doesn't run on the initial request ("mount" does)...</span>

        <span class="hljs-keyword">$this</span>-&gt;post = <span class="hljs-keyword">new</span> PostDto(<span class="hljs-keyword">$this</span>-&gt;post);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dehydrate</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// Runs at the end of every single request...</span>

        <span class="hljs-keyword">$this</span>-&gt;post = <span class="hljs-keyword">$this</span>-&gt;post-&gt;toArray();
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now, from actions and other places inside your component, you can access the <code>PostDto</code> object instead of the primitive data.</p>
<p>The above example mainly demonstrates the abilities and nature of the <code>hydrate()</code> and <code>dehydrate()</code> hooks. However, it is recommended that you use <a href="/docs/properties#supporting-custom-types">Wireables or Synthesizers</a> to accomplish this instead.</p>
<h2 id="render">Render</h2>
<p>If you want to hook into the process of rendering a component's Blade view, you can do so using the <code>rendering()</code> and <code>rendered()</code> hooks:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-posts'</span>, [
            <span class="hljs-string">'post'</span> =&gt; Post::all(),
        ])
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rendering</span><span class="hljs-params">($view, $data)</span>
    </span>{
        <span class="hljs-comment">// Runs BEFORE the provided view is rendered...</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// $view: The view about to be rendered</span>
        <span class="hljs-comment">// $data: The data provided to the view</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rendered</span><span class="hljs-params">($view, $html)</span>
    </span>{
        <span class="hljs-comment">// Runs AFTER the provided view is rendered...</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// $view: The rendered view</span>
        <span class="hljs-comment">// $html: The final, rendered HTML</span>
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h2 id="using-hooks-inside-a-trait">Using hooks inside a trait</h2>
<p>Traits are a helpful way to reuse code across components or extract code from a single component into a dedicated file.</p>
<p>To avoid multiple traits conflicting with each other when declaring lifecycle hook methods, Livewire supports prefixing hook methods with the <em>camelCased</em> name of the current trait declaring them.</p>
<p>This way, you can have multiple traits using the same lifecycle hooks and avoid conflicting method definitions.</p>
<p>Below is an example of a component referencing a trait called <code>HasPostForm</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">HasPostForm</span>;

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now here's the actual <code>HasPostForm</code> trait containing all the available prefixed hooks:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">trait</span> HasPostForm
{
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountHasPostForm</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hydrateHasPostForm</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootHasPostForm</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatingHasPostForm</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatedHasPostForm</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderingHasPostForm</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderedHasPostForm</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dehydrateHasPostForm</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<pre class="hljs"><code><div>
## File: loading.md
```md
Loading indicators are an important part of crafting good user interfaces. They give users visual feedback when a request is being made to the server, so they know they are waiting for a process to complete.

## Basic usage

Livewire provides a simple yet extremely powerful syntax for controlling loading indicators: `wire:loading`. Adding `wire:loading` to any element will hide it by default (using `display: none` in CSS) and show it when a request is sent to the server.

Below is a basic example of a `CreatePost` component's form with `wire:loading` being used to toggle a loading message:

```blade
&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;!-- ... --&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;

    &lt;div wire:loading&gt; &lt;!-- [tl! highlight:2] --&gt;
        Saving post...
    &lt;/div&gt;
&lt;/form&gt;
</div></code></pre>
<p>When a user presses &quot;Save&quot;, the &quot;Saving post...&quot; message will appear below the button while the &quot;save&quot; action is being executed. The message will disappear when the response is received from the server and processed by Livewire.</p>
<h3 id="removing-elements">Removing elements</h3>
<p>Alternatively, you can append <code>.remove</code> for the inverse effect, showing an element by default and hiding it during requests to the server:</p>
<pre class="hljs"><code><div>&lt;div wire:loading.remove&gt;...&lt;/div&gt;
</div></code></pre>
<h2 id="toggling-classes">Toggling classes</h2>
<p>In addition to toggling the visibility of entire elements, it's often useful to change the styling of an existing element by toggling CSS classes on and off during requests to the server. This technique can be used for things like changing background colors, lowering opacity, triggering spinning animations, and more.</p>
<p>Below is a simple example of using the <a href="https://tailwindcss.com/">Tailwind</a> class <code>opacity-50</code> to make the &quot;Save&quot; button fainter while the form is being submitted:</p>
<pre class="hljs"><code><div>&lt;button wire:loading.class=&quot;opacity-50&quot;&gt;Save&lt;/button&gt;
</div></code></pre>
<p>Like toggling an element, you can perform the inverse class operation by appending <code>.remove</code> to the <code>wire:loading</code> directive. In the example below, the button's <code>bg-blue-500</code> class will be removed when the &quot;Save&quot; button is pressed:</p>
<pre class="hljs"><code><div>&lt;button class=&quot;bg-blue-500&quot; wire:loading.class.remove=&quot;bg-blue-500&quot;&gt;
    Save
&lt;/button&gt;
</div></code></pre>
<h2 id="toggling-attributes">Toggling attributes</h2>
<p>By default, when a form is submitted, Livewire will automatically disable the submit button and add the <code>readonly</code> attribute to each input element while the form is being processed.</p>
<p>However, in addition to this default behavior, Livewire offers the <code>.attr</code> modifier to allow you to toggle other attributes on an element or toggle attributes on elements that are outside of forms:</p>
<pre class="hljs"><code><div>&lt;button
    type=&quot;button&quot;
    wire:click=&quot;remove&quot;
    wire:loading.attr=&quot;disabled&quot;
&gt;
    Remove
&lt;/button&gt;
</div></code></pre>
<p>Because the button above isn't a submit button, it won't be disabled by Livewire's default form handling behavior when pressed. Instead, we manually added <code>wire:loading.attr=&quot;disabled&quot;</code> to achieve this behavior.</p>
<h2 id="targeting-specific-actions">Targeting specific actions</h2>
<p>By default, <code>wire:loading</code> will be triggered whenever a component makes a request to the server.</p>
<p>However, in components with multiple elements that can trigger server requests, you should scope your loading indicators down to individual actions.</p>
<p>For example, consider the following &quot;Save post&quot; form. In addition to a &quot;Save&quot; button that submits the form, there might also be a &quot;Remove&quot; button that executes a &quot;remove&quot; action on the component.</p>
<p>By adding <code>wire:target</code> to the following <code>wire:loading</code> element, you can instruct Livewire to only show the loading message when the &quot;Remove&quot; button is clicked:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;!-- ... --&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;

    &lt;button type=&quot;button&quot; wire:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;

    &lt;div wire:loading wire:target=&quot;remove&quot;&gt;  &lt;!-- [tl! highlight:2] --&gt;
        Removing post...
    &lt;/div&gt;
&lt;/form&gt;
</div></code></pre>
<p>When the above &quot;Remove&quot; button is pressed, the &quot;Removing post...&quot; message will be displayed to the user. However, the message will not be displayed when the &quot;Save&quot; button is pressed.</p>
<h3 id="targeting-action-parameters">Targeting action parameters</h3>
<p>In situations where the same action is triggered with different parameters from multiple places on a page, you can further scope <code>wire:target</code> to a specific action by passing in additional parameters. For example, consider the following scenario where a &quot;Remove&quot; button exists for each post on the page:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;div wire:key=&quot;{{ $post-&gt;id }}&quot;&gt;
            &lt;h2&gt;{{ $post-&gt;title }}&lt;/h2&gt;

            &lt;button wire:click=&quot;remove({{ $post-&gt;id }})&quot;&gt;Remove&lt;/button&gt;

            &lt;div wire:loading wire:target=&quot;remove({{ $post-&gt;id }})&quot;&gt;  &lt;!-- [tl! highlight:2] --&gt;
                Removing post...
            &lt;/div&gt;
        &lt;/div&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>Without passing <code>{{ $post-&gt;id }}</code> to <code>wire:target=&quot;remove&quot;</code>, the &quot;Removing post...&quot; message would show when any of the buttons on the page are clicked.</p>
<p>However, because we are passing in unique parameters to each instance of <code>wire:target</code>, Livewire will only show the loading message when the matching parameters are passed to the &quot;remove&quot; action.</p>
<h3 id="targeting-property-updates">Targeting property updates</h3>
<p>Livewire also allows you to target specific component property updates by passing the property's name to the <code>wire:target</code> directive.</p>
<p>Consider the following example where a form input named <code>username</code> uses <code>wire:model.live</code> for real-time validation as a user types:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model.live=&quot;username&quot;&gt;
    @error('username') &lt;span&gt;{{ $message }}&lt;/span&gt; @enderror

    &lt;div wire:loading wire:target=&quot;username&quot;&gt; &lt;!-- [tl! highlight:2] --&gt;
        Checking availability of username...
    &lt;/div&gt;

    &lt;!-- ... --&gt;
&lt;/form&gt;
</div></code></pre>
<p>The &quot;Checking availability...&quot; message will show when the server is updated with the new username as the user types into the input field.</p>
<h2 id="customizing-css-display-property">Customizing CSS display property</h2>
<p>When <code>wire:loading</code> is added to an element, Livewire updates the CSS <code>display</code> property of the element to show and hide the element. By default, Livewire uses <code>none</code> to hide and <code>inline-block</code> to show.</p>
<p>If you are toggling an element that uses a display value other than <code>inline-block</code>, like <code>flex</code> in the following example, you can append <code>.flex</code> to <code>wire:loading</code>:</p>
<pre class="hljs"><code><div>&lt;div class=&quot;flex&quot; wire:loading.flex&gt;...&lt;/div&gt;
</div></code></pre>
<p>Below is the complete list of available display values:</p>
<pre class="hljs"><code><div>&lt;div wire:loading.inline-flex&gt;...&lt;/div&gt;
&lt;div wire:loading.inline&gt;...&lt;/div&gt;
&lt;div wire:loading.block&gt;...&lt;/div&gt;
&lt;div wire:loading.table&gt;...&lt;/div&gt;
&lt;div wire:loading.flex&gt;...&lt;/div&gt;
&lt;div wire:loading.grid&gt;...&lt;/div&gt;
</div></code></pre>
<h2 id="delaying-a-loading-indicator">Delaying a loading indicator</h2>
<p>On fast connections, updates often happen so quickly that loading indicators only flash briefly on the screen before being removed. In these cases, the indicator is more of a distraction than a helpful affordance.</p>
<p>For this reason, Livewire provides a <code>.delay</code> modifier to delay the showing of an indicator. For example, if you add <code>wire:loading.delay</code> to an element like so:</p>
<pre class="hljs"><code><div>&lt;div wire:loading.delay&gt;...&lt;/div&gt;
</div></code></pre>
<p>The above element will only appear if the request takes over 200 milliseconds. The user will never see the indicator if the request completes before then.</p>
<p>To customize the amount of time to delay the loading indicator, you can use one of Livewire's helpful interval aliases:</p>
<pre class="hljs"><code><div>&lt;div wire:loading.delay.none&gt;...&lt;/div&gt;     &lt;!-- 0ms --&gt;
&lt;div wire:loading.delay.shortest&gt;...&lt;/div&gt; &lt;!-- 50ms --&gt;
&lt;div wire:loading.delay.shorter&gt;...&lt;/div&gt;  &lt;!-- 100ms --&gt;
&lt;div wire:loading.delay.short&gt;...&lt;/div&gt;    &lt;!-- 150ms --&gt;
&lt;div wire:loading.delay&gt;...&lt;/div&gt;          &lt;!-- 200ms --&gt;
&lt;div wire:loading.delay.default&gt;...&lt;/div&gt;  &lt;!-- 200ms --&gt;
&lt;div wire:loading.delay.long&gt;...&lt;/div&gt;     &lt;!-- 300ms --&gt;
&lt;div wire:loading.delay.longer&gt;...&lt;/div&gt;   &lt;!-- 500ms --&gt;
&lt;div wire:loading.delay.longest&gt;...&lt;/div&gt;  &lt;!-- 1000ms --&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: locked.md
```md
Livewire properties are able to be modified freely on both the frontend and backend using utilities like `wire:model`. If you want to prevent a property — like a model ID — from being modified on the frontend, you can use Livewire's `#[Locked]` attribute.

## Basic usage

Below is a `ShowPost` component that stores a `Post` model's ID as a public property named `$id`. To keep this property from being modified by a curious or malicious user, you can add the `#[Locked]` attribute to the property:

&gt; [!warning] Make sure you import attribute classes
&gt; Make sure you import any attribute classes. For example, the below `#[Locked]` attribute requires the following import `use Livewire\Attributes\Locked;`.

```php
use Livewire\Attributes\Locked;
use Livewire\Component;

class ShowPost extends Component
{
	#[Locked] // [tl! highlight]
    public $id;

    public function mount($postId)
    {
        $this-&gt;id = $postId;
    }

	// ...
}
</div></code></pre>
<p>By adding the <code>#[Locked]</code> attribute, you are ensured that the <code>$id</code> property will never be tampered with.</p>
<blockquote>
<p>[!tip] Model properties are secure by default
If you store an Eloquent model in a public property instead of just the model's ID, Livewire will ensure the ID isn't tampered with, without you needing to explicitly add the <code>#[Locked]</code> attribute to the property. For most cases, this is a better approach than using <code>#[Locked]</code>:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
   <span class="hljs-keyword">public</span> Post $post; <span class="hljs-comment">// [tl! highlight]</span>

   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($postId)</span>
   </span>{
       <span class="hljs-keyword">$this</span>-&gt;post = Post::find($postId);
   }

	<span class="hljs-comment">// ...</span>
}
</div></code></pre>
</blockquote>
<h3 id="why-not-use-protected-properties">Why not use protected properties?</h3>
<p>You might ask yourself: why not just use protected properties for sensitive data?</p>
<p>Remember, Livewire only persists public properties between network requests. For static, hard-coded data, protected properties are suitable. However, for data that is stored at runtime, you must use a public property to ensure that the data is persisted properly.</p>
<h3 id="cant-livewire-do-this-automatically">Can't Livewire do this automatically?</h3>
<p>In a perfect world, Livewire would lock properties by default, and only allow modifications when <code>wire:model</code> is used on that property.</p>
<p>Unfortunately, that would require Livewire to parse all of your Blade templates to understand if a property is modified by <code>wire:model</code> or a similar API.</p>
<p>Not only would that add technical and performance overhead, it would be impossible to detect if a property is mutated by something like Alpine or any other custom JavaScript.</p>
<p>Therefore, Livewire will continue to make public properties freely mutable by default and give developers the tools to lock them as needed.</p>
<pre class="hljs"><code><div>
## File: morph.md
```md

When a Livewire component updates the browser's DOM, it does so in an intelligent way we call &quot;morphing&quot;. The term _morph_ is in contrast with a word like _replace_.

Instead of _replacing_ a component's HTML with newly rendered HTML every time a component is updated, Livewire dynamically compares the current HTML with the new HTML, identifies differences, and makes surgical changes to the HTML only in the places where changes are needed.

This has the benefit of preserving existing, un-changed elements on a component. For example, event listeners, focus state, and form input values are all preserved between Livewire updates. Of course, morphing also offers increased performance compared to wiping and re-rending new DOM on every update.

## How morphing works

To understand how Livewire determines which elements to update between Livewire requests, consider this simple `Todos` component:

```php
class Todos extends Component
{
    public $todo = '';

    public $todos = [
        'first',
        'second',
    ];

    public function add()
    {
        $this-&gt;todos[] = $this-&gt;todo;
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;add&quot;&gt;
    &lt;ul&gt;
        @foreach ($todos as $item)
            &lt;li&gt;{{ $item }}&lt;/li&gt;
        @endforeach
    &lt;/ul&gt;

    &lt;input wire:model=&quot;todo&quot;&gt;
&lt;/form&gt;
</div></code></pre>
<p>The initial render of this component will output the following HTML:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">wire:submit</span>=<span class="hljs-string">"add"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>first<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>second<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"todo"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>Now, imagine you typed &quot;third&quot; into the input field and pressed the <code>[Enter]</code> key. The newly rendered HTML would be:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">wire:submit</span>=<span class="hljs-string">"add"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>first<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>second<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>third<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! add] --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"todo"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>When Livewire processes the component update, it <em>morphs</em> the original DOM into the newly rendered HTML. The following visualization should intuitively give you an understanding of how it works:</p>
<div style="padding:56.25% 0 0 0;position:relative;"><iframe src="https://player.vimeo.com/video/844600772?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen style="position:absolute;top:0;left:0;width:100%;height:100%;" title="morph_basic"></iframe></div><script src="https://player.vimeo.com/api/player.js"></script>
<p>As you can see, Livewire walks both HTML trees simultaneously. As it encounters each element in both trees, it compares them for changes, additions, and removals. If it detects one, it surgically makes the appropriate change.</p>
<h2 id="morphing-shortcomings">Morphing shortcomings</h2>
<p>The following are scenarios where morphing algorithms fail to correctly identify the change in HTML trees and therefore cause problems in your application.</p>
<h3 id="inserting-intermediate-elements">Inserting intermediate elements</h3>
<p>Consider the following Livewire Blade template for a fictitious <code>CreatePost</code> component:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;div&gt;
        &lt;input wire:model=&quot;title&quot;&gt;
    &lt;/div&gt;

    @if ($errors-&gt;has('title'))
        &lt;div&gt;{{ $errors-&gt;first('title') }}&lt;/div&gt;
    @endif

    &lt;div&gt;
        &lt;button&gt;Save&lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;
</div></code></pre>
<p>If a user tries submitting the form, but encounters a validation error, the following problem occurs:</p>
<div style="padding:56.25% 0 0 0;position:relative;"><iframe src="https://player.vimeo.com/video/844600840?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen style="position:absolute;top:0;left:0;width:100%;height:100%;" title="morph_problem"></iframe></div><script src="https://player.vimeo.com/api/player.js"></script>
<p>As you can see, when Livewire encounters the new <code>&lt;div&gt;</code> for the error message, it doesn't know whether to change the existing <code>&lt;div&gt;</code> in-place, or insert the new <code>&lt;div&gt;</code> in the middle.</p>
<p>To re-iterate what's happening more explicitly:</p>
<ul>
<li>Livewire encounters the first <code>&lt;div&gt;</code> in both trees. They are the same, so it continues.</li>
<li>Livewire encounters the second <code>&lt;div&gt;</code> in both trees and thinks they are the same <code>&lt;div&gt;</code>, just one has changed contents. So instead of inserting the error message as a new element, it changes the <code>&lt;button&gt;</code> into an error message.</li>
<li>Livewire then, after mistakenly modifying the previous element, notices an additional element at the end of the comparison. It then creates and appends the element after the previous one.</li>
<li>Therefore, destroying, then re-creating an element that otherwise should have been simply moved.</li>
</ul>
<p>This scenario is at the root of almost all morph-related bugs.</p>
<p>Here are a few specific problematic impacts of these bugs:</p>
<ul>
<li>Event listeners and element state are lost between updates</li>
<li>Event listeners and state are misplaced across the wrong elements</li>
<li>Entire Livewire components can be reset or duplicated as Livewire components are also simply elements in the DOM tree</li>
<li>Alpine components and state can be lost or misplaced</li>
</ul>
<p>Fortunately, Livewire has worked hard to mitigate these problems using the following approaches:</p>
<h3 id="internal-look-ahead">Internal look-ahead</h3>
<p>Livewire has an additional step in its morphing algorithm that checks subsequent elements and their contents before changing an element.</p>
<p>This prevents the above scenario from happening in many cases.</p>
<p>Here is a visualization of the &quot;look-ahead&quot; algorithm in action:</p>
<div style="padding:56.25% 0 0 0;position:relative;"><iframe src="https://player.vimeo.com/video/844600800?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen style="position:absolute;top:0;left:0;width:100%;height:100%;" title="morph_lookahead"></iframe></div><script src="https://player.vimeo.com/api/player.js"></script>
<h3 id="injecting-morph-markers">Injecting morph markers</h3>
<p>On the backend, Livewire automatically detects conditionals inside Blade templates and wraps them in HTML comment markers that Livewire's JavaScript can use as a guide when morphing.</p>
<p>Here's an example of the previous Blade template but with Livewire's injected markers:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;div&gt;
        &lt;input wire:model=&quot;title&quot;&gt;
    &lt;/div&gt;

    &lt;!--[if BLOCK]&gt;&lt;![endif]--&gt; &lt;!-- [tl! highlight] --&gt;
    @if ($errors-&gt;has('title'))
        &lt;div&gt;Error: {{ $errors-&gt;first('title') }}&lt;/div&gt;
    @endif
    &lt;!--[if ENDBLOCK]&gt;&lt;![endif]--&gt; &lt;!-- [tl! highlight] --&gt;

    &lt;div&gt;
        &lt;button&gt;Save&lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;
</div></code></pre>
<p>With these markers injected into the template, Livewire can now more easily detect the difference between a change and an addition.</p>
<p>This feature is extremely beneficial to Livewire applications, but because it requires parsing templates via regex, it can sometimes fail to properly detect conditionals. If this feature is more of a hindrance than a help to your application, you can disable it with the following configuration in your application's <code>config/livewire.php</code> file:</p>
<pre class="hljs"><code><div><span class="hljs-string">'inject_morph_markers'</span> =&gt; <span class="hljs-keyword">false</span>,
</div></code></pre>
<h4 id="wrapping-conditionals">Wrapping conditionals</h4>
<p>If the above two solutions don't cover your situation, the most reliable way to avoid morphing problems is to wrap conditionals and loops in their own elements that are always present.</p>
<p>For example, here's the above Blade template rewritten with wrapping <code>&lt;div&gt;</code> elements:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;div&gt;
        &lt;input wire:model=&quot;title&quot;&gt;
    &lt;/div&gt;

    &lt;div&gt; &lt;!-- [tl! highlight] --&gt;
        @if ($errors-&gt;has('title'))
            &lt;div&gt;{{ $errors-&gt;first('title') }}&lt;/div&gt;
        @endif
    &lt;/div&gt; &lt;!-- [tl! highlight] --&gt;

    &lt;div&gt;
        &lt;button&gt;Save&lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;
</div></code></pre>
<p>Now that the conditional has been wrapped in a persistent element, Livewire will morph the two different HTML trees properly.</p>
<pre class="hljs"><code><div>
## File: navigate.md
```md

Many modern web applications are built as &quot;single page applications&quot; (SPAs). In these applications, each page rendered by the application no longer requires a full browser page reload, avoiding the overhead of re-downloading JavaScript and CSS assets on every request.

The alternative to a *single page application* is a *multi-page application*. In these applications, every time a user clicks a link, an entirely new HTML page is requested and rendered in the browser.

While most PHP applications have traditionally been multi-page applications, Livewire offers a single page application experience via a simple attribute you can add to links in your application: `wire:navigate`.

## Basic usage

Let's explore an example of using `wire:navigate`. Below is a typical Laravel routes file (`routes/web.php`) with three Livewire components defined as routes:

```php
use App\Livewire\Dashboard;
use App\Livewire\ShowPosts;
use App\Livewire\ShowUsers;

Route::get('/', Dashboard::class);

Route::get('/posts', ShowPosts::class);

Route::get('/users', ShowUsers::class);
</div></code></pre>
<p>By adding <code>wire:navigate</code> to each link in a navigation menu on each page, Livewire will prevent the standard handling of the link click and replace it with its own, faster version:</p>
<pre class="hljs"><code><div>&lt;nav&gt;
    &lt;a href=&quot;/&quot; wire:navigate&gt;Dashboard&lt;/a&gt;
    &lt;a href=&quot;/posts&quot; wire:navigate&gt;Posts&lt;/a&gt;
    &lt;a href=&quot;/users&quot; wire:navigate&gt;Users&lt;/a&gt;
&lt;/nav&gt;
</div></code></pre>
<p>Below is a breakdown of what happens when a <code>wire:navigate</code> link is clicked:</p>
<ul>
<li>User clicks a link</li>
<li>Livewire prevents the browser from visiting the new page</li>
<li>Instead, Livewire requests the page in the background and shows a loading bar at the top of the page</li>
<li>When the HTML for the new page has been received, Livewire replaces the current page's URL, <code>&lt;title&gt;</code> tag and <code>&lt;body&gt;</code> contents with the elements from the new page</li>
</ul>
<p>This technique results in much faster page load times — often twice as fast — and makes the application &quot;feel&quot; like a JavaScript powered single page application.</p>
<h2 id="redirects">Redirects</h2>
<p>When one of your Livewire components redirects users to another URL within your application, you can also instruct Livewire to use its <code>wire:navigate</code> functionality to load the new page. To accomplish this, provide the <code>navigate</code> argument to the <code>redirect()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;redirect(<span class="hljs-string">'/posts'</span>, navigate: <span class="hljs-keyword">true</span>);
</div></code></pre>
<p>Now, instead of a full page request being used to redirect the user to the new URL, Livewire will replace the contents and URL of the current page with the new one.</p>
<h2 id="prefetching-links">Prefetching links</h2>
<p>By default, Livewire includes a gentle strategy to <em>prefetch</em> pages before a user clicks on a link:</p>
<ul>
<li>A user presses down on their mouse button</li>
<li>Livewire starts requesting the page</li>
<li>They lift up on the mouse button to complete the <em>click</em></li>
<li>Livewire finishes the request and navigates to the new page</li>
</ul>
<p>Surprisingly, the time between a user pressing down and lifting up on the mouse button is often enough time to load half or even an entire page from the server.</p>
<p>If you want an even more aggressive approach to prefetching, you may use the <code>.hover</code> modifier on a link:</p>
<pre class="hljs"><code><div>&lt;a href=&quot;/posts&quot; wire:navigate.hover&gt;Posts&lt;/a&gt;
</div></code></pre>
<p>The <code>.hover</code> modifier will instruct Livewire to prefetch the page after a user has hovered over the link for <code>60</code> milliseconds.</p>
<blockquote>
<p>[!warning] Prefetching on hover increases server usage
Because not all users will click a link they hover over, adding <code>.hover</code> will request pages that may not be needed, though Livewire attempts to mitigate some of this overhead by waiting <code>60</code> milliseconds before prefetching the page.</p>
</blockquote>
<h2 id="persisting-elements-across-page-visits">Persisting elements across page visits</h2>
<p>Sometimes, there are parts of a user interface that you need to persist between page loads, such as audio or video players. For example, in a podcasting application, a user may want to keep listening to an episode as they browse other pages.</p>
<p>You can achieve this in Livewire with the <code>@persist</code> directive.</p>
<p>By wrapping an element with <code>@persist</code> and providing it with a name, when a new page is requested using <code>wire:navigate</code>, Livewire will look for an element on the new page that has a matching <code>@persist</code>. Instead of replacing the element like normal, Livewire will use the existing DOM element from the previous page in the new page, preserving any state within the element.</p>
<p>Here is an example of an <code>&lt;audio&gt;</code> player element being persisted across pages using <code>@persist</code>:</p>
<pre class="hljs"><code><div>@persist('player')
    &lt;audio src=&quot;{{ $episode-&gt;file }}&quot; controls&gt;&lt;/audio&gt;
@endpersist
</div></code></pre>
<p>If the above HTML appears on both pages — the current page, and the next one — the original element will be re-used on the new page. In the case of an audio player, the audio playback won't be interrupted when navigating from one page to another.</p>
<p>Please be aware that the persisted element must be placed outside your Livewire components. A common practice is to position the persisted element in your main layout, such as <code>resources/views/components/layouts/app.blade.php</code>.</p>
<pre class="hljs"><code><div><span class="hljs-comment">&lt;!-- resources/views/components/layouts/app.blade.php --&gt;</span>

<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"{{ str_replace('_', '-', app()-&gt;getLocale()) }}"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>{{ $title ?? 'Page Title' }}<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
            {{ $slot }}
        <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>

        @persist('player') <span class="hljs-comment">&lt;!-- [tl! highlight:2] --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"{{ $episode-&gt;file }}"</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span>
        @endpersist
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h3 id="preserving-scroll-position">Preserving scroll position</h3>
<p>By default, Livewire will preserve the scroll position of a page when navigating back and forth between pages. However, sometimes you may want to preserve the scroll position of an individual element you are persisting between page loads.</p>
<p>To do this, you must add <code>wire:scroll</code> to the element containing a scrollbar like so:</p>
<pre class="hljs"><code><div>@persist('scrollbar')
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"overflow-y-scroll"</span> <span class="hljs-attr">wire:scroll</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! highlight] --&gt;</span>
    <span class="hljs-comment">&lt;!-- ... --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
@endpersist
</div></code></pre>
<h2 id="javascript-hooks">JavaScript hooks</h2>
<p>Livewire dispatches a useful event called <code>livewire:navigating</code> that allows you to execute JavaScript immediately BEFORE the current page is navigated away from.</p>
<p>This is useful for scenarios like modifying the contents of the current page before it is stored and reloaded as the back-button cache HTML.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:navigating'</span>, () =&gt; {
    <span class="hljs-comment">// Mutate the HTML before the page is navigated away...</span>
})
</div></code></pre>
<p>Alternatively, you can hook into AFTER Livewire has navigated to a page using <code>livewire:navigated</code>. This event will dispatch after every navigation including back and forward button presses:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:navigated'</span>, () =&gt; {
    <span class="hljs-comment">//</span>
})
</div></code></pre>
<h2 id="manually-visiting-a-new-page">Manually visiting a new page</h2>
<p>In addition to <code>wire:navigate</code>, you can manually call the <code>Livewire.navigate()</code> method to trigger a visit to a new page using JavaScript:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
    <span class="hljs-comment">// ...</span>

    Livewire.navigate(<span class="hljs-string">'/new/url'</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<h2 id="using-with-analytics-software">Using with analytics software</h2>
<p>When navigating pages using <code>wire:navigate</code> in your app, any <code>&lt;script&gt;</code> tags in the <code>&lt;head&gt;</code> only evaluate when the page is initially loaded.</p>
<p>This creates a problem for analytics software such as <a href="https://usefathom.com/">Fathom Analytics</a>. These tools rely on a <code>&lt;script&gt;</code> snippet being evaluated on every single page change, not just the first.</p>
<p>Tools like <a href="https://marketingplatform.google.com/about/analytics/">Google Analytics</a> are smart enough to handle this automatically, however, when using Fathom Analytics, you must add <code>data-spa=&quot;auto&quot;</code> to your script tag to ensure each page visit is tracked properly:</p>
<pre class="hljs"><code><div>&lt;head&gt;
    &lt;!-- ... --&gt;

    &lt;!-- Fathom Analytics --&gt;
    @if (! config('app.debug'))
        &lt;script src=&quot;https://cdn.usefathom.com/script.js&quot; data-site=&quot;ABCDEFG&quot; data-spa=&quot;auto&quot; defer&gt;&lt;/script&gt; &lt;!-- [tl! highlight] --&gt;
    @endif
&lt;/head&gt;
</div></code></pre>
<h2 id="script-evaluation">Script evaluation</h2>
<p>When navigating to a new page using <code>wire:navigate</code>, it <em>feels</em> like the browser has changed pages; however, from the browser's perspective, you are technically still on the original page.</p>
<p>Because of this, styles and scripts are executed normally on the first page, but on subsequent pages, you may have to tweak the way you normally write JavaScript.</p>
<p>Here are a few caveats and scenarios you should be aware of when using <code>wire:navigate</code>.</p>
<h3 id="dont-rely-on-domcontentloaded">Don't rely on <code>DOMContentLoaded</code></h3>
<p>It's common practice to place JavaScript inside a <code>DOMContentLoaded</code> event listener so that the code you want to run only executes after the page has fully loaded.</p>
<p>When using <code>wire:navigate</code>, <code>DOMContentLoaded</code> is only fired on the first page visit, not subsequent visits.</p>
<p>To run code on every page visit, swap every instance of <code>DOMContentLoaded</code> with <code>livewire:navigated</code>:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; { <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:navigated'</span>, () =&gt; { <span class="hljs-comment">// [tl! add]</span>
    <span class="hljs-comment">// ...</span>
})
</div></code></pre>
<p>Now, any code placed inside this listener will be run on the initial page visit, and also after Livewire has finished navigating to subsequent pages.</p>
<p>Listening to this event is useful for things like initializing third-party libraries.</p>
<h3 id="scripts-in-head-are-loaded-once">Scripts in <code>&lt;head&gt;</code> are loaded once</h3>
<p>If two pages include the same <code>&lt;script&gt;</code> tag in the <code>&lt;head&gt;</code>, that script will only be run on the initial page visit and not on subsequent page visits.</p>
<pre class="hljs"><code><div>&lt;!-- Page one --&gt;
&lt;head&gt;
    &lt;script src=&quot;/app.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;!-- Page two --&gt;
&lt;head&gt;
    &lt;script src=&quot;/app.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
</div></code></pre>
<h3 id="new-head-scripts-are-evaluated">New <code>&lt;head&gt;</code> scripts are evaluated</h3>
<p>If a subsequent page includes a new <code>&lt;script&gt;</code> tag in the <code>&lt;head&gt;</code> that was not present in the <code>&lt;head&gt;</code> of the initial page visit, Livewire will run the new <code>&lt;script&gt;</code> tag.</p>
<p>In the below example, <em>page two</em> includes a new JavaScript library for a third-party tool. When the user navigates to <em>page two</em>, that library will be evaluated.</p>
<pre class="hljs"><code><div>&lt;!-- Page one --&gt;
&lt;head&gt;
    &lt;script src=&quot;/app.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;!-- Page two --&gt;
&lt;head&gt;
    &lt;script src=&quot;/app.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/third-party.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
</div></code></pre>
<blockquote>
<p>[!info] Head assets are blocking
If you are navigating to a new page that contains an asset like <code>&lt;script src=&quot;...&quot;&gt;</code> in the head tag. That asset will be fetched and processed before the navigation is complete and the new page is swapped in. This might be surprising behavior, but it ensures any scripts that depend on those assets will have immediate access to them.</p>
</blockquote>
<h3 id="reloading-when-assets-change">Reloading when assets change</h3>
<p>It's common practice to include a version hash in an application's main JavaScript file name. This ensures that after deploying a new version of your application, users will receive the fresh JavaScript asset, and not an old version served from the browser's cache.</p>
<p>But, now that you are using <code>wire:navigate</code> and each page visit is no longer a fresh browser page load, your users may still be receiving stale JavaScript after deployments.</p>
<p>To prevent this, you may add <code>data-navigate-track</code> to a <code>&lt;script&gt;</code> tag in <code>&lt;head&gt;</code>:</p>
<pre class="hljs"><code><div>&lt;!-- Page one --&gt;
&lt;head&gt;
    &lt;script src=&quot;/app.js?id=123&quot; data-navigate-track&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;!-- Page two --&gt;
&lt;head&gt;
    &lt;script src=&quot;/app.js?id=456&quot; data-navigate-track&gt;&lt;/script&gt;
&lt;/head&gt;
</div></code></pre>
<p>When a user visits <em>page two</em>, Livewire will detect a fresh JavaScript asset and trigger a full browser page reload.</p>
<p>If you are using <a href="https://laravel.com/docs/vite#loading-your-scripts-and-styles">Laravel's Vite plug-in</a> to bundle and serve your assets, Livewire adds <code>data-navigate-track</code> to the rendered HTML asset tags automatically. You can continue referencing your assets and scripts like normal:</p>
<pre class="hljs"><code><div>&lt;head&gt;
    @vite(['resources/css/app.css', 'resources/js/app.js'])
&lt;/head&gt;
</div></code></pre>
<p>Livewire will automatically inject <code>data-navigate-track</code> onto the rendered HTML tags.</p>
<blockquote>
<p>[!warning] Only query string changes are tracked
Livewire will only reload a page if a <code>[data-navigate-track]</code> element's query string (<code>?id=&quot;456&quot;</code>) changes, not the URI itself (<code>/app.js</code>).</p>
</blockquote>
<h3 id="scripts-in-the-body-are-re-evaluated">Scripts in the <code>&lt;body&gt;</code> are re-evaluated</h3>
<p>Because Livewire replaces the entire contents of the <code>&lt;body&gt;</code> on every new page, all <code>&lt;script&gt;</code> tags on the new page will be run:</p>
<pre class="hljs"><code><div>&lt;!-- Page one --&gt;
&lt;body&gt;
    &lt;script&gt;
        console.log('Runs on page one')
    &lt;/script&gt;
&lt;/body&gt;

&lt;!-- Page two --&gt;
&lt;body&gt;
    &lt;script&gt;
        console.log('Runs on page two')
    &lt;/script&gt;
&lt;/body&gt;
</div></code></pre>
<p>If you have a <code>&lt;script&gt;</code> tag in the body that you only want to be run once, you can add the <code>data-navigate-once</code> attribute to the <code>&lt;script&gt;</code> tag and Livewire will only run it on the initial page visit:</p>
<pre class="hljs"><code><div>&lt;script data-navigate-once&gt;
    console.log('Runs only on page one')
&lt;/script&gt;
</div></code></pre>
<h2 id="customizing-the-progress-bar">Customizing the progress bar</h2>
<p>When a page takes longer than 150ms to load, Livewire will show a progress bar at the top of the page.</p>
<p>You can customize the color of this bar or disable it all together inside Livewire's config file (<code>config/livewire.php</code>):</p>
<pre class="hljs"><code><div><span class="hljs-string">'navigate'</span> =&gt; [
    <span class="hljs-string">'show_progress_bar'</span> =&gt; <span class="hljs-keyword">false</span>,
    <span class="hljs-string">'progress_bar_color'</span> =&gt; <span class="hljs-string">'#2299dd'</span>,
],
</div></code></pre>
<pre class="hljs"><code><div>
## File: nesting.md
```md

Livewire allows you to nest additional Livewire components inside of a parent component. This feature is immensely powerful, as it allows you to re-use and encapsulate behavior within Livewire components that are shared across your application.

&gt; [!warning] You might not need a Livewire component
&gt; Before you extract a portion of your template into a nested Livewire component, ask yourself: Does this content in this component need to be &quot;live&quot;? If not, we recommend that you create a simple [Blade component](https://laravel.com/docs/blade#components) instead. Only create a Livewire component if the component benefits from Livewire's dynamic nature or if there is a direct performance benefit.

Consult our [in-depth, technical examination of Livewire component nesting](/docs/understanding-nesting) for more information on the performance, usage implications, and constraints of nested Livewire components.

## Nesting a component

To nest a Livewire component within a parent component, simply include it in the parent component's Blade view. Below is an example of a `Dashboard` parent component that contains a nested `TodoList` component:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;

class Dashboard extends Component
{
    public function render()
    {
        return view('livewire.dashboard');
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;Dashboard&lt;/h1&gt;

    &lt;livewire:todo-list /&gt; &lt;!-- [tl! highlight] --&gt;
&lt;/div&gt;
</div></code></pre>
<p>On this page's initial render, the <code>Dashboard</code> component will encounter <code>&lt;livewire:todo-list /&gt;</code> and render it in place. On a subsequent network request to <code>Dashboard</code>, the nested <code>todo-list</code> component will skip rendering because it is now its own independent component on the page. For more information on the technical concepts behind nesting and rendering, consult our documentation on why <a href="/docs/understanding-nesting#every-component-is-an-island">nested components are &quot;islands&quot;</a>.</p>
<p>For more information about the syntax for rendering components, consult our documentation on <a href="/docs/components#rendering-components">Rendering Components</a>.</p>
<h2 id="passing-props-to-children">Passing props to children</h2>
<p>Passing data from a parent component to a child component is straightforward. In fact, it's very much like passing props to a typical <a href="https://laravel.com/docs/blade#components">Blade component</a>.</p>
<p>For example, let's check out a <code>TodoList</code> component that passes a collection of <code>$todos</code> to a child component called <code>TodoCount</code>:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-list'</span>, [
            <span class="hljs-string">'todos'</span> =&gt; Auth::user()-&gt;todos,
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;livewire:todo-count :todos=&quot;$todos&quot; /&gt;

    &lt;!-- ... --&gt;
&lt;/div&gt;
</div></code></pre>
<p>As you can see, we are passing <code>$todos</code> into <code>todo-count</code> with the syntax: <code>:todos=&quot;$todos&quot;</code>.</p>
<p>Now that <code>$todos</code> has been passed to the child component, you can receive that data through the child component's <code>mount()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Todo</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $todos;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($todos)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;todos = $todos;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-count'</span>, [
            <span class="hljs-string">'count'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;todos-&gt;count(),
        ]);
    }
}
</div></code></pre>
<blockquote>
<p>[!tip] Omit <code>mount()</code> as a shorter alternative
If the <code>mount()</code> method in above example feels like redundant boilerplate code to you, it can be omitted as long as the property and parameter names match:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> $todos; <span class="hljs-comment">// [tl! highlight]</span>
</div></code></pre>
</blockquote>
<h3 id="passing-static-props">Passing static props</h3>
<p>In the previous example, we passed props to our child component using Livewire's dynamic prop syntax, which supports PHP expressions like so:</p>
<pre class="hljs"><code><div>&lt;livewire:todo-count :todos=&quot;$todos&quot; /&gt;
</div></code></pre>
<p>However, sometimes you may want to pass a component a simple static value such as a string. In these cases, you may omit the colon from the beginning of the statement:</p>
<pre class="hljs"><code><div>&lt;livewire:todo-count :todos=&quot;$todos&quot; label=&quot;Todo Count:&quot; /&gt;
</div></code></pre>
<p>Boolean values may be provided to components by only specifying the key. For example, to pass an <code>$inline</code> variable with a value of <code>true</code> to a component, we may simply place <code>inline</code> on the component tag:</p>
<pre class="hljs"><code><div>&lt;livewire:todo-count :todos=&quot;$todos&quot; inline /&gt;
</div></code></pre>
<h3 id="shortened-attribute-syntax">Shortened attribute syntax</h3>
<p>When passing PHP variables into a component, the variable name and the prop name are often the same. To avoid writing the name twice, Livewire allows you to simply prefix the variable with a colon:</p>
<pre class="hljs"><code><div>&lt;livewire:todo-count :todos=&quot;$todos&quot; /&gt; &lt;!-- [tl! remove] --&gt;

&lt;livewire:todo-count :$todos /&gt; &lt;!-- [tl! add] --&gt;
</div></code></pre>
<h2 id="rendering-children-in-a-loop">Rendering children in a loop</h2>
<p>When rendering a child component within a loop, you should include a unique <code>key</code> value for each iteration.</p>
<p>Component keys are how Livewire tracks each component on subsequent renders, particularly if a component has already been rendered or if multiple components have been re-arranged on the page.</p>
<p>You can specify the component's key by specifying a <code>:key</code> prop on the child component:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;Todos&lt;/h1&gt;

    @foreach ($todos as $todo)
        &lt;livewire:todo-item :$todo :key=&quot;$todo-&gt;id&quot; /&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>As you can see, each child component will have a unique key set to the ID of each <code>$todo</code>. This ensures the key will be unique and tracked if the todos are re-ordered.</p>
<blockquote>
<p>[!warning] Keys aren't optional
If you have used frontend frameworks like Vue or Alpine, you are familiar with adding a key to a nested element in a loop. However, in those frameworks, a key isn't <em>mandatory</em>, meaning the items will render, but a re-order might not be tracked properly. However, Livewire relies more heavily on keys and will behave incorrectly without them.</p>
</blockquote>
<h2 id="reactive-props">Reactive props</h2>
<p>Developers new to Livewire expect that props are &quot;reactive&quot; by default. In other words, they expect that when a parent changes the value of a prop being passed into a child component, the child component will automatically be updated. However, by default, Livewire props are not reactive.</p>
<p>When using Livewire, <a href="/docs/understanding-nesting#every-component-is-an-island">every component is an island</a>. This means that when an update is triggered on the parent and a network request is dispatched, only the parent component's state is sent to the server to re-render - not the child component's. The intention behind this behavior is to only send the minimal amount of data back and forth between the server and client, making updates as performant as possible.</p>
<p>But, if you want or need a prop to be reactive, you can easily enable this behavior using the <code>#[Reactive]</code> attribute parameter.</p>
<p>For example, below is the template of a parent <code>TodoList</code> component. Inside, it is rendering a <code>TodoCount</code> component and passing in the current list of todos:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;Todos:&lt;/h1&gt;

    &lt;livewire:todo-count :$todos /&gt;

    &lt;!-- ... --&gt;
&lt;/div&gt;
</div></code></pre>
<p>Now let's add <code>#[Reactive]</code> to the <code>$todos</code> prop in the <code>TodoCount</code> component. Once we have done so, any todos that are added or removed inside the parent component will automatically trigger an update within the <code>TodoCount</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Reactive</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Todo</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Reactive] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $todos;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-count'</span>, [
            <span class="hljs-string">'count'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;todos-&gt;count(),
        ]);
    }
}
</div></code></pre>
<p>Reactive properties are an incredibly powerful feature, making Livewire more similar to frontend component libraries like Vue and React. But, it is important to understand the performance implications of this feature and only add <code>#[Reactive]</code> when it makes sense for your particular scenario.</p>
<h2 id="binding-to-child-data-using-wiremodel">Binding to child data using <code>wire:model</code></h2>
<p>Another powerful pattern for sharing state between parent and child components is using <code>wire:model</code> directly on a child component via Livewire's <code>Modelable</code> feature.</p>
<p>This behavior is very commonly needed when extracting an input element into a dedicated Livewire component while still accessing its state in the parent component.</p>
<p>Below is an example of a parent <code>TodoList</code> component that contains a <code>$todo</code> property which tracks the current todo about to be added by a user:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Todo</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $todo = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">()</span>
    </span>{
        Todo::create([
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;todo,
        ]);

        <span class="hljs-keyword">$this</span>-&gt;reset(<span class="hljs-string">'todo'</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-list'</span>, [
            <span class="hljs-string">'todos'</span> =&gt; Auth::user()-&gt;todos,
        ]);
    }
}
</div></code></pre>
<p>As you can see in the <code>TodoList</code> template, <code>wire:model</code> is being used to bind the <code>$todo</code> property directly to a nested <code>TodoInput</code> component:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;Todos&lt;/h1&gt;

    &lt;livewire:todo-input wire:model=&quot;todo&quot; /&gt; &lt;!-- [tl! highlight] --&gt;

    &lt;button wire:click=&quot;add&quot;&gt;Add Todo&lt;/button&gt;

    &lt;div&gt;
        @foreach ($todos as $todo)
            &lt;livewire:todo-item :$todo :key=&quot;$todo-&gt;id&quot; /&gt;
        @endforeach
    &lt;/div&gt;
&lt;/div&gt;
</div></code></pre>
<p>Livewire provides a <code>#[Modelable]</code> attribute you can add to any child component property to make it <em>modelable</em> from a parent component.</p>
<p>Below is the <code>TodoInput</code> component with the <code>#[Modelable]</code> attribute added above the <code>$value</code> property to signal to Livewire that if <code>wire:model</code> is declared on the component by a parent it should bind to this property:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Modelable</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Modelable] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $value = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-input'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;value&quot; &gt;
&lt;/div&gt;
</div></code></pre>
<p>Now the parent <code>TodoList</code> component can treat <code>TodoInput</code> like any other input element and bind directly to its value using <code>wire:model</code>.</p>
<blockquote>
<p>[!warning]
Currently Livewire only supports a single <code>#[Modelable]</code> attribute, so only the first one will be bound.</p>
</blockquote>
<h2 id="listening-for-events-from-children">Listening for events from children</h2>
<p>Another powerful parent-child component communication technique is Livewire's event system, which allows you to dispatch an event on the server or client that can be intercepted by other components.</p>
<p>Our <a href="/docs/events">complete documentation on Livewire's event system</a> provides more detailed information on events, but below we'll discuss a simple example of using an event to trigger an update in a parent component.</p>
<p>Consider a <code>TodoList</code> component with functionality to show and remove todos:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Todo</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">($todoId)</span>
    </span>{
        $todo = Todo::find($todoId);

        <span class="hljs-keyword">$this</span>-&gt;authorize(<span class="hljs-string">'delete'</span>, $todo);

        $todo-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-list'</span>, [
            <span class="hljs-string">'todos'</span> =&gt; Auth::user()-&gt;todos,
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($todos as $todo)
        &lt;livewire:todo-item :$todo :key=&quot;$todo-&gt;id&quot; /&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>To call <code>remove()</code> from inside the child <code>TodoItem</code> components, you can add an event listener to <code>TodoList</code> via the <code>#[On]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Todo</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">On</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[On('remove-todo')] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">($todoId)</span>
    </span>{
        $todo = Todo::find($todoId);

        <span class="hljs-keyword">$this</span>-&gt;authorize(<span class="hljs-string">'delete'</span>, $todo);

        $todo-&gt;delete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-list'</span>, [
            <span class="hljs-string">'todos'</span> =&gt; Auth::user()-&gt;todos,
        ]);
    }
}
</div></code></pre>
<p>Once the attribute has been added to the action, you can dispatch the <code>remove-todo</code> event from the <code>TodoList</code> child component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Todo</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Todo $todo;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'remove-todo'</span>, todoId: <span class="hljs-keyword">$this</span>-&gt;todo-&gt;id); <span class="hljs-comment">// [tl! highlight]</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-item'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;span&gt;{{ $todo-&gt;content }}&lt;/span&gt;

    &lt;button wire:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>Now when the &quot;Remove&quot; button is clicked inside a <code>TodoItem</code>, the parent <code>TodoList</code> component will intercept the dispatched event and perform the todo removal.</p>
<p>After the todo is removed in the parent, the list will be re-rendered and the child that dispatched the <code>remove-todo</code> event will be removed from the page.</p>
<h3 id="improving-performance-by-dispatching-client-side">Improving performance by dispatching client-side</h3>
<p>Though the above example works, it takes two network requests to perform a single action:</p>
<ol>
<li>The first network request from the <code>TodoItem</code> component triggers the <code>remove</code> action, dispatching the <code>remove-todo</code> event.</li>
<li>The second network request is after the <code>remove-todo</code> event is dispatched client-side and is intercepted by <code>TodoList</code> to call its <code>remove</code> action.</li>
</ol>
<p>You can avoid the first request entirely by dispatching the <code>remove-todo</code> event directly on the client-side. Below is an updated <code>TodoItem</code> component that does not trigger a network request when dispatching the <code>remove-todo</code> event:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Todo</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Todo $todo;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-item'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;span&gt;{{ $todo-&gt;content }}&lt;/span&gt;

    &lt;button wire:click=&quot;$dispatch('remove-todo', { todoId: {{ $todo-&gt;id }} })&quot;&gt;Remove&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>As a rule of thumb, always prefer dispatching client-side when possible.</p>
<h2 id="directly-accessing-the-parent-from-the-child">Directly accessing the parent from the child</h2>
<p>Event communication adds a layer of indirection. A parent can listen for an event that never gets dispatched from a child, and a child can dispatch an event that is never intercepted by a parent.</p>
<p>This indirection is sometimes desirable; however, in other cases you may prefer to access a parent component directly from the child component.</p>
<p>Livewire allows you to accomplish this by providing a magic <code>$parent</code> variable to your Blade template that you can use to access actions and properties directly from the child. Here's the above <code>TodoItem</code> template rewritten to call the <code>remove()</code> action directly on the parent via the magic <code>$parent</code> variable:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;span&gt;{{ $todo-&gt;content }}&lt;/span&gt;

    &lt;button wire:click=&quot;$parent.remove({{ $todo-&gt;id }})&quot;&gt;Remove&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>Events and direct parent communication are a few of the ways to communicate back and forth between parent and child components. Understanding their tradeoffs enables you to make more informed decisions about which pattern to use in a particular scenario.</p>
<h2 id="dynamic-child-components">Dynamic child components</h2>
<p>Sometimes, you may not know which child component should be rendered on a page until run-time. Therefore, Livewire allows you to choose a child component at run-time via <code>&lt;livewire:dynamic-component ...&gt;</code>, which receives an <code>:is</code> prop:</p>
<pre class="hljs"><code><div>&lt;livewire:dynamic-component :is=&quot;$current&quot; /&gt;
</div></code></pre>
<p>Dynamic child components are useful in a variety of different scenarios, but below is an example of rendering different steps in a multi-step form using a dynamic component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Steps</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $current = <span class="hljs-string">'step-one'</span>;

    <span class="hljs-keyword">protected</span> $steps = [
        <span class="hljs-string">'step-one'</span>,
        <span class="hljs-string">'step-two'</span>,
        <span class="hljs-string">'step-three'</span>,
    ];

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span><span class="hljs-params">()</span>
    </span>{
        $currentIndex = array_search(<span class="hljs-keyword">$this</span>-&gt;current, <span class="hljs-keyword">$this</span>-&gt;steps);

        <span class="hljs-keyword">$this</span>-&gt;current = <span class="hljs-keyword">$this</span>-&gt;steps[$currentIndex + <span class="hljs-number">1</span>];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.todo-list'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;livewire:dynamic-component :is=&quot;$current&quot; /&gt;

    &lt;button wire:click=&quot;next&quot;&gt;Next&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>Now, if the <code>Steps</code> component's <code>$current</code> prop is set to &quot;step-one&quot;, Livewire will render a component named &quot;step-one&quot; like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StepOne</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.step-one'</span>);
    }
}
</div></code></pre>
<p>If you prefer, you can use the alternative syntax:</p>
<pre class="hljs"><code><div>&lt;livewire:is :component=&quot;$current&quot; /&gt;
</div></code></pre>
<h2 id="recursive-components">Recursive components</h2>
<p>Although rarely needed by most applications, Livewire components may be nested recursively, meaning a parent component renders itself as its child.</p>
<p>Imagine a survey which contains a <code>SurveyQuestion</code> component that can have sub-questions attached to itself:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Question</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SurveyQuestion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Question $question;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.survey-question'</span>, [
            <span class="hljs-string">'subQuestions'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;question-&gt;subQuestions,
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    Question: {{ $question-&gt;content }}

    @foreach ($subQuestions as $subQuestion)
        &lt;livewire:survey-question :question=&quot;$subQuestion&quot; :key=&quot;$subQuestion-&gt;id&quot; /&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<blockquote>
<p>[!warning]
Of course, the standard rules of recursion apply to recursive components. Most importantly, you should have logic in your template to ensure the template doesn't recurse indefinitely. In the example above, if a <code>$subQuestion</code> contained the original question as its own <code>$subQuestion</code>, an infinite loop would occur.</p>
</blockquote>
<h2 id="forcing-a-child-component-to-re-render">Forcing a child component to re-render</h2>
<p>Behind the scenes, Livewire generates a key for each nested Livewire component in its template.</p>
<p>For example, consider the following nested <code>todo-count</code> component:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;livewire:todo-count :$todos /&gt;
&lt;/div&gt;
</div></code></pre>
<p>Livewire internally attaches a random string key to the component like so:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;livewire:todo-count :$todos key=&quot;lska&quot; /&gt;
&lt;/div&gt;
</div></code></pre>
<p>When the parent component is rendering and encounters a child component like the above, it stores the key in a list of children attached to the parent:</p>
<pre class="hljs"><code><div><span class="hljs-string">'children'</span> =&gt; [<span class="hljs-string">'lska'</span>],
</div></code></pre>
<p>Livewire uses this list for reference on subsequent renders in order to detect if a child component has already been rendered in a previous request. If it has already been rendered, the component is skipped. Remember, <a href="/docs/understanding-nesting#every-component-is-an-island">nested components are islands</a>. However, if the child key is not in the list, meaning it hasn't been rendered already, Livewire will create a new instance of the component and render it in place.</p>
<p>These nuances are all behind-the-scenes behavior that most users don't need to be aware of; however, the concept of setting a key on a child is a powerful tool for controlling child rendering.</p>
<p>Using this knowledge, if you want to force a component to re-render, you can simply change its key.</p>
<p>Below is an example where we might want to destroy and re-initialize the <code>todo-count</code> component if the <code>$todos</code> being passed to the component are changed:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;livewire:todo-count :todos=&quot;$todos&quot; :key=&quot;$todos-&gt;pluck('id')-&gt;join('-')&quot; /&gt;
&lt;/div&gt;
</div></code></pre>
<p>As you can see above, we are generating a dynamic <code>:key</code> string based on the content of <code>$todos</code>. This way, the <code>todo-count</code> component will render and exist as normal until the <code>$todos</code> themselves change. At that point, the component will be re-initialized entirely from scratch, and the old component will be discarded.</p>
<pre class="hljs"><code><div>
## File: offline.md
```md
In real-time applications, it can be helpful to provide a visual indication that the user's device is no longer connected to the internet.

Livewire provides the `wire:offline` directive for such cases.

By adding `wire:offline` to an element inside a Livewire component, it will be hidden by default and become visible when the user loses connection:

```blade
&lt;div wire:offline&gt;
    This device is currently offline.
&lt;/div&gt;
</div></code></pre>
<h2 id="toggling-classes">Toggling classes</h2>
<p>Adding the <code>class</code> modifier allows you to add a class to an element when the user loses their connection. The class will be removed again, once the user is back online:</p>
<pre class="hljs"><code><div>&lt;div wire:offline.class=&quot;bg-red-300&quot;&gt;
</div></code></pre>
<p>Or, using the <code>.remove</code> modifier, you can remove a class when a user loses their connection. In this example, the <code>bg-green-300</code> class will be removed from the <code>&lt;div&gt;</code> while the user has lost their connection:</p>
<pre class="hljs"><code><div>&lt;div class=&quot;bg-green-300&quot; wire:offline.class.remove=&quot;bg-green-300&quot;&gt;
</div></code></pre>
<h2 id="toggling-attributes">Toggling attributes</h2>
<p>The <code>.attr</code> modifier allows you to add an attribute to an element when the user loses their connection. In this example, the &quot;Save&quot; button will be disabled while the user has lost their connection:</p>
<pre class="hljs"><code><div>&lt;button wire:offline.attr=&quot;disabled&quot;&gt;Save&lt;/button&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: pagination.md
```md
Laravel's pagination feature allows you to query a subset of data and provides your users with the ability to navigate between *pages* of those results.

Because Laravel's paginator was designed for static applications, in a non-Livewire app, each page navigation triggers a full browser visit to a new URL containing the desired page (`?page=2`).

However, when you use pagination inside a Livewire component, users can navigate between pages while remaining on the same page. Livewire will handle everything behind the scenes, including updating the URL query string with the current page.

## Basic usage

Below is the most basic example of using pagination inside a `ShowPosts` component to only show ten posts at a time:

&gt; [!warning] You must use the `WithPagination` trait
&gt; To take advantage of Livewire's pagination features, each component containing pagination must use the `Livewire\WithPagination` trait.

```php
&lt;?php

namespace App\Livewire;

use Livewire\WithPagination;
use Livewire\Component;
use App\Models\Post;

class ShowPosts extends Component
{
    use WithPagination;

    public function render()
    {
        return view('show-posts', [
            'posts' =&gt; Post::paginate(10),
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;div&gt;
        @foreach ($posts as $post)
            &lt;!-- ... --&gt;
        @endforeach
    &lt;/div&gt;

    {{ $posts-&gt;links() }}
&lt;/div&gt;
</div></code></pre>
<p>As you can see, in addition to limiting the number of posts shown via the <code>Post::paginate()</code> method, we will also use <code>$posts-&gt;links()</code> to render page navigation links.</p>
<p>For more information on pagination using Laravel, check out <a href="https://laravel.com/docs/pagination">Laravel's comprehensive pagination documentation</a>.</p>
<h2 id="disabling-url-query-string-tracking">Disabling URL query string tracking</h2>
<p>By default, Livewire's paginator tracks the current page in the browser URL's query string like so: <code>?page=2</code>.</p>
<p>If you wish to still use Livewire's pagination utility, but disable query string tracking, you can do so using the <code>WithoutUrlPagination</code> trait:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">WithoutUrlPagination</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">WithPagination</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">WithPagination</span>, <span class="hljs-title">WithoutUrlPagination</span>; <span class="hljs-comment">// [tl! highlight]</span>

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now, pagination will work as expected, but the current page won't show up in the query string. This also means the current page won't be persisted across page changes.</p>
<h2 id="customizing-scroll-behavior">Customizing scroll behavior</h2>
<p>By default, Livewire's paginator scrolls to the top of the page after every page change.</p>
<p>You can disable this behavior by passing <code>false</code> to the <code>scrollTo</code> parameter of the <code>links()</code> method like so:</p>
<pre class="hljs"><code><div>{{ $posts-&gt;links(data: ['scrollTo' =&gt; false]) }}
</div></code></pre>
<p>Alternatively, you can provide any CSS selector to the <code>scrollTo</code> parameter, and Livewire will find the nearest element matching that selector and scroll to it after each navigation:</p>
<pre class="hljs"><code><div>{{ $posts-&gt;links(data: ['scrollTo' =&gt; '#paginated-posts']) }}
</div></code></pre>
<h2 id="resetting-the-page">Resetting the page</h2>
<p>When sorting or filtering results, it is common to want to reset the page number back to <code>1</code>.</p>
<p>For this reason, Livewire provides the <code>$this-&gt;resetPage()</code> method, allowing you to reset the page number from anywhere in your component.</p>
<p>The following component demonstrates using this method to reset the page after the search form is submitted:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">WithPagination</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">WithPagination</span>;

    <span class="hljs-keyword">public</span> $query = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;resetPage();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'show-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Post::where(<span class="hljs-string">'title'</span>, <span class="hljs-string">'like'</span>, <span class="hljs-string">'%'</span>.<span class="hljs-keyword">$this</span>-&gt;query.<span class="hljs-string">'%'</span>)-&gt;paginate(<span class="hljs-number">10</span>),
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;form wire:submit=&quot;search&quot;&gt;
        &lt;input type=&quot;text&quot; wire:model=&quot;query&quot;&gt;

        &lt;button type=&quot;submit&quot;&gt;Search posts&lt;/button&gt;
    &lt;/form&gt;

    &lt;div&gt;
        @foreach ($posts as $post)
            &lt;!-- ... --&gt;
        @endforeach
    &lt;/div&gt;

    {{ $posts-&gt;links() }}
&lt;/div&gt;
</div></code></pre>
<p>Now, if a user was on page <code>5</code> of the results and then filtered the results further by pressing &quot;Search posts&quot;, the page would be reset back to <code>1</code>.</p>
<h3 id="available-page-navigation-methods">Available page navigation methods</h3>
<p>In addition to <code>$this-&gt;resetPage()</code>, Livewire provides other useful methods for navigating between pages programmatically from your component:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$this-&gt;setPage($page)</code></td>
<td>Set the paginator to a specific page number</td>
</tr>
<tr>
<td><code>$this-&gt;resetPage()</code></td>
<td>Reset the page back to 1</td>
</tr>
<tr>
<td><code>$this-&gt;nextPage()</code></td>
<td>Go to the next page</td>
</tr>
<tr>
<td><code>$this-&gt;previousPage()</code></td>
<td>Go to the previous page</td>
</tr>
</tbody>
</table>
<h2 id="multiple-paginators">Multiple paginators</h2>
<p>Because both Laravel and Livewire use URL query string parameters to store and track the current page number, if a single page contains multiple paginators, it's important to assign them different names.</p>
<p>To demonstrate the problem more clearly, consider the following <code>ShowClients</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">WithPagination</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Client</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowClients</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">WithPagination</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'show-clients'</span>, [
            <span class="hljs-string">'clients'</span> =&gt; Client::paginate(<span class="hljs-number">10</span>),
        ]);
    }
}
</div></code></pre>
<p>As you can see, the above component contains a paginated set of <em>clients</em>. If a user were to navigate to page <code>2</code> of this result set, the URL might look like the following:</p>
<pre class="hljs"><code><div>http://application.test/?page=2
</div></code></pre>
<p>Suppose the page also contains a <code>ShowInvoices</code> component that also uses pagination. To independently track each paginator's current page, you need to specify a name for the second paginator like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">WithPagination</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Invoices</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowInvoices</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">WithPagination</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'show-invoices'</span>, [
            <span class="hljs-string">'invoices'</span> =&gt; Invoice::paginate(<span class="hljs-number">10</span>, pageName: <span class="hljs-string">'invoices-page'</span>),
        ]);
    }
}
</div></code></pre>
<p>Now, because of the <code>pageName</code> parameter that has been added to the <code>paginate</code> method, when a user visits page <code>2</code> of the <em>invoices</em>, the URL will contain the following:</p>
<pre class="hljs"><code><div>https://application.test/customers?page=2&amp;invoices-page=2
</div></code></pre>
<p>When using Livewire's page navigation methods on a named paginator, you must provide the page name as an additional parameter:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;setPage(<span class="hljs-number">2</span>, pageName: <span class="hljs-string">'invoices-page'</span>);

<span class="hljs-keyword">$this</span>-&gt;resetPage(pageName: <span class="hljs-string">'invoices-page'</span>);

<span class="hljs-keyword">$this</span>-&gt;nextPage(pageName: <span class="hljs-string">'invoices-page'</span>);

<span class="hljs-keyword">$this</span>-&gt;previousPage(pageName: <span class="hljs-string">'invoices-page'</span>);
</div></code></pre>
<h2 id="hooking-into-page-updates">Hooking into page updates</h2>
<p>Livewire allows you to execute code before and after a page is updated by defining either of the following methods inside your component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">WithPagination</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">WithPagination</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatingPage</span><span class="hljs-params">($page)</span>
    </span>{
        <span class="hljs-comment">// Runs before the page is updated for this component...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatedPage</span><span class="hljs-params">($page)</span>
    </span>{
        <span class="hljs-comment">// Runs after the page is updated for this component...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'show-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Post::paginate(<span class="hljs-number">10</span>),
        ]);
    }
}
</div></code></pre>
<h3 id="named-paginator-hooks">Named paginator hooks</h3>
<p>The previous hooks only apply to the default paginator. If you are using a named paginator, you must define the methods using the paginator's name.</p>
<p>For example, below is an example of what a hook for a paginator named <code>invoices-page</code> would look like:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatingInvoicesPage</span><span class="hljs-params">($page)</span>
</span>{
    <span class="hljs-comment">//</span>
}
</div></code></pre>
<h3 id="general-paginator-hooks">General paginator hooks</h3>
<p>If you prefer to not reference the paginator name in the hook method name, you can use the more generic alternatives and simply receive the <code>$pageName</code> as a second argument to the hook method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatingPaginators</span><span class="hljs-params">($page, $pageName)</span>
</span>{
    <span class="hljs-comment">// Runs before the page is updated for this component...</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatedPaginators</span><span class="hljs-params">($page, $pageName)</span>
</span>{
    <span class="hljs-comment">// Runs after the page is updated for this component...</span>
}
</div></code></pre>
<h2 id="using-the-simple-theme">Using the simple theme</h2>
<p>You can use Laravel's <code>simplePaginate()</code> method instead of <code>paginate()</code> for added speed and simplicity.</p>
<p>When paginating results using this method, only <em>next</em> and <em>previous</em> navigation links will be shown to the user instead of individual links for each page number:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'show-posts'</span>, [
        <span class="hljs-string">'posts'</span> =&gt; Post::simplePaginate(<span class="hljs-number">10</span>),
    ]);
}
</div></code></pre>
<p>For more information on simple pagination, check out <a href="https://laravel.com/docs/pagination#simple-pagination">Laravel's &quot;simplePaginator&quot; documentation</a>.</p>
<h2 id="using-cursor-pagination">Using cursor pagination</h2>
<p>Livewire also supports using Laravel's cursor pagination — a faster pagination method useful in large datasets:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> view(<span class="hljs-string">'show-posts'</span>, [
        <span class="hljs-string">'posts'</span> =&gt; Post::cursorPaginate(<span class="hljs-number">10</span>),
    ]);
}
</div></code></pre>
<p>By using <code>cursorPaginate()</code> instead of <code>paginate()</code> or <code>simplePaginate()</code>, the query string in your application's URL will store an encoded <em>cursor</em> instead of a standard page number. For example:</p>
<pre class="hljs"><code><div>https://example.com/posts?cursor=eyJpZCI6MTUsIl9wb2ludHNUb05leHRJdGVtcyI6dHJ1ZX0
</div></code></pre>
<p>For more information on cursor pagination, check out <a href="https://laravel.com/docs/pagination#cursor-pagination">Laravel's cursor pagination documentation</a>.</p>
<h2 id="using-bootstrap-instead-of-tailwind">Using Bootstrap instead of Tailwind</h2>
<p>If you are using <a href="https://getbootstrap.com/">Bootstrap</a> instead of <a href="https://tailwindcss.com/">Tailwind</a> as your application's CSS framework, you can configure Livewire to use Bootstrap styled pagination views instead of the default Tailwind views.</p>
<p>To accomplish this, set the <code>pagination_theme</code> configuration value in your application's <code>config/livewire.php</code> file:</p>
<pre class="hljs"><code><div><span class="hljs-string">'pagination_theme'</span> =&gt; <span class="hljs-string">'bootstrap'</span>,
</div></code></pre>
<blockquote>
<p>[!info] Publishing Livewire's configuration file
Before customizing the pagination theme, you must first publish Livewire's configuration file to your application's <code>/config</code> directory by running the following command:</p>
<pre class="hljs"><code><div>php artisan livewire:publish --config
</div></code></pre>
</blockquote>
<h2 id="modifying-the-default-pagination-views">Modifying the default pagination views</h2>
<p>If you want to modify Livewire's pagination views to fit your application's style, you can do so by <em>publishing</em> them using the following command:</p>
<pre class="hljs"><code><div>php artisan livewire:publish --pagination
</div></code></pre>
<p>After running this command, the following four files will be inserted into the <code>resources/views/vendor/livewire</code> directory:</p>
<table>
<thead>
<tr>
<th>View file name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tailwind.blade.php</code></td>
<td>The standard Tailwind pagination theme</td>
</tr>
<tr>
<td><code>tailwind-simple.blade.php</code></td>
<td>The <em>simple</em> Tailwind pagination theme</td>
</tr>
<tr>
<td><code>bootstrap.blade.php</code></td>
<td>The standard Bootstrap pagination theme</td>
</tr>
<tr>
<td><code>bootstrap-simple.blade.php</code></td>
<td>The <em>simple</em> Bootstrap pagination theme</td>
</tr>
</tbody>
</table>
<p>Once the files have been published, you have complete control over them. When rendering pagination links using the paginated result's <code>-&gt;links()</code> method inside your template, Livewire will use these files instead of its own.</p>
<h2 id="using-custom-pagination-views">Using custom pagination views</h2>
<p>If you wish to bypass Livewire's pagination views entirely, you can render your own in one of two ways:</p>
<ol>
<li>The <code>-&gt;links()</code> method in your Blade view</li>
<li>The <code>paginationView()</code> method in your component</li>
</ol>
<h3 id="via--links">Via <code>-&gt;links()</code></h3>
<p>The first approach is to simply pass your custom pagination Blade view name to the <code>-&gt;links()</code> method directly:</p>
<pre class="hljs"><code><div>{{ $posts-&gt;links('custom-pagination-links') }}
</div></code></pre>
<p>When rendering the pagination links, Livewire will now look for a view at <code>resources/views/custom-pagination-links.blade.php</code>.</p>
<h3 id="via-paginationview">Via <code>paginationView()</code></h3>
<p>The second approach is to declare a <code>paginationView</code> method inside your component which returns the name of the view you would like to use:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paginationView</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'custom-pagination-links-view'</span>;
}
</div></code></pre>
<h3 id="sample-pagination-view">Sample pagination view</h3>
<p>Below is an unstyled sample of a simple Livewire pagination view for your reference.</p>
<p>As you can see, you can use Livewire's page navigation helpers like <code>$this-&gt;nextPage()</code> directly inside your template by adding <code>wire:click=&quot;nextPage&quot;</code> to buttons:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    @if ($paginator-&gt;hasPages())
        &lt;nav role=&quot;navigation&quot; aria-label=&quot;Pagination Navigation&quot;&gt;
            &lt;span&gt;
                @if ($paginator-&gt;onFirstPage())
                    &lt;span&gt;Previous&lt;/span&gt;
                @else
                    &lt;button wire:click=&quot;previousPage&quot; wire:loading.attr=&quot;disabled&quot; rel=&quot;prev&quot;&gt;Previous&lt;/button&gt;
                @endif
            &lt;/span&gt;

            &lt;span&gt;
                @if ($paginator-&gt;onLastPage())
                    &lt;span&gt;Next&lt;/span&gt;
                @else
                    &lt;button wire:click=&quot;nextPage&quot; wire:loading.attr=&quot;disabled&quot; rel=&quot;next&quot;&gt;Next&lt;/button&gt;
                @endif
            &lt;/span&gt;
        &lt;/nav&gt;
    @endif
&lt;/div&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: polling.md
```md
Polling is a technique used in web applications to &quot;poll&quot; the server (send regular requests) for updates. It's a simple way to keep a page up-to-date without the need for a more sophisticated technology like [WebSockets](/docs/events#real-time-events-using-laravel-echo).

## Basic usage

Using polling inside Livewire is as simple as adding `wire:poll` to an element.

Below is an example of a `SubscriberCount` component that shows a user's subscriber count:

```php
&lt;?php

namespace App\Livewire;

use Illuminate\Support\Facades\Auth;
use Livewire\Component;

class SubscriberCount extends Component
{
    public function render()
    {
        return view('livewire.subscriber-count', [
            'count' =&gt; Auth::user()-&gt;subscribers-&gt;count(),
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div wire:poll&gt;
    Subscribers: {{ $count }}
&lt;/div&gt;
</div></code></pre>
<p>Normally, this component would show the subscriber count for the user and never update until the page was refreshed. However, because of <code>wire:poll</code> on the component's template, this component will now refresh itself every <code>2.5</code> seconds, keeping the subscriber count up-to-date.</p>
<p>You can also specify an action to fire on the polling interval by passing a value to <code>wire:poll</code>:</p>
<pre class="hljs"><code><div>&lt;div wire:poll=&quot;refreshSubscribers&quot;&gt;
    Subscribers: {{ $count }}
&lt;/div&gt;
</div></code></pre>
<p>Now, the <code>refreshSubscribers()</code> method on the component will be called every <code>2.5</code> seconds.</p>
<h2 id="timing-control">Timing control</h2>
<p>The primary drawback of polling is that it can be resource intensive. If you have a thousand visitors on a page that uses polling, one thousand network requests will be triggered every <code>2.5</code> seconds.</p>
<p>The best way to reduce requests in this scenario is simply to make the polling interval longer.</p>
<p>You can manually control how often the component will poll by appending the desired duration to <code>wire:poll</code> like so:</p>
<pre class="hljs"><code><div>&lt;div wire:poll.15s&gt; &lt;!-- In seconds... --&gt;

&lt;div wire:poll.15000ms&gt; &lt;!-- In milliseconds... --&gt;
</div></code></pre>
<h2 id="background-throttling">Background throttling</h2>
<p>To further cut down on server requests, Livewire automatically throttles polling when a page is in the background. For example, if a user keeps a page open in a different browser tab, Livewire will reduce the number of polling requests by 95% until the user revisits the tab.</p>
<p>If you want to opt-out of this behavior and keep polling continuously, even when a tab is in the background, you can add the <code>.keep-alive</code> modifier to <code>wire:poll</code>:</p>
<pre class="hljs"><code><div>&lt;div wire:poll.keep-alive&gt;
</div></code></pre>
<h2 id="viewport-throttling">Viewport throttling</h2>
<p>Another measure you can take to only poll when necessary, is to add the <code>.visible</code> modifier to <code>wire:poll</code>. The <code>.visible</code> modifier instructs Livewire to only poll the component when it is visible on the page:</p>
<pre class="hljs"><code><div>&lt;div wire:poll.visible&gt;
</div></code></pre>
<p>If a component using <code>wire:visible</code> is at the bottom of a long page, it won't start polling until the user scrolls it into the viewport. When the user scrolls away, it will stop polling again.</p>
<pre class="hljs"><code><div>
## File: properties.md
```md
Properties store and manage data inside your Livewire components. They are defined as public properties on component classes and can be accessed and modified on both the server and client-side.

## Initializing properties

You can set initial values for properties within your component's `mount()` method.

Consider the following example:

```php
&lt;?php

namespace App\Livewire;

use Illuminate\Support\Facades\Auth;
use Livewire\Component;

class TodoList extends Component
{
    public $todos = [];

    public $todo = '';

    public function mount()
    {
        $this-&gt;todos = Auth::user()-&gt;todos; // [tl! highlight]
    }

    // ...
}
</div></code></pre>
<p>In this example, we've defined an empty <code>todos</code> array and initialized it with existing todos from the authenticated user. Now, when the component renders for the first time, all the existing todos in the database are shown to the user.</p>
<h2 id="bulk-assignment">Bulk assignment</h2>
<p>Sometimes initializing many properties in the <code>mount()</code> method can feel verbose. To help with this, Livewire provides a convenient way to assign multiple properties at once via the <code>fill()</code> method. By passing an associative array of property names and their respective values, you can set several properties simultaneously and cut down on repetitive lines of code in <code>mount()</code>.</p>
<p>For example:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $post;

    <span class="hljs-keyword">public</span> $title;

    <span class="hljs-keyword">public</span> $description;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = $post;

        <span class="hljs-keyword">$this</span>-&gt;fill( <span class="hljs-comment">// [tl! highlight]</span>
            $post-&gt;only(<span class="hljs-string">'title'</span>, <span class="hljs-string">'description'</span>), <span class="hljs-comment">// [tl! highlight]</span>
        ); <span class="hljs-comment">// [tl! highlight]</span>
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Because <code>$post-&gt;only(...)</code> returns an associative array of model attributes and values based on the names you pass into it, the <code>$title</code> and <code>$description</code> properties will be initially set to the <code>title</code> and <code>description</code> of the <code>$post</code> model from the database without having to set each one individually.</p>
<h2 id="data-binding">Data binding</h2>
<p>Livewire supports two-way data binding through the <code>wire:model</code> HTML attribute. This allows you to easily synchronize data between component properties and HTML inputs, keeping your user interface and component state in sync.</p>
<p>Let's use the <code>wire:model</code> directive to bind the <code>$todo</code> property in a <code>TodoList</code> component to a basic input element:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $todos = [];

    <span class="hljs-keyword">public</span> $todo = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;todos[] = <span class="hljs-keyword">$this</span>-&gt;todo;

        <span class="hljs-keyword">$this</span>-&gt;todo = <span class="hljs-string">''</span>;
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;todo&quot; placeholder=&quot;Todo...&quot;&gt; &lt;!-- [tl! highlight] --&gt;

    &lt;button wire:click=&quot;add&quot;&gt;Add Todo&lt;/button&gt;

    &lt;ul&gt;
        @foreach ($todos as $todo)
            &lt;li&gt;{{ $todo }}&lt;/li&gt;
        @endforeach
    &lt;/ul&gt;
&lt;/div&gt;
</div></code></pre>
<p>In the above example, the text input's value will synchronize with the <code>$todo</code> property on the server when the &quot;Add Todo&quot; button is clicked.</p>
<p>This is just scratching the surface of <code>wire:model</code>. For deeper information on data binding, check out our <a href="/docs/forms">documentation on forms</a>.</p>
<h2 id="resetting-properties">Resetting properties</h2>
<p>Sometimes, you may need to reset your properties back to their initial state after an action is performed by the user. In these cases, Livewire provides a <code>reset()</code> method that accepts one or more property names and resets their values to their initial state.</p>
<p>In the example below, we can avoid code duplication by using <code>$this-&gt;reset()</code> to reset the <code>todo</code> field after the &quot;Add Todo&quot; button is clicked:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageTodos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $todos = [];

    <span class="hljs-keyword">public</span> $todo = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;todos[] = <span class="hljs-keyword">$this</span>-&gt;todo;

        <span class="hljs-keyword">$this</span>-&gt;reset(<span class="hljs-string">'todo'</span>); <span class="hljs-comment">// [tl! highlight]</span>
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>In the above example, after a user clicks &quot;Add Todo&quot;, the input field holding the todo that has just been added will clear, allowing the user to write a new todo.</p>
<blockquote>
<p>[!warning] <code>reset()</code> won't work on values set in <code>mount()</code>
<code>reset()</code> will reset a property to its state before the <code>mount()</code> method was called. If you initialized the property in <code>mount()</code> to a different value, you will need to reset the property manually.</p>
</blockquote>
<h2 id="supported-property-types">Supported property types</h2>
<p>Livewire supports a limited set of property types because of its unique approach to managing component data between server requests.</p>
<p>Each property in a Livewire component is serialized or &quot;dehydrated&quot; into JSON between requests, then &quot;hydrated&quot; from JSON back into PHP for the next request.</p>
<p>This two-way conversion process has certain limitations, restricting the types of properties Livewire can work with.</p>
<h3 id="primitive-types">Primitive types</h3>
<p>Livewire supports primitive types such as strings, integers, etc. These types can be easily converted to and from JSON, making them ideal for use as properties in Livewire components.</p>
<p>Livewire supports the following primitive property types: <code>Array</code>, <code>String</code>, <code>Integer</code>, <code>Float</code>, <code>Boolean</code>, and <code>Null</code>.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $todos = []; <span class="hljs-comment">// Array</span>

    <span class="hljs-keyword">public</span> $todo = <span class="hljs-string">''</span>; <span class="hljs-comment">// String</span>

    <span class="hljs-keyword">public</span> $maxTodos = <span class="hljs-number">10</span>; <span class="hljs-comment">// Integer</span>

    <span class="hljs-keyword">public</span> $showTodos = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Boolean</span>

    <span class="hljs-keyword">public</span> $todoFilter; <span class="hljs-comment">// Null</span>
}
</div></code></pre>
<h3 id="common-php-types">Common PHP types</h3>
<p>In addition to primitive types, Livewire supports common PHP object types used in Laravel applications. However, it's important to note that these types will be <em>dehydrated</em> into JSON and <em>hydrated</em> back to PHP on each request. This means that the property may not preserve run-time values such as closures. Also, information about the object such as class names may be exposed to JavaScript.</p>
<p>Supported PHP types:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Full Class Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Collection</td>
<td><code>Illuminate\Support\Collection</code></td>
</tr>
<tr>
<td>Eloquent Collection</td>
<td><code>Illuminate\Database\Eloquent\Collection</code></td>
</tr>
<tr>
<td>Model</td>
<td><code>Illuminate\Database\Model</code></td>
</tr>
<tr>
<td>DateTime</td>
<td><code>DateTime</code></td>
</tr>
<tr>
<td>Carbon</td>
<td><code>Carbon\Carbon</code></td>
</tr>
<tr>
<td>Stringable</td>
<td><code>Illuminate\Support\Stringable</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>[!warning] Eloquent Collections and Models
When storing Eloquent Collections and Models in Livewire properties, additional query constraints like select(...) will not be re-applied on subsequent requests.</p>
<p>See <a href="#eloquent-constraints-arent-preserved-between-requests">Eloquent constraints aren't preserved between requests</a> for more details</p>
</blockquote>
<p>Here's a quick example of setting properties as these various types:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">$this</span>-&gt;todos = collect([]); <span class="hljs-comment">// Collection</span>

    <span class="hljs-keyword">$this</span>-&gt;todos = Todos::all(); <span class="hljs-comment">// Eloquent Collection</span>

    <span class="hljs-keyword">$this</span>-&gt;todo = Todos::first(); <span class="hljs-comment">// Model</span>

    <span class="hljs-keyword">$this</span>-&gt;date = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-string">'now'</span>); <span class="hljs-comment">// DateTime</span>

    <span class="hljs-keyword">$this</span>-&gt;date = <span class="hljs-keyword">new</span> Carbon(<span class="hljs-string">'now'</span>); <span class="hljs-comment">// Carbon</span>

    <span class="hljs-keyword">$this</span>-&gt;todo = str(<span class="hljs-string">''</span>); <span class="hljs-comment">// Stringable</span>
}
</div></code></pre>
<h3 id="supporting-custom-types">Supporting custom types</h3>
<p>Livewire allows your application to support custom types through two powerful mechanisms:</p>
<ul>
<li>Wireables</li>
<li>Synthesizers</li>
</ul>
<p>Wireables are simple and easy to use for most applications, so we'll explore them below. If you're an advanced user or package author wanting more flexibility, <a href="/docs/synthesizers">Synthesizers are the way to go</a>.</p>
<h4 id="wireables">Wireables</h4>
<p>Wireables are any class in your application that implements the <code>Wireable</code> interface.</p>
<p>For example, let's imagine you have a <code>Customer</code> object in your application that contains the primary data about a customer:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span>
</span>{
    <span class="hljs-keyword">protected</span> $name;
    <span class="hljs-keyword">protected</span> $age;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">($name, $age)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;name = $name;
        <span class="hljs-keyword">$this</span>-&gt;age = $age;
    }
}
</div></code></pre>
<p>Attempting to set an instance of this class to a Livewire component property will result in an error telling you that the <code>Customer</code> property type isn't supported:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowCustomer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Customer $customer;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;customer = <span class="hljs-keyword">new</span> Customer(<span class="hljs-string">'Caleb'</span>, <span class="hljs-number">29</span>);
    }
}
</div></code></pre>
<p>However, you can solve this by implementing the <code>Wireable</code> interface and adding a <code>toLivewire()</code> and <code>fromLivewire()</code> method to your class. These methods tell Livewire how to turn properties of this type into JSON and back again:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Wireable</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Wireable</span>
</span>{
    <span class="hljs-keyword">protected</span> $name;
    <span class="hljs-keyword">protected</span> $age;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">($name, $age)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;name = $name;
        <span class="hljs-keyword">$this</span>-&gt;age = $age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLivewire</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'name'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;name,
            <span class="hljs-string">'age'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;age,
        ];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromLivewire</span><span class="hljs-params">($value)</span>
    </span>{
        $name = $value[<span class="hljs-string">'name'</span>];
        $age = $value[<span class="hljs-string">'age'</span>];

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">static</span>($name, $age);
    }
}
</div></code></pre>
<p>Now you can freely set <code>Customer</code> objects on your Livewire components and Livewire will know how to convert these objects into JSON and back into PHP.</p>
<p>As mentioned earlier, if you want to support types more globally and powerfully, Livewire offers Synthesizers, its advanced internal mechanism for handling different property types. <a href="/docs/synthesizers">Learn more about Synthesizers</a>.</p>
<h2 id="accessing-properties-from-javascript">Accessing properties from JavaScript</h2>
<p>Because Livewire properties are also available in the browser via JavaScript, you can access and manipulate their JavaScript representations from <a href="https://alpinejs.dev/">AlpineJS</a>.</p>
<p>Alpine is a lightweight JavaScript library that is included with Livewire. Alpine provides a way to build lightweight interactions into your Livewire components without making full server roundtrips.</p>
<p>Internally, Livewire's frontend is built on top of Alpine. In fact, every Livewire component is actually an Alpine component under-the-hood. This means that you can freely utilize Alpine inside your Livewire components.</p>
<p>The rest of this page assumes a basic familiarity with Alpine. If you're unfamiliar with Alpine, <a href="https://alpinejs.dev/docs">take a look at the Alpine documentation</a>.</p>
<h3 id="accessing-properties">Accessing properties</h3>
<p>Livewire exposes a magic <code>$wire</code> object to Alpine. You can access the <code>$wire</code> object from any Alpine expression inside your Livewire component.</p>
<p>The <code>$wire</code> object can be treated like a JavaScript version of your Livewire component. It has all the same properties and methods as the PHP version of your component, but also contains a few dedicated methods to perform specific functions in your template.</p>
<p>For example, we can use <code>$wire</code> to show a live character count of the <code>todo</code> input field:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;todo&quot;&gt;

    Todo character length: &lt;h2 x-text=&quot;$wire.todo.length&quot;&gt;&lt;/h2&gt;
&lt;/div&gt;
</div></code></pre>
<p>As the user types in the field, the character length of the current todo being written will be shown and live-updated on the page, all without sending a network request to the server.</p>
<p>If you prefer, you can use the more explicit <code>.get()</code> method to accomplish the same thing:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;todo&quot;&gt;

    Todo character length: &lt;h2 x-text=&quot;$wire.get('todo').length&quot;&gt;&lt;/h2&gt;
&lt;/div&gt;
</div></code></pre>
<h3 id="manipulating-properties">Manipulating properties</h3>
<p>Similarly, you can manipulate your Livewire component properties in JavaScript using <code>$wire</code>.</p>
<p>For example, let's add a &quot;Clear&quot; button to the <code>TodoList</code> component to allow the user to reset the input field using only JavaScript:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;todo&quot;&gt;

    &lt;button x-on:click=&quot;$wire.todo = ''&quot;&gt;Clear&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>After the user clicks &quot;Clear&quot;, the input will be reset to an empty string, without sending a network request to the server.</p>
<p>On the subsequent request, the server-side value of <code>$todo</code> will be updated and synchronized.</p>
<p>If you prefer, you can also use the more explicit <code>.set()</code> method for setting properties client-side. However, you should note that using <code>.set()</code> by default immediately triggers a network request and synchronizes the state with the server. If that is desired, then this is an excellent API:</p>
<pre class="hljs"><code><div>&lt;button x-on:click=&quot;$wire.set('todo', '')&quot;&gt;Clear&lt;/button&gt;
</div></code></pre>
<p>In order to update the property without sending a network request to the server, you can pass a third bool parameter. This will defer the network request and on a subsequent request, the state will be synchronized on the server-side:</p>
<pre class="hljs"><code><div>&lt;button x-on:click=&quot;$wire.set('todo', '', false)&quot;&gt;Clear&lt;/button&gt;
</div></code></pre>
<h2 id="security-concerns">Security concerns</h2>
<p>While Livewire properties are a powerful feature, there are a few security considerations that you should be aware of before using them.</p>
<p>In short, always treat public properties as user input — as if they were request input from a traditional endpoint. In light of this, it's essential to validate and authorize properties before persisting them to a database — just like you would do when working with request input in a controller.</p>
<h3 id="dont-trust-property-values">Don't trust property values</h3>
<p>To demonstrate how neglecting to authorize and validate properties can introduce security holes in your application, the following <code>UpdatePost</code> component is vulnerable to attack:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $id;
    <span class="hljs-keyword">public</span> $title;
    <span class="hljs-keyword">public</span> $content;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;id = $post-&gt;id;
        <span class="hljs-keyword">$this</span>-&gt;title = $post-&gt;title;
        <span class="hljs-keyword">$this</span>-&gt;content = $post-&gt;content;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
    </span>{
        $post = Post::findOrFail(<span class="hljs-keyword">$this</span>-&gt;id);

        $post-&gt;update([
            <span class="hljs-string">'title'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;title,
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;content,
        ]);

        session()-&gt;flash(<span class="hljs-string">'message'</span>, <span class="hljs-string">'Post updated successfully!'</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.update-post'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;update&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;content&quot;&gt;

    &lt;button type=&quot;submit&quot;&gt;Update&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>At first glance, this component may look completely fine. But, let's walk through how an attacker could use the component to do unauthorized things in your application.</p>
<p>Because we are storing the <code>id</code> of the post as a public property on the component, it can be manipulated on the client just the same as the <code>title</code> and <code>content</code> properties.</p>
<p>It doesn't matter that we didn't write an input with <code>wire:model=&quot;id&quot;</code>. A malicious user can easily change the view to the following using their browser DevTools:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;update&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;id&quot;&gt; &lt;!-- [tl! highlight] --&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;content&quot;&gt;

    &lt;button type=&quot;submit&quot;&gt;Update&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>Now the malicious user can update the <code>id</code> input to the ID of a different post model. When the form is submitted and <code>update()</code> is called, <code>Post::findOrFail()</code> will return and update a post the user is not the owner of.</p>
<p>To prevent this kind of attack, we can use one or both of the following strategies:</p>
<ul>
<li>Authorize the input</li>
<li>Lock the property from updates</li>
</ul>
<h4 id="authorizing-the-input">Authorizing the input</h4>
<p>Because <code>$id</code> can be manipulated client-side with something like <code>wire:model</code>, just like in a controller, we can use <a href="https://laravel.com/docs/authorization">Laravel's authorization</a> to make sure the current user can update the post:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
</span>{
    $post = Post::findOrFail(<span class="hljs-keyword">$this</span>-&gt;id);

    <span class="hljs-keyword">$this</span>-&gt;authorize(<span class="hljs-string">'update'</span>, $post); <span class="hljs-comment">// [tl! highlight]</span>

    $post-&gt;update(...);
}
</div></code></pre>
<p>If a malicious user mutates the <code>$id</code> property, the added authorization will catch it and throw an error.</p>
<h4 id="locking-the-property">Locking the property</h4>
<p>Livewire also allows you to &quot;lock&quot; properties in order to prevent properties from being modified on the client-side. You can &quot;lock&quot; a property from client-side manipulation using the <code>#[Locked]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Locked</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Locked] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $id;

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now, if a user tries to modify <code>$id</code> on the front end, an error will be thrown.</p>
<p>By using <code>#[Locked]</code>, you can assume this property has not been manipulated anywhere outside your component's class.</p>
<p>For more information on locking properties, <a href="/docs/locked">consult the Locked properties documentation</a>.</p>
<h4 id="eloquent-models-and-locking">Eloquent models and locking</h4>
<p>When an Eloquent model is assigned to a Livewire component property, Livewire will automatically lock the property and ensure the ID isn't changed, so that you are safe from these kinds of attacks:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post; <span class="hljs-comment">// [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $title;
    <span class="hljs-keyword">public</span> $content;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = $post;
        <span class="hljs-keyword">$this</span>-&gt;title = $post-&gt;title;
        <span class="hljs-keyword">$this</span>-&gt;content = $post-&gt;content;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post-&gt;update([
            <span class="hljs-string">'title'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;title,
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;content,
        ]);

        session()-&gt;flash(<span class="hljs-string">'message'</span>, <span class="hljs-string">'Post updated successfully!'</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.update-post'</span>);
    }
}
</div></code></pre>
<h3 id="properties-expose-system-information-to-the-browser">Properties expose system information to the browser</h3>
<p>Another essential thing to remember is that Livewire properties are serialized or &quot;dehydrated&quot; before they are sent to the browser. This means that their values are converted to a format that can be sent over the wire and understood by JavaScript. This format can expose information about your application to the browser, including the names and class names of your properties.</p>
<p>For example, suppose you have a Livewire component that defines a public property named <code>$post</code>. This property contains an instance of a <code>Post</code> model from your database. In this case, the dehydrated value of this property sent over the wire might look something like this:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"model"</span>,
    <span class="hljs-attr">"class"</span>: <span class="hljs-string">"App\Models\Post"</span>,
    <span class="hljs-attr">"key"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">"relationships"</span>: []
}
</div></code></pre>
<p>As you can see, the dehydrated value of the <code>$post</code> property includes the class name of the model (<code>App\Models\Post</code>) as well as the ID and any relationships that have been eager-loaded.</p>
<p>If you don't want to expose the class name of the model, you can use Laravel's &quot;morphMap&quot; functionality from a service provider to assign an alias to a model class name:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Providers</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">ServiceProvider</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Database</span>\<span class="hljs-title">Eloquent</span>\<span class="hljs-title">Relations</span>\<span class="hljs-title">Relation</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppServiceProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceProvider</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boot</span><span class="hljs-params">()</span>
    </span>{
        Relation::morphMap([
            <span class="hljs-string">'post'</span> =&gt; <span class="hljs-string">'App\Models\Post'</span>,
        ]);
    }
}
</div></code></pre>
<p>Now, when the Eloquent model is &quot;dehydrated&quot; (serialized), the original class name won't be exposed, only the &quot;post&quot; alias:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"model"</span>,
    <span class="hljs-attr">"class"</span>: <span class="hljs-string">"App\Models\Post"</span>, <span class="hljs-comment">// [tl! remove]</span>
    <span class="hljs-attr">"class"</span>: <span class="hljs-string">"post"</span>, <span class="hljs-comment">// [tl! add]</span>
    <span class="hljs-attr">"key"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">"relationships"</span>: []
}
</div></code></pre>
<h3 id="eloquent-constraints-arent-preserved-between-requests">Eloquent constraints aren't preserved between requests</h3>
<p>Typically, Livewire is able to preserve and recreate server-side properties between requests; however, there are certain scenarios where preserving values are impossible between requests.</p>
<p>For example, when storing Eloquent collections as Livewire properties, additional query constraints like <code>select(...)</code> will not be re-applied on subsequent requests.</p>
<p>To demonstrate, consider the following <code>ShowTodos</code> component with a <code>select()</code> constraint applied to the <code>Todos</code> Eloquent collection:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowTodos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $todos;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;todos = Auth::user()
            -&gt;todos()
            -&gt;select([<span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>]) <span class="hljs-comment">// [tl! highlight]</span>
            -&gt;get();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-todos'</span>);
    }
}
</div></code></pre>
<p>When this component is initially loaded, the <code>$todos</code> property will be set to an Eloquent collection of the user's todos; however, only the <code>title</code> and <code>content</code> fields of each row in the database will have been queried and loaded into each of the models.</p>
<p>When Livewire <em>hydrates</em> the JSON of this property back into PHP on a subsequent request, the select constraint will have been lost.</p>
<p>To ensure the integrity of Eloquent queries, we recommend that you use <a href="/docs/computed-properties">computed properties</a> instead of properties.</p>
<p>Computed properties are methods in your component marked with the <code>#[Computed]</code> attribute. They can be accessed as a dynamic property that isn't stored as part of the component's state but is instead evaluated on-the-fly.</p>
<p>Here's the above example re-written using a computed property:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowTodos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Computed] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todos</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> Auth::user()
            -&gt;todos()
            -&gt;select([<span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>])
            -&gt;get();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-todos'</span>);
    }
}
</div></code></pre>
<p>Here's how you would access these <em>todos</em> from the Blade view:</p>
<pre class="hljs"><code><div>&lt;ul&gt;
    @foreach ($this-&gt;todos as $todo)
        &lt;li&gt;{{ $todo }}&lt;/li&gt;
    @endforeach
&lt;/ul&gt;
</div></code></pre>
<p>Notice, inside your views, you can only access computed properties on the <code>$this</code> object like so: <code>$this-&gt;todos</code>.</p>
<p>You can also access <code>$todos</code> from inside your class. For example, if you had a <code>markAllAsComplete()</code> action:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Computed</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowTodos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Computed]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todos</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> Auth::user()
            -&gt;todos()
            -&gt;select([<span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>])
            -&gt;get();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markAllComplete</span><span class="hljs-params">()</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:3]
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;todos-&gt;each-&gt;complete();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-todos'</span>);
    }
}
</div></code></pre>
<p>You might wonder why not just call <code>$this-&gt;todos()</code> as a method directly where you need to? Why use <code>#[Computed]</code> in the first place?</p>
<p>The reason is that computed properties have a performance advantage, since they are automatically cached after their first usage during a single request. This means you can freely access <code>$this-&gt;todos</code> within your component and be assured that the actual method will only be called once, so that you don't run an expensive query multiple times in the same request.</p>
<p>For more information, <a href="/docs/computed-properties">visit the computed properties documentation</a>.</p>
<pre class="hljs"><code><div>
## File: quickstart.md
```md

To begin your Livewire journey, we will create a simple &quot;counter&quot; component and render it in the browser. This example is a great way to experience Livewire for the first time as it demonstrates Livewire's _liveness_ in the simplest way possible.

## Prerequisites

Before we start, make sure you have the following installed:

- Laravel version 10 or later
- PHP version 8.1 or later

## Install Livewire

From the root directory of your Laravel app, run the following [Composer](https://getcomposer.org/) command:

```shell
composer require livewire/livewire
</div></code></pre>
<blockquote>
<p>[!warning] Make sure Alpine isn't already installed
If the application you are using already has AlpineJS installed, you will need to remove it for Livewire to work properly; otherwise, Alpine will be loaded twice and Livewire won't function. For example, if you installed the Laravel Breeze &quot;Blade with Alpine&quot; starter kit, you will need to remove Alpine from <code>resources/js/app.js</code>.</p>
</blockquote>
<h2 id="create-a-livewire-component">Create a Livewire component</h2>
<p>Livewire provides a convenient Artisan command to generate new components quickly. Run the following command to make a new <code>Counter</code> component:</p>
<pre class="hljs"><code><div>php artisan make:livewire counter
</div></code></pre>
<p>This command will generate two new files in your project:</p>
<ul>
<li><code>app/Livewire/Counter.php</code></li>
<li><code>resources/views/livewire/counter.blade.php</code></li>
</ul>
<h2 id="writing-the-class">Writing the class</h2>
<p>Open <code>app/Livewire/Counter.php</code> and replace its contents with the following:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $count = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;count++;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;count--;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.counter'</span>);
    }
}
</div></code></pre>
<p>Here's a brief explanation of the code above:</p>
<ul>
<li><code>public $count = 1;</code> — Declares a public property named <code>$count</code> with an initial value of <code>1</code>.</li>
<li><code>public function increment()</code> — Declares a public method named <code>increment()</code> that increments the <code>$count</code> property each time it's called. Public methods like this can be triggered from the browser in a variety of ways, including when a user clicks a button.</li>
<li><code>public function render()</code> — Declares a <code>render()</code> method that returns a Blade view. This Blade view will contain the HTML template for our component.</li>
</ul>
<h2 id="writing-the-view">Writing the view</h2>
<p>Open the <code>resources/views/livewire/counter.blade.php</code> file and replace its content with the following:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;{{ $count }}&lt;/h1&gt;

    &lt;button wire:click=&quot;increment&quot;&gt;+&lt;/button&gt;

    &lt;button wire:click=&quot;decrement&quot;&gt;-&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>This code will display the value of the <code>$count</code> property and two buttons that increment and decrement the <code>$count</code> property, respectively.</p>
<blockquote>
<p>[!warning] Livewire components MUST have a single root element
In order for Livewire to work, components must have just <strong>one</strong> single element as its root. If multiple root elements are detected, an exception is thrown. It is recommended to use a <code>&lt;div&gt;</code> element as in the example. HTML comments count as separate elements and should be put inside the root element.
When rendering <a href="/docs/components#full-page-components">full-page components</a>, named slots for the layout file may be put outside the root element. These are removed before the component is rendered.</p>
</blockquote>
<h2 id="register-a-route-for-the-component">Register a route for the component</h2>
<p>Open the <code>routes/web.php</code> file in your Laravel application and add the following code:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Counter</span>;

Route::get(<span class="hljs-string">'/counter'</span>, Counter::class);
</div></code></pre>
<p>Now, our <em>counter</em> component is assigned to the <code>/counter</code> route, so that when a user visits the <code>/counter</code> endpoint in your application, this component will be rendered by the browser.</p>
<h2 id="create-a-template-layout">Create a template layout</h2>
<p>Before you can visit <code>/counter</code> in the browser, we need an HTML layout for our component to render inside. By default, Livewire will automatically look for a layout file named: <code>resources/views/components/layouts/app.blade.php</code></p>
<p>You may create this file if it doesn't already exist by running the following command:</p>
<pre class="hljs"><code><div>php artisan livewire:layout
</div></code></pre>
<p>This command will generate a file called <code>resources/views/components/layouts/app.blade.php</code> with the following contents:</p>
<pre class="hljs"><code><div>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;{{ str_replace('_', '-', app()-&gt;getLocale()) }}&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;

        &lt;title&gt;{{ $title ?? 'Page Title' }}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        {{ $slot }}
    &lt;/body&gt;
&lt;/html&gt;
</div></code></pre>
<p>The <em>counter</em> component will be rendered in place of the <code>$slot</code> variable in the template above.</p>
<p>You may have noticed there is no JavaScript or CSS assets provided by Livewire. That is because Livewire 3 and above automatically injects any frontend assets it needs.</p>
<h2 id="test-it-out">Test it out</h2>
<p>With our component class and templates in place, our component is ready to test!</p>
<p>Visit <code>/counter</code> in your browser, and you should see a number displayed on the screen with two buttons to increment and decrement the number.</p>
<p>After clicking one of the buttons, you will notice that the count updates in real time, without the page reloading. This is the magic of Livewire: dynamic frontend applications written entirely in PHP.</p>
<p>We've barely scratched the surface of what Livewire is capable of. Keep reading the documentation to see everything Livewire has to offer.</p>
<pre class="hljs"><code><div>
## File: redirecting.md
```md
After a user performs some action — like submitting a form — you may want to redirect them to another page in your application.

Because Livewire requests aren't standard full-page browser requests, standard HTTP redirects won't work. Instead, you need to trigger redirects via JavaScript. Fortunately, Livewire exposes a simple `$this-&gt;redirect()` helper method to use within your components. Internally, Livewire will handle the process of redirecting on the frontend.

If you prefer, you can use [Laravel's built-in redirect utilities](https://laravel.com/docs/responses#redirects) within your components as well.

## Basic usage

Below is an example of a `CreatePost` Livewire component that redirects the user to another page after they submit the form to create a post:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;
use App\Models\Post;

class CreatePost extends Component
{
	public $title = '';

    public $content = '';

    public function save()
    {
		Post::create([
			'title' =&gt; $this-&gt;title,
			'content' =&gt; $this-&gt;content,
		]);

		$this-&gt;redirect('/posts'); // [tl! highlight]
    }

    public function render()
    {
        return view('livewire.create-post');
    }
}
</div></code></pre>
<p>As you can see, when the <code>save</code> action is triggered, a redirect will also be triggered to <code>/posts</code>. When Livewire receives this response, it will redirect the user to the new URL on the frontend.</p>
<h2 id="redirect-to-route">Redirect to Route</h2>
<p>In case you want to redirect to a page using its route name you can use the <code>redirectRoute</code>.</p>
<p>For example, if you have a page with the route named <code>'profile'</code> like this:</p>
<pre class="hljs"><code><div>    Route::get(<span class="hljs-string">'/user/profile'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// ...</span>
    })-&gt;name(<span class="hljs-string">'profile'</span>);
</div></code></pre>
<p>You can use <code>redirectRoute</code> to redirect to that page using the name of the route like so:</p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">$this</span>-&gt;redirectRoute(<span class="hljs-string">'profile'</span>);
</div></code></pre>
<p>In case you need to pass parameters to the route you may use the second argument of the method <code>redirectRoute</code> like so:</p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">$this</span>-&gt;redirectRoute(<span class="hljs-string">'profile'</span>, [<span class="hljs-string">'id'</span> =&gt; <span class="hljs-number">1</span>]);
</div></code></pre>
<h2 id="redirect-to-intended">Redirect to intended</h2>
<p>In case you want to redirect the user back to the previous page they were on you can use <code>redirectIntended</code>. It accepts an optional default URL as its first argument which is used as a fallback if no previous page can be determined:</p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">$this</span>-&gt;redirectIntended(<span class="hljs-string">'/default/url'</span>);
</div></code></pre>
<h2 id="redirecting-to-full-page-components">Redirecting to full-page components</h2>
<p>Because Livewire uses Laravel's built-in redirection feature, you can use all of the redirection methods available to you in a typical Laravel application.</p>
<p>For example, if you are using a Livewire component as a full-page component for a route like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">ShowPosts</span>;

Route::get(<span class="hljs-string">'/posts'</span>, ShowPosts::class);
</div></code></pre>
<p>You can redirect to the component by providing the component name to the <code>redirect()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">$this</span>-&gt;redirect(ShowPage::class);
}
</div></code></pre>
<h2 id="flash-messages">Flash messages</h2>
<p>In addition to allowing you to use Laravel's built-in redirection methods, Livewire also supports Laravel's <a href="https://laravel.com/docs/session#flash-data">session flash data utilities</a>.</p>
<p>To pass flash data along with a redirect, you can use Laravel's <code>session()-&gt;flash()</code> method like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// ...</span>

        session()-&gt;flash(<span class="hljs-string">'status'</span>, <span class="hljs-string">'Post successfully updated.'</span>);

        <span class="hljs-keyword">$this</span>-&gt;redirect(<span class="hljs-string">'/posts'</span>);
    }
}
</div></code></pre>
<p>Assuming the page being redirected to contains the following Blade snippet, the user will see a &quot;Post successfully updated.&quot; message after updating the post:</p>
<pre class="hljs"><code><div>@if (session('status'))
    &lt;div class=&quot;alert alert-success&quot;&gt;
        {{ session('status') }}
    &lt;/div&gt;
@endif
</div></code></pre>
<pre class="hljs"><code><div>
## File: security.md
```md
It's important to make sure your Livewire apps are secure and don't expose any application vulnerabilities. Livewire has internal security features to handle many cases, however, there are times when it's up to your application code to keep your components secure.

## Authorizing action parameters

Livewire actions are extremely powerful, however, any parameters passed to Livewire actions are mutable on the client and should be treated as un-trusted user input.

Arguably the most common security pitfall in Livewire is failing to validate and authorize Livewire action calls before persisting changes to the database.

Here is an example of an insecurity resulting from a lack of authorization:

```php
&lt;?php

use App\Models\Post;
use Livewire\Component;

class ShowPost extends Component
{
    // ...

    public function delete($id)
    {
        // INSECURE!

        $post = Post::find($id);

        $post-&gt;delete();
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"delete({{ $post-&gt;id }})"</span>&gt;</span>Delete Post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>The reason the above example is insecure is that <code>wire:click=&quot;delete(...)&quot;</code> can be modified in the browser to pass ANY post ID a malicious user wishes.</p>
<p>Action parameters (like <code>$id</code> in this case) should be treated the same as any untrusted input from the browser.</p>
<p>Therefore, to keep this application secure and prevent a user from deleting another user's post, we must add authorization to the <code>delete()</code> action.</p>
<p>First, let's create a <a href="https://laravel.com/docs/authorization#creating-policies">Laravel Policy</a> for the Post model by running the following command:</p>
<pre class="hljs"><code><div>php artisan make:policy PostPolicy --model=Post
</div></code></pre>
<p>After running the above command, a new Policy will be created inside <code>app/Policies/PostPolicy.php</code>. We can then update its contents with a <code>delete</code> method like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Policies</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostPolicy</span>
</span>{
    <span class="hljs-comment">/**
     * Determine if the given post can be deleted by the user.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">(?User $user, Post $post)</span>: <span class="hljs-title">bool</span>
    </span>{
        <span class="hljs-keyword">return</span> $user?-&gt;id === $post-&gt;user_id;
    }
}
</div></code></pre>
<p>Before you can use the new Policy, you need to register it inside <code>app\Providers\AuthServiceProvider.php</code>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// ...</span>

<span class="hljs-keyword">protected</span> $policies = [
    Post::class =&gt; PostPolicy::class,
];

<span class="hljs-comment">// ...</span>
</div></code></pre>
<p>Now, we can use the <code>$this-&gt;authorize()</code> method from the Livewire component to ensure the user owns the post before deleting it:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">($id)</span>
</span>{
    $post = Post::find($id);

    <span class="hljs-comment">// If the user doesn't own the post,</span>
    <span class="hljs-comment">// an AuthorizationException will be thrown...</span>
    <span class="hljs-keyword">$this</span>-&gt;authorize(<span class="hljs-string">'delete'</span>, $post); <span class="hljs-comment">// [tl! highlight]</span>

    $post-&gt;delete();
}
</div></code></pre>
<p>Further reading:</p>
<ul>
<li><a href="https://laravel.com/docs/authorization#gates">Laravel Gates</a></li>
<li><a href="https://laravel.com/docs/authorization#creating-policies">Laravel Policies</a></li>
</ul>
<h2 id="authorizing-public-properties">Authorizing public properties</h2>
<p>Similar to action parameters, public properties in Livewire should be treated as un-trusted input from the user.</p>
<p>Here is the same example from above about deleting a post, written insecurely in a different manner:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $postId;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($postId)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;postId = $postId;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// INSECURE!</span>

        $post = Post::find(<span class="hljs-keyword">$this</span>-&gt;postId);

        $post-&gt;delete();
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"delete"</span>&gt;</span>Delete Post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>As you can see, instead of passing the <code>$postId</code> as a parameter to the <code>delete</code> method from <code>wire:click</code>, we are storing it as a public property on the Livewire component.</p>
<p>The problem with this approach is that any malicious user can inject a custom element onto the page such as:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"postId"</span>&gt;</span>
</div></code></pre>
<p>This would allow them to freely modify the <code>$postId</code> before pressing &quot;Delete Post&quot;. Because the <code>delete</code> action doesn't authorize the value of <code>$postId</code>, the user can now delete any post in the database, whether they own it or not.</p>
<p>To protect against this risk, there are two possible solutions:</p>
<h3 id="using-model-properties">Using model properties</h3>
<p>When setting public properties, Livewire treats models differently than plain values such as strings and integers. Because of this, if we instead store the entire post model as a property on the component, Livewire will ensure the ID is never tampered with.</p>
<p>Here is an example of storing a <code>$post</code> property instead of a simple <code>$postId</code> property:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($postId)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post = Post::find($postId);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post-&gt;delete();
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"delete"</span>&gt;</span>Delete Post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>This component is now secured because there is no way for a malicious user to change the <code>$post</code> property to a different Eloquent model.</p>
<h3 id="locking-the-property">Locking the property</h3>
<p>Another way to prevent properties from being set to unwanted values is to use <a href="https://livewire.laravel.com/docs/locked">locked properties</a>. Locking properties is done by applying the <code>#[Locked]</code> attribute. Now if users attempt to tamper with this value an error will be thrown.</p>
<p>Note that properties with the Locked attribute can still be changed in the back-end, so care still needs to taken that untrusted user input is not passed to the property in your own Livewire functions.</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Locked</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Locked] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $postId;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($postId)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;postId = $postId;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span>
    </span>{
        $post = Post::find(<span class="hljs-keyword">$this</span>-&gt;postId);

        $post-&gt;delete();
    }
}
</div></code></pre>
<h3 id="authorizing-the-property">Authorizing the property</h3>
<p>If using a model property is undesired in your scenario, you can of course fall-back to manually authorizing the deletion of the post inside the <code>delete</code> action:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $postId;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">($postId)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;postId = $postId;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span>
    </span>{
        $post = Post::find(<span class="hljs-keyword">$this</span>-&gt;postId);

        <span class="hljs-keyword">$this</span>-&gt;authorize(<span class="hljs-string">'delete'</span>, $post); <span class="hljs-comment">// [tl! highlight]</span>

        $post-&gt;delete();
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"delete"</span>&gt;</span>Delete Post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>Now, even though a malicious user can still freely modify the value of <code>$postId</code>, when the <code>delete</code> action is called, <code>$this-&gt;authorize()</code> will throw an <code>AuthorizationException</code> if the user does not own the post.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://laravel.com/docs/authorization#gates">Laravel Gates</a></li>
<li><a href="https://laravel.com/docs/authorization#creating-policies">Laravel Policies</a></li>
</ul>
<h2 id="middleware">Middleware</h2>
<p>When a Livewire component is loaded on a page containing route-level <a href="https://laravel.com/docs/authorization#via-middleware">Authorization Middleware</a>, like so:</p>
<pre class="hljs"><code><div>Route::get(<span class="hljs-string">'/post/{post}'</span>, App\Livewire\UpdatePost::class)
    -&gt;middleware(<span class="hljs-string">'can:update,post'</span>); <span class="hljs-comment">// [tl! highlight]</span>
</div></code></pre>
<p>Livewire will ensure those middlewares are re-applied to subsequent Livewire network requests. This is referred to as &quot;Persistent Middleware&quot; in Livewire's core.</p>
<p>Persistent middleware protects you from scenarios where the authorization rules or user permissions have changed after the initial page-load.</p>
<p>Here's a more in-depth example of such a scenario:</p>
<pre class="hljs"><code><div>Route::get(<span class="hljs-string">'/post/{post}'</span>, App\Livewire\UpdatePost::class)
    -&gt;middleware(<span class="hljs-string">'can:update,post'</span>); <span class="hljs-comment">// [tl! highlight]</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-comment">#[Validate('required|min:5')]</span>
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;title = <span class="hljs-keyword">$this</span>-&gt;post-&gt;title;
        <span class="hljs-keyword">$this</span>-&gt;content = <span class="hljs-keyword">$this</span>-&gt;post-&gt;content;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;post-&gt;update([
            <span class="hljs-string">'title'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;title,
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;content,
        ]);
    }
}
</div></code></pre>
<p>As you can see, the <code>can:update,post</code> middleware is applied at the route-level. This means that a user who doesn't have permission to update a post cannot view the page.</p>
<p>However, consider a scenario where a user:</p>
<ul>
<li>Loads the page</li>
<li>Loses permission to update after the page loads</li>
<li>Tries updating the post after losing permission</li>
</ul>
<p>Because Livewire has already successfully loaded the page you might ask yourself: &quot;When Livewire makes a subsequent request to update the post, will the <code>can:update,post</code> middleware be re-applied? Or instead, will the un-authorized user be able to update the post successfully?&quot;</p>
<p>Because Livewire has internal mechanisms to re-apply middleware from the original endpoint, you are protected in this scenario.</p>
<h3 id="configuring-persistent-middleware">Configuring persistent middleware</h3>
<p>By default, Livewire persists the following middleware across network requests:</p>
<pre class="hljs"><code><div>\Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
\Laravel\Jetstream\Http\Middleware\AuthenticateSession::class,
\Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
\Illuminate\Routing\Middleware\SubstituteBindings::class,
\App\Http\Middleware\RedirectIfAuthenticated::class,
\Illuminate\Auth\Middleware\Authenticate::class,
\Illuminate\Auth\Middleware\Authorize::class,
\App\Http\Middleware\Authenticate::class,
</div></code></pre>
<p>If any of the above middlewares are applied to the initial page-load, they will be persisted (re-applied) to any future network requests.</p>
<p>However, if you are applying a custom middleware from your application the initial page-load, and want it persisted between Livewire requests, you will need to add it to this list from a <a href="https://laravel.com/docs/providers#main-content">Service Provider</a> in your app like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Providers</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">ServiceProvider</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppServiceProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceProvider</span>
</span>{
    <span class="hljs-comment">/**
     * Bootstrap any application services.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boot</span><span class="hljs-params">()</span>: <span class="hljs-title">void</span>
    </span>{
        Livewire::addPersistentMiddleware([ <span class="hljs-comment">// [tl! highlight:2]</span>
            App\Http\Middleware\EnsureUserHasRole::class,
        ]);
    }
}
</div></code></pre>
<p>If a Livewire component is loaded on a page that uses the <code>EnsureUserHasRole</code> middleware from your application, it will now be persisted and re-applied to any future network requests to that Livewire component.</p>
<blockquote>
<p>[!warning] Middleware arguments are not supported
Livewire currently doesn't support middleware arguments for persistent middleware definitions.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Bad...</span>
Livewire::addPersistentMiddleware(AuthorizeResource::class.<span class="hljs-string">':admin'</span>);

<span class="hljs-comment">// Good...</span>
Livewire::addPersistentMiddleware(AuthorizeResource::class);
</div></code></pre>
</blockquote>
<h3 id="applying-global-livewire-middleware">Applying global Livewire middleware</h3>
<p>Alternatively, if you wish to apply specific middleware to every single Livewire update network request, you can do so by registering your own Livewire update route with any middleware you wish:</p>
<pre class="hljs"><code><div>Livewire::setUpdateRoute(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($handle)</span> </span>{
	<span class="hljs-keyword">return</span> Route::post(<span class="hljs-string">'/livewire/update'</span>, $handle)
        -&gt;middleware(App\Http\Middleware\LocalizeViewPaths::class);
});
</div></code></pre>
<p>Any Livewire AJAX/fetch requests made to the server will use the above endpoint and apply the <code>LocalizeViewPaths</code> middleware before handling the component update.</p>
<p>Learn more about <a href="https://livewire.laravel.com/docs/installation#configuring-livewires-update-endpoint">customizing the update route on the Installation page</a>.</p>
<h2 id="snapshot-checksums">Snapshot checksums</h2>
<p>Between every Livewire request, a snapshot is taken of the Livewire component and sent to the browser. This snapshot is used to re-build the component during the next server round-trip.</p>
<p><a href="https://livewire.laravel.com/docs/hydration#the-snapshot">Learn more about Livewire snapshots in the Hydration documentation.</a></p>
<p>Because fetch requests can be intercepted and tampered with in a browser, Livewire generates a &quot;checksum&quot; of each snapshot to go along with it.</p>
<p>This checksum is then used on the next network request to verify that the snapshot hasn't changed in any way.</p>
<p>If Livewire finds a checksum mismatch, it will throw a <code>CorruptComponentPayloadException</code> and the request will fail.</p>
<p>This protects against any form of malicious tampering that would otherwise result in granting users the ability to execute or modify unrelated code.</p>
<pre class="hljs"><code><div>
## File: session-properties.md
```md

Livewire makes it easy to persist property values across page refreshes/changes using the `#[Session]` attribute.

By adding `#[Session]` to a property in your component, Livewire will store that property's value in the session every time it changes. This way, when a page is refreshed, Livewire will fetch the latest value from the session and use it in your component.

The `#[Session]` attribute is analogous to the [`#[Url]`](/docs/url) attribute. They are both useful in similar scenarios. The primary difference being `#[Session]` persists values without modifying the URL's query string, which is sometimes desired; sometimes not.

## Basic usage

Here's a `ShowPosts` component that allows users to filter visible posts by a string stored in a `$search` property:

```php
&lt;?php

use Livewire\Attributes\Session;
use Livewire\Component;
use App\Models\Post;

class ShowPosts extends Component
{
    #[Session] // [tl! highlight]
    public $search;

    protected function posts()
    {
        return $this-&gt;search === ''
            ? Post::all()
            : Post::where('title', 'like', '%'.$this-&gt;search.'%');
    }

    public function render()
    {
        return view('livewire.show-posts', [
            'posts' =&gt; $this-&gt;posts(),
        ]);
    }
}
</div></code></pre>
<p>Because the <code>#[Session]</code> attribute has been added to the <code>$search</code> property, after a user enters a search value, they can refresh the page and the search value will be persisted. Every time <code>$search</code> is updated, its new value will be stored in the user's session and used across page loads.</p>
<blockquote>
<p>[!warning] Performance implications
Because Laravel sessions are loaded into memory during every request, you can slow down the performance of your entire application for a given user by storing too much in a user's session.</p>
</blockquote>
<h2 id="setting-a-custom-key">Setting a custom key</h2>
<p>When using <code>[#Session]</code>, Livewire will store the property value in the session using a dynamically generated key that consists of the component name combined with the property name.</p>
<p>This ensures that properties across component instances will use the same session value. It also ensures properties of the same name from different components won't conflict.</p>
<p>If you want full control over what session key Livewire uses for a given property, you can pass the <code>key:</code> parameter:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Session</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Session(key: 'search')] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $search;

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>When Livewire stores and retrieves the value of the <code>$search</code> property, it will use the given key: &quot;search&quot;.</p>
<p>Additionally, if you want to generate the key dynamically from other properties in your component, you can do so using the following curly brace notation:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Session</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Author</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Author $author;

    <span class="hljs-comment">#[Session(key: 'search-{author.id}')] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $search;

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>In the above example, if the <code>$author</code> model's id is &quot;4&quot;, the session key will become: <code>search-4</code></p>
<pre class="hljs"><code><div>
## File: synthesizers.md
```md

Because Livewire components are dehydrated (serialized) into JSON, then hydrated (unserialized) back into PHP components between requests, their properties need to be JSON-serializable.

Natively, PHP serializes most primitive values into JSON easily. However, in order for Livewire components to support more sophisticated property types (like models, collections, carbon instances, and stringables), a more robust system is needed.

Therefore, Livewire provides a point of extension called &quot;Synthesizers&quot; that allow users to support any custom property types they wish.

&gt; [!tip] Make sure you understand hydration first
&gt; Before using Synthesizers, it's helpful to fully understand Livewire's hydration system. You can learn more by reading the [hydration documentation](/docs/hydration).

## Understanding Synthesizers

Before exploring the creation of custom Synthesizers, let's first look at the internal Synthesizer that Livewire uses to support [Laravel Stringables](https://laravel.com/docs/strings).

Suppose your application contained the following `CreatePost` component:

```php
class CreatePost extends Component
{
    public $title = '';
}
</div></code></pre>
<p>Between requests, Livewire might serialize this component's state into a JSON object like the following:</p>
<pre class="hljs"><code><div>state: { <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> },
</div></code></pre>
<p>Now, consider a more advanced example where the <code>$title</code> property value is a stringable instead of a plain string:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;title = str(<span class="hljs-keyword">$this</span>-&gt;title);
    }
}
</div></code></pre>
<p>The dehydrated JSON representing this component's state now contains a <a href="/docs/hydration#deeply-nested-tuples">metadata tuple</a> instead of a plain empty string:</p>
<pre class="hljs"><code><div>state: { <span class="hljs-attr">title</span>: [<span class="hljs-string">''</span>, { <span class="hljs-attr">s</span>: <span class="hljs-string">'str'</span> }] },
</div></code></pre>
<p>Livewire can now use this tuple to hydrate the <code>$title</code> property back into a stringable on the next request.</p>
<p>Now that you've seen the outside-in effects of Synthesizers, here is the actual source code for Livewire's internal stringable synth:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Stringable</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringableSynth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Synth</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> $key = <span class="hljs-string">'str'</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span><span class="hljs-params">($target)</span>
    </span>{
        <span class="hljs-keyword">return</span> $target <span class="hljs-keyword">instanceof</span> Stringable;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dehydrate</span><span class="hljs-params">($target)</span>
    </span>{
        <span class="hljs-keyword">return</span> [$target-&gt;__toString(), []];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hydrate</span><span class="hljs-params">($value)</span>
    </span>{
        <span class="hljs-keyword">return</span> str($value);
    }
}
</div></code></pre>
<p>Let's break this down piece by piece.</p>
<p>First is the <code>$key</code> property:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> $key = <span class="hljs-string">'str'</span>;
</div></code></pre>
<p>Every synth must contain a static <code>$key</code> property that Livewire uses to convert a <a href="/docs/hydration#deeply-nested-tuples">metadata tuple</a> like <code>['', { s: 'str' }]</code> back into a stringable. As you may notice, each metadata tuple has an <code>s</code> key referencing this key.</p>
<p>Inversely, when Livewire is dehydrating a property, it will use the synth's static <code>match()</code> function to identify if this particular Synthesizer is a good candidate to dehydrate the current property (<code>$target</code> being the current value of the property):</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span><span class="hljs-params">($target)</span>
</span>{
    <span class="hljs-keyword">return</span> $target <span class="hljs-keyword">instanceof</span> Stringable;
}
</div></code></pre>
<p>If <code>match()</code> returns true, the <code>dehydrate()</code> method will be used to take the property's PHP value as input and return the JSONable <a href="/docs/hydration#deeply-nested-tuples">metadata</a> tuple:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dehydrate</span><span class="hljs-params">($target)</span>
</span>{
    <span class="hljs-keyword">return</span> [$target-&gt;__toString(), []];
}
</div></code></pre>
<p>Now, at the beginning of the next request, after this Synthesizer has been matched by the <code>{ s: 'str' }</code> key in the tuple, the <code>hydrate()</code> method will be called and passed the raw JSON representation of the property with the expectation that it returns the full PHP-compatible value to be assigned to the property.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hydrate</span><span class="hljs-params">($value)</span>
</span>{
    <span class="hljs-keyword">return</span> str($value);
}
</div></code></pre>
<h2 id="registering-a-custom-synthesizer">Registering a custom Synthesizer</h2>
<p>To demonstrate how you might author your own Synthesizer to support a custom property, we will use the following <code>UpdateProperty</code> component as an example:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdateProperty</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Address $address;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;address = <span class="hljs-keyword">new</span> Address();
    }
}
</div></code></pre>
<p>Here's the source for the <code>Address</code> class:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Dtos</span>\<span class="hljs-title">Address</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>
</span>{
    <span class="hljs-keyword">public</span> $street = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">public</span> $city = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">public</span> $state = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">public</span> $zip = <span class="hljs-string">''</span>;
}
</div></code></pre>
<p>To support properties of type <code>Address</code>, we can use the following Synthesizer:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Dtos</span>\<span class="hljs-title">Address</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddressSynth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Synth</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> $key = <span class="hljs-string">'address'</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span><span class="hljs-params">($target)</span>
    </span>{
        <span class="hljs-keyword">return</span> $target <span class="hljs-keyword">instanceof</span> Address;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dehydrate</span><span class="hljs-params">($target)</span>
    </span>{
        <span class="hljs-keyword">return</span> [[
            <span class="hljs-string">'street'</span> =&gt; $target-&gt;street,
            <span class="hljs-string">'city'</span> =&gt; $target-&gt;city,
            <span class="hljs-string">'state'</span> =&gt; $target-&gt;state,
            <span class="hljs-string">'zip'</span> =&gt; $target-&gt;zip,
        ], []];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hydrate</span><span class="hljs-params">($value)</span>
    </span>{
        $instance = <span class="hljs-keyword">new</span> Address;

        $instance-&gt;street = $value[<span class="hljs-string">'street'</span>];
        $instance-&gt;city = $value[<span class="hljs-string">'city'</span>];
        $instance-&gt;state = $value[<span class="hljs-string">'state'</span>];
        $instance-&gt;zip = $value[<span class="hljs-string">'zip'</span>];

        <span class="hljs-keyword">return</span> $instance;
    }
}
</div></code></pre>
<p>To make it available globally in your application, you can use Livewire's <code>propertySynthesizer</code> method to register the synthesizer from your service provider boot method:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppServiceProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceProvider</span>
</span>{
    <span class="hljs-comment">/**
     * Bootstrap any application services.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boot</span><span class="hljs-params">()</span>: <span class="hljs-title">void</span>
    </span>{
        Livewire::propertySynthesizer(AddressSynth::class);
    }
}
</div></code></pre>
<h2 id="supporting-data-binding">Supporting data binding</h2>
<p>Using the <code>UpdateProperty</code> example from above, it is likely that you would want to support <code>wire:model</code> binding directly to properties of the <code>Address</code> object. Synthesizers allow you to support this using the <code>get()</code> and <code>set()</code> methods:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Dtos</span>\<span class="hljs-title">Address</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddressSynth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Synth</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> $key = <span class="hljs-string">'address'</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span><span class="hljs-params">($target)</span>
    </span>{
        <span class="hljs-keyword">return</span> $target <span class="hljs-keyword">instanceof</span> Address;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dehydrate</span><span class="hljs-params">($target)</span>
    </span>{
        <span class="hljs-keyword">return</span> [[
            <span class="hljs-string">'street'</span> =&gt; $target-&gt;street,
            <span class="hljs-string">'city'</span> =&gt; $target-&gt;city,
            <span class="hljs-string">'state'</span> =&gt; $target-&gt;state,
            <span class="hljs-string">'zip'</span> =&gt; $target-&gt;zip,
        ], []];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hydrate</span><span class="hljs-params">($value)</span>
    </span>{
        $instance = <span class="hljs-keyword">new</span> Address;

        $instance-&gt;street = $value[<span class="hljs-string">'street'</span>];
        $instance-&gt;city = $value[<span class="hljs-string">'city'</span>];
        $instance-&gt;state = $value[<span class="hljs-string">'state'</span>];
        $instance-&gt;zip = $value[<span class="hljs-string">'zip'</span>];

        <span class="hljs-keyword">return</span> $instance;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span><span class="hljs-params">(&amp;$target, $key)</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:8]
    </span>{
        <span class="hljs-keyword">return</span> $target-&gt;{$key};
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span><span class="hljs-params">(&amp;$target, $key, $value)</span>
    </span>{
        $target-&gt;{$key} = $value;
    }
}
</div></code></pre>
<pre class="hljs"><code><div>
## File: teleport.md
```md
Livewire allows you to _teleport_ part of your template to another part of the DOM on the page entirely.

This is useful for things like nested dialogs. When nesting one dialog inside of another, the z-index of the parent modal is applied to the nested modal. This can cause problems with styling backdrops and overlays. To avoid this problem, you can use Livewire's `@teleport` directive to render each nested modal as siblings in the rendered DOM.

This functionality is powered by [Alpine's `x-teleport` directive](https://alpinejs.dev/directives/teleport).

## Basic usage

To _teleport_ a portion of your template to another part of the DOM, you can wrap it in Livewire's `@teleport` directive.

Below is an example of using `@teleport` to render a modal dialog's contents at the end of the `&lt;body&gt;` element on the page:

```blade
&lt;div&gt;
    &lt;!-- Modal --&gt;
    &lt;div x-data=&quot;{ open: false }&quot;&gt;
        &lt;button @click=&quot;open = ! open&quot;&gt;Toggle Modal&lt;/button&gt;

        @teleport('body')
            &lt;div x-show=&quot;open&quot;&gt;
                Modal contents...
            &lt;/div&gt;
        @endteleport
    &lt;/div&gt;
&lt;/div&gt;
</div></code></pre>
<blockquote>
<p>[!info]
The <code>@teleport</code> selector can be any string you would normally pass into something like <code>document.querySelector()</code>.</p>
<p>You can learn more about <code>document.querySelector()</code> by consulting its <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector">MDN documentation</a>.</p>
</blockquote>
<p>Now, when the above Livewire template is rendered on the page, the <em>contents</em> portion of the modal will be rendered at the end of <code>&lt;body&gt;</code>:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- ... --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">x-show</span>=<span class="hljs-string">"open"</span>&gt;</span>
        Modal contents...
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</div></code></pre>
<blockquote>
<p>[!warning] You must teleport outside the component
Livewire only supports teleporting HTML outside your components. For example, teleporting a modal to the <code>&lt;body&gt;</code> tag is fine, but teleporting it to another element within your component will not work.</p>
</blockquote>
<blockquote>
<p>[!warning] Teleporting only works with a single root element
Make sure you only include a single root element inside your <code>@teleport</code> statement.</p>
</blockquote>
<pre class="hljs"><code><div>
## File: testing.md
```md

## Creating your first test

By appending the `--test` flag to the `make:livewire` command, you can generate a test file along with a component:

```shell
php artisan make:livewire create-post --test
</div></code></pre>
<p>In addition to generating the component files themselves, the above command will generate the following test file <code>tests/Feature/Livewire/CreatePostTest.php</code>:</p>
<p>If you would like to create a <a href="https://pestphp.com/">Pest PHP</a> test, you may provide the <code>--pest</code> option to the make:livewire command:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renders_successfully</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(CreatePost::class)
            -&gt;assertStatus(<span class="hljs-number">200</span>);
    }
}
</div></code></pre>
<p>Of course, you can always create these files by hand or even use Livewire's testing utilities inside any other existing PHPUnit test in your Laravel application.</p>
<p>Before reading further, you may wish to familiarize yourself with <a href="https://laravel.com/docs/testing">Laravel's own built-in testing features</a>.</p>
<h2 id="testing-a-page-contains-a-component">Testing a page contains a component</h2>
<p>The simplest Livewire test you can write is asserting that a given endpoint in your application includes and successfully renders a given Livewire component.</p>
<p>Livewire provides an <code>assertSeeLivewire()</code> method that can be used from any Laravel test:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">component_exists_on_the_page</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;get(<span class="hljs-string">'/posts/create'</span>)
            -&gt;assertSeeLivewire(CreatePost::class);
    }
}
</div></code></pre>
<blockquote>
<p>[!tip] These are called smoke tests
Smoke tests are broad tests that ensure there are no catastrophic problems in your application. Although it may seem like a test that isn't worth writing, pound for pound, these are some of the most valuable tests you can write as they require very little maintenance and provide you a base level of confidence that your application will render successfully with no major errors.</p>
</blockquote>
<h2 id="testing-views">Testing views</h2>
<p>Livewire provides a simple yet powerful utility for asserting the existence of text in the component's rendered output: <code>assertSee()</code>.</p>
<p>Below is an example of using <code>assertSee()</code> to ensure that all posts in the database are displayed on the page:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">ShowPosts</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPostsTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displays_posts</span><span class="hljs-params">()</span>
    </span>{
        Post::factory()-&gt;make([<span class="hljs-string">'title'</span> =&gt; <span class="hljs-string">'On bathing well'</span>]);
        Post::factory()-&gt;make([<span class="hljs-string">'title'</span> =&gt; <span class="hljs-string">'There\'s no time like bathtime'</span>]);

        Livewire::test(ShowPosts::class)
            -&gt;assertSee(<span class="hljs-string">'On bathing well'</span>)
            -&gt;assertSee(<span class="hljs-string">'There\'s no time like bathtime'</span>);
    }
}
</div></code></pre>
<h3 id="asserting-data-from-the-view">Asserting data from the view</h3>
<p>In addition to asserting the output of a rendered view, sometimes it's helpful to test the data being passed into the view.</p>
<p>Here's the same test as above, but testing the view data rather than the rendered output:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">ShowPosts</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPostsTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displays_all_posts</span><span class="hljs-params">()</span>
    </span>{
        Post::factory()-&gt;make([<span class="hljs-string">'title'</span> =&gt; <span class="hljs-string">'On bathing well'</span>]);
        Post::factory()-&gt;make([<span class="hljs-string">'title'</span> =&gt; <span class="hljs-string">'The bathtub is my sanctuary'</span>]);

        Livewire::test(ShowPosts::class)
            -&gt;assertViewHas(<span class="hljs-string">'posts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($posts)</span> </span>{
                <span class="hljs-keyword">return</span> count($posts) == <span class="hljs-number">2</span>;
            });
    }
}
</div></code></pre>
<p>As you can see, <code>assertViewHas()</code> provides control over what assertions you want to make against the specified data.</p>
<p>If you would rather make a simple assertion, such as ensuring a piece of view data matches a given value, you can pass the value directly as the second argument given to the <code>assertViewHas()</code> method.</p>
<p>For example, assuming you have a component with a variable named <code>$postCount</code> being passed into the view, you can make assertions against its literal value like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;assertViewHas(<span class="hljs-string">'postCount'</span>, <span class="hljs-number">3</span>)
</div></code></pre>
<h2 id="setting-the-authenticated-user">Setting the authenticated user</h2>
<p>Most web applications require users to log in before using them. Rather than manually authenticating a fake user at the beginning of your tests, Livewire provides an <code>actingAs()</code> method.</p>
<p>Below is an example of a test where multiple users have posts, yet the authenticated user should only be able to see their own posts:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">ShowPosts</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPostsTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">user_only_sees_their_own_posts</span><span class="hljs-params">()</span>
    </span>{
        $user = User::factory()
            -&gt;has(Post::factory()-&gt;count(<span class="hljs-number">3</span>))
            -&gt;create();

        $stranger = User::factory()
            -&gt;has(Post::factory()-&gt;count(<span class="hljs-number">2</span>))
            -&gt;create();

        Livewire::actingAs($user)
            -&gt;test(ShowPosts::class)
            -&gt;assertViewHas(<span class="hljs-string">'posts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($posts)</span> </span>{
                <span class="hljs-keyword">return</span> count($posts) == <span class="hljs-number">3</span>;
            });
    }
}
</div></code></pre>
<h2 id="testing-properties">Testing properties</h2>
<p>Livewire also provides helpful testing utilities for setting and asserting properties within your components.</p>
<p>Component properties are typically updated in your application when users interact with form inputs containing <code>wire:model</code>. But, because tests don't typically type into an actual browser, Livewire allows you to set properties directly using the <code>set()</code> method.</p>
<p>Below is an example of using <code>set()</code> to update the <code>$title</code> property of a <code>CreatePost</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">can_set_title</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(CreatePost::class)
            -&gt;set(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Confessions of a serial soaker'</span>)
            -&gt;assertSet(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Confessions of a serial soaker'</span>);
    }
}
</div></code></pre>
<h3 id="initializing-properties">Initializing properties</h3>
<p>Often, Livewire components receive data being passed in from a parent component or route parameters. Because Livewire components are tested in isolation, you can manually pass data into them using the second parameter of the <code>Livewire::test()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">UpdatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">title_field_is_populated</span><span class="hljs-params">()</span>
    </span>{
        $post = Post::factory()-&gt;make([
            <span class="hljs-string">'title'</span> =&gt; <span class="hljs-string">'Top ten bath bombs'</span>,
        ]);

        Livewire::test(UpdatePost::class, [<span class="hljs-string">'post'</span> =&gt; $post])
            -&gt;assertSet(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Top ten bath bombs'</span>);
    }
}
</div></code></pre>
<p>The underlying component being tested (<code>UpdatePost</code>) will receive <code>$post</code> through its <code>mount()</code> method. Let's look at the source for <code>UpdatePost</code> to paint a clearer picture of this feature:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

	<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">(Post $post)</span>
	</span>{
		<span class="hljs-keyword">$this</span>-&gt;post = $post;

		<span class="hljs-keyword">$this</span>-&gt;title = $post-&gt;title;
	}

	<span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h3 id="setting-url-parameters">Setting URL parameters</h3>
<p>If your Livewire component depends on specific query parameters in the URL of the page it's loaded on, you can use the <code>withQueryParams()</code> method to set the query parameters manually for your test.</p>
<p>Below is a basic <code>SearchPosts</code> component that uses <a href="/docs/url">Livewire's URL feature</a> to store and track the current search query in the query string:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">With</span>\<span class="hljs-title">Url</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPosts</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Url] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.search-posts'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; Post::search(<span class="hljs-keyword">$this</span>-&gt;search)-&gt;get(),
        ]);
    }
}
</div></code></pre>
<p>As you can see, the <code>$search</code> property above uses Livewire's <code>#[Url]</code> attribute to denote that its value should be stored in the URL.</p>
<p>Below is an example of how you would simulate the scenario of loading this component on a page with specific query parameters in the URL:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">SearchPosts</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPostsTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">can_search_posts_via_url_query_string</span><span class="hljs-params">()</span>
    </span>{
        Post::factory()-&gt;create([<span class="hljs-string">'title'</span> =&gt; <span class="hljs-string">'Testing the first water-proof hair dryer'</span>]);
        Post::factory()-&gt;create([<span class="hljs-string">'title'</span> =&gt; <span class="hljs-string">'Rubber duckies that actually float'</span>]);

        Livewire::withQueryParams([<span class="hljs-string">'search'</span> =&gt; <span class="hljs-string">'hair'</span>])
            -&gt;test(SearchPosts::class)
            -&gt;assertSee(<span class="hljs-string">'Testing the first'</span>)
            -&gt;assertDontSee(<span class="hljs-string">'Rubber duckies'</span>);
    }
}
</div></code></pre>
<h3 id="setting-cookies">Setting cookies</h3>
<p>If your Livewire component depends on cookies, you can use the <code>withCookie()</code> or <code>withCookies()</code> methods to set the cookies manually for your test.</p>
<p>Below is a basic <code>Cart</code> component that loads a discount token from a cookie on mount:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">With</span>\<span class="hljs-title">Url</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $discountToken;

    <span class="hljs-keyword">public</span> mount()
    {
        <span class="hljs-keyword">$this</span>-&gt;discountToken = request()-&gt;cookie(<span class="hljs-string">'discountToken'</span>);
    }
}
</div></code></pre>
<p>As you can see, the <code>$discountToken</code> property above gets its value from a cookie in the request.</p>
<p>Below is an example of how you would simulate the scenario of loading this component on a page with cookies:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Cart</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">can_load_discount_token_from_a_cookie</span><span class="hljs-params">()</span>
    </span>{
        Livewire::withCookies([<span class="hljs-string">'discountToken'</span> =&gt; <span class="hljs-string">'CALEB2023'</span>])
            -&gt;test(Cart::class)
            -&gt;assertSet(<span class="hljs-string">'discountToken'</span>, <span class="hljs-string">'CALEB2023'</span>);
    }
}
</div></code></pre>
<h2 id="calling-actions">Calling actions</h2>
<p>Livewire actions are typically called from the frontend using something like <code>wire:click</code>.</p>
<p>Because Livewire component tests don't use an actual browser, you can instead trigger actions in your tests using the <code>call()</code> method.</p>
<p>Below is an example of a <code>CreatePost</code> component using the <code>call()</code> method to trigger the <code>save()</code> action:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">can_create_post</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;assertEquals(<span class="hljs-number">0</span>, Post::count());

        Livewire::test(CreatePost::class)
            -&gt;set(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Wrinkly fingers? Try this one weird trick'</span>)
            -&gt;set(<span class="hljs-string">'content'</span>, <span class="hljs-string">'...'</span>)
            -&gt;call(<span class="hljs-string">'save'</span>);

        <span class="hljs-keyword">$this</span>-&gt;assertEquals(<span class="hljs-number">1</span>, Post::count());
    }
}
</div></code></pre>
<p>In the above test, we assert that calling <code>save()</code> creates a new post in the database.</p>
<p>You can also pass parameters to actions by passing additional parameters into the <code>call()</code> method:</p>
<pre class="hljs"><code><div>-&gt;call(<span class="hljs-string">'deletePost'</span>, $postId);
</div></code></pre>
<h3 id="validation">Validation</h3>
<p>To test that a validation error has been thrown, you can use Livewire's <code>assertHasErrors()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">title_field_is_required</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(CreatePost::class)
            -&gt;set(<span class="hljs-string">'title'</span>, <span class="hljs-string">''</span>)
            -&gt;call(<span class="hljs-string">'save'</span>)
            -&gt;assertHasErrors(<span class="hljs-string">'title'</span>);
    }
}
</div></code></pre>
<p>If you want to test that a specific validation rule has failed, you can pass an array of rules:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;assertHasErrors([<span class="hljs-string">'title'</span> =&gt; [<span class="hljs-string">'required'</span>]]);
</div></code></pre>
<p>Or if you'd rather assert a validation message exists, you can do so as well:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;assertHasErrors([<span class="hljs-string">'title'</span> =&gt; [<span class="hljs-string">'The title field is required.'</span>]]);
</div></code></pre>
<h3 id="authorization">Authorization</h3>
<p>Authorizing actions relying on untrusted input in your Livewire components is <a href="/docs/properties#authorizing-the-input">essential</a>. Livewire provides <code>assertUnauthorized()</code> and <code>assertForbidden()</code> methods to ensure that an authentication or authorization check has failed:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">UpdatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cant_update_another_users_post</span><span class="hljs-params">()</span>
    </span>{
        $user = User::factory()-&gt;create();
        $stranger = User::factory()-&gt;create();

        $post = Post::factory()-&gt;for($stranger)-&gt;create();

        Livewire::actingAs($user)
            -&gt;test(UpdatePost::class, [<span class="hljs-string">'post'</span> =&gt; $post])
            -&gt;set(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Living the lavender life'</span>)
            -&gt;call(<span class="hljs-string">'save'</span>)
            -&gt;assertUnauthorized();

        Livewire::actingAs($user)
            -&gt;test(UpdatePost::class, [<span class="hljs-string">'post'</span> =&gt; $post])
            -&gt;set(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Living the lavender life'</span>)
            -&gt;call(<span class="hljs-string">'save'</span>)
            -&gt;assertForbidden();
    }
}
</div></code></pre>
<p>If you prefer, you can also test for explicit status codes that an action in your component may have triggered using <code>assertStatus()</code>:</p>
<pre class="hljs"><code><div>-&gt;assertStatus(<span class="hljs-number">401</span>); <span class="hljs-comment">// Unauthorized</span>
-&gt;assertStatus(<span class="hljs-number">403</span>); <span class="hljs-comment">// Forbidden</span>
</div></code></pre>
<h3 id="redirects">Redirects</h3>
<p>You can test that a Livewire action performed a redirect using the <code>assertRedirect()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">redirected_to_all_posts_after_creating_a_post</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(CreatePost::class)
            -&gt;set(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Using a loofah doesn\'t make you aloof...ugh'</span>)
            -&gt;set(<span class="hljs-string">'content'</span>, <span class="hljs-string">'...'</span>)
            -&gt;call(<span class="hljs-string">'save'</span>)
            -&gt;assertRedirect(<span class="hljs-string">'/posts'</span>);
    }
}
</div></code></pre>
<p>As an added convenience, you can assert that the user was redirected to a specific page component instead of a hard-coded URL.</p>
<pre class="hljs"><code><div>-&gt;assertRedirect(CreatePost::class);
</div></code></pre>
<h3 id="events">Events</h3>
<p>To assert that an event was dispatched from within your component, you can use the <code>-&gt;assertDispatched()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creating_a_post_dispatches_event</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(CreatePost::class)
            -&gt;set(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Top 100 bubble bath brands'</span>)
            -&gt;set(<span class="hljs-string">'content'</span>, <span class="hljs-string">'...'</span>)
            -&gt;call(<span class="hljs-string">'save'</span>)
            -&gt;assertDispatched(<span class="hljs-string">'post-created'</span>);
    }
}
</div></code></pre>
<p>It is often helpful to test that two components can communicate with each other by dispatching and listening for events. Using the <code>dispatch()</code> method, let's simulate a <code>CreatePost</code> component dispatching a <code>create-post</code> event. Then, we will assert that a <code>PostCountBadge</code> component, which listens for that event, updates its post count appropriately:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">PostCountBadge</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostCountBadgeTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post_count_is_updated_when_event_is_dispatched</span><span class="hljs-params">()</span>
    </span>{
        $badge = Livewire::test(PostCountBadge::class)
            -&gt;assertSee(<span class="hljs-string">"0"</span>);

        Livewire::test(CreatePost::class)
            -&gt;set(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Tear-free: the greatest lie ever told'</span>)
            -&gt;set(<span class="hljs-string">'content'</span>, <span class="hljs-string">'...'</span>)
            -&gt;call(<span class="hljs-string">'save'</span>)
            -&gt;assertDispatched(<span class="hljs-string">'post-created'</span>);

        $badge-&gt;dispatch(<span class="hljs-string">'post-created'</span>)
            -&gt;assertSee(<span class="hljs-string">"1"</span>);
    }
}
</div></code></pre>
<p>Sometimes it may come in handy to assert that an event was dispatched with one or more parameters. Let's have a look at a component called <code>ShowPosts</code> that dispatches an event called <code>banner-message</code> with a parameter called <code>message</code>:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">ShowPosts</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPostsTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notification_is_dispatched_when_deleting_a_post</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(ShowPosts::class)
            -&gt;call(<span class="hljs-string">'delete'</span>, postId: <span class="hljs-number">3</span>)
            -&gt;assertDispatched(<span class="hljs-string">'notify'</span>,
                message: <span class="hljs-string">'The post was deleted'</span>,
            );
    }
}
</div></code></pre>
<p>If your component dispatches an event of which the parameter values must be asserted conditionally, you can pass in a closure as the second argument to the <code>assertDispatched</code> method like below. It receives the event name as the first argument, and an array containing the parameters as the second argument. Make sure the closure returns a boolean.</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">ShowPosts</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPostsTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notification_is_dispatched_when_deleting_a_post</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(ShowPosts::class)
            -&gt;call(<span class="hljs-string">'delete'</span>, postId: <span class="hljs-number">3</span>)
            -&gt;assertDispatched(<span class="hljs-string">'notify'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($eventName, $params)</span> </span>{
                <span class="hljs-keyword">return</span> ($params[<span class="hljs-string">'message'</span>] ?? <span class="hljs-string">''</span>) === <span class="hljs-string">'The post was deleted'</span>;
            })
    }
}
</div></code></pre>
<h2 id="all-available-testing-utilities">All available testing utilities</h2>
<p>Livewire provides many more testing utilities. Below is a comprehensive list of every testing method available to you, with a short description of how it's intended to be used:</p>
<h3 id="setup-methods">Setup methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Livewire::test(CreatePost::class)</code></td>
<td>Test the <code>CreatePost</code> component</td>
</tr>
<tr>
<td><code>Livewire::test(UpdatePost::class, ['post' =&gt; $post])</code></td>
<td>Test the <code>UpdatePost</code> component with the <code>post</code> parameter (To be received through the <code>mount()</code> method)</td>
</tr>
<tr>
<td><code>Livewire::actingAs($user)</code></td>
<td>Set the provided user as the session's authenticated user</td>
</tr>
<tr>
<td><code>Livewire::withQueryParams(['search' =&gt; '...'])</code></td>
<td>Set the test's <code>search</code> URL query parameter to the provided value (ex. <code>?search=...</code>). Typically in the context of a property using Livewire's <a href="/docs/url"><code>#[Url]</code> attribute</a></td>
</tr>
<tr>
<td><code>Livewire::withCookie('color', 'blue')</code></td>
<td>Set the test's <code>color</code> cookie to the provided value (<code>blue</code>).</td>
</tr>
<tr>
<td><code>Livewire::withCookies(['color' =&gt; 'blue', 'name' =&gt; 'Taylor])</code></td>
<td>Set the test's <code>color</code> and <code>name</code> cookies to the provided values (<code>blue</code>, <code>Taylor</code>).</td>
</tr>
<tr>
<td><code>Livewire::withHeaders(['X-COLOR' =&gt; 'blue', 'X-NAME' =&gt; 'Taylor])</code></td>
<td>Set the test's <code>X-COLOR</code> and <code>X-NAME</code> headers to the provided values (<code>blue</code>, <code>Taylor</code>).</td>
</tr>
</tbody>
</table>
<h3 id="interacting-with-components">Interacting with components</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set('title', '...')</code></td>
<td>Set the <code>title</code> property to the provided value</td>
</tr>
<tr>
<td><code>set(['title' =&gt; '...', ...])</code></td>
<td>Set multiple component properties using an associative array</td>
</tr>
<tr>
<td><code>toggle('sortAsc')</code></td>
<td>Toggle the <code>sortAsc</code> property between <code>true</code> and <code>false</code></td>
</tr>
<tr>
<td><code>call('save')</code></td>
<td>Call the <code>save</code> action / method</td>
</tr>
<tr>
<td><code>call('remove', $post-&gt;id)</code></td>
<td>Call the <code>remove</code> method and pass the <code>$post-&gt;id</code> as the first parameter (Accepts subsequent parameters as well)</td>
</tr>
<tr>
<td><code>refresh()</code></td>
<td>Trigger a component re-render</td>
</tr>
<tr>
<td><code>dispatch('post-created')</code></td>
<td>Dispatch the <code>post-created</code> event from the component</td>
</tr>
<tr>
<td><code>dispatch('post-created', postId: $post-&gt;id)</code></td>
<td>Dispatch the <code>post-created</code> event with <code>$post-&gt;id</code> as an additional parameter (<code>$event.detail</code> from Alpine)</td>
</tr>
</tbody>
</table>
<h3 id="assertions">Assertions</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>assertSet('title', '...')</code></td>
<td>Assert that the <code>title</code> property is set to the provided value</td>
</tr>
<tr>
<td><code>assertNotSet('title', '...')</code></td>
<td>Assert that the <code>title</code> property is not set to the provided value</td>
</tr>
<tr>
<td><code>assertSetStrict('title', '...')</code></td>
<td>Assert that the <code>title</code> property is set to the provided value using a strict comparison</td>
</tr>
<tr>
<td><code>assertNotSetStrict('title', '...')</code></td>
<td>Assert that the <code>title</code> property is not set to the provided value using a strict comparison</td>
</tr>
<tr>
<td><code>assertReturned('...')</code></td>
<td>Assert that the previous <code>-&gt;call(...)</code> returned a given value</td>
</tr>
<tr>
<td><code>assertCount('posts', 3)</code></td>
<td>Assert that the <code>posts</code> property is an array-like value with <code>3</code> items in it</td>
</tr>
<tr>
<td><code>assertSnapshotSet('date', '08/26/1990')</code></td>
<td>Assert that the <code>date</code> property's raw / dehydrated value (from JSON) is set to <code>08/26/1990</code>. Alternative to asserting against the hydrated <code>DateTime</code> instance in the case of <code>date</code></td>
</tr>
<tr>
<td><code>assertSnapshotNotSet('date', '08/26/1990')</code></td>
<td>Assert that <code>date</code>'s raw / dehydrated value is not equal to the provided value</td>
</tr>
<tr>
<td><code>assertSee($post-&gt;title)</code></td>
<td>Assert that the rendered HTML of the component contains the provided value</td>
</tr>
<tr>
<td><code>assertDontSee($post-&gt;title)</code></td>
<td>Assert that the rendered HTML does not contain the provided value</td>
</tr>
<tr>
<td><code>assertSeeHtml('&lt;div&gt;...&lt;/div&gt;')</code></td>
<td>Assert the provided string literal is contained in the rendered HTML without escaping the HTML characters (unlike <code>assertSee</code>, which does escape the provided characters by default)</td>
</tr>
<tr>
<td><code>assertDontSeeHtml('&lt;div&gt;...&lt;/div&gt;')</code></td>
<td>Assert the provided string is contained in the rendered HTML</td>
</tr>
<tr>
<td><code>assertSeeInOrder(['...', '...'])</code></td>
<td>Assert that the provided strings appear in order in the rendered HTML output of the component</td>
</tr>
<tr>
<td><code>assertSeeHtmlInOrder([$firstString, $secondString])</code></td>
<td>Assert that the provided HTML strings appear in order in the rendered output of the component</td>
</tr>
<tr>
<td><code>assertDispatched('post-created')</code></td>
<td>Assert that the given event has been dispatched by the component</td>
</tr>
<tr>
<td><code>assertNotDispatched('post-created')</code></td>
<td>Assert that the given event has not been dispatched by the component</td>
</tr>
<tr>
<td><code>assertHasErrors('title')</code></td>
<td>Assert that validation has failed for the <code>title</code> property</td>
</tr>
<tr>
<td><code>assertHasErrors(['title' =&gt; ['required', 'min:6']])</code></td>
<td>Assert that the provided validation rules failed for the <code>title</code> property</td>
</tr>
<tr>
<td><code>assertHasNoErrors('title')</code></td>
<td>Assert that there are no validation errors for the <code>title</code> property</td>
</tr>
<tr>
<td><code>assertHasNoErrors(['title' =&gt; ['required', 'min:6']])</code></td>
<td>Assert that the provided validation rules haven't failed for the <code>title</code> property</td>
</tr>
<tr>
<td><code>assertRedirect()</code></td>
<td>Assert that a redirect has been triggered from within the component</td>
</tr>
<tr>
<td><code>assertRedirect('/posts')</code></td>
<td>Assert the component triggered a redirect to the <code>/posts</code> endpoint</td>
</tr>
<tr>
<td><code>assertRedirect(ShowPosts::class)</code></td>
<td>Assert that the component triggered a redirect to the <code>ShowPosts</code> component</td>
</tr>
<tr>
<td><code>assertNoRedirect()</code></td>
<td>Assert that no redirect has been triggered</td>
</tr>
<tr>
<td><code>assertViewHas('posts')</code></td>
<td>Assert that the <code>render()</code> method has passed a <code>posts</code> item to the view data</td>
</tr>
<tr>
<td><code>assertViewHas('postCount', 3)</code></td>
<td>Assert that a <code>postCount</code> variable has been passed to the view with a value of <code>3</code></td>
</tr>
<tr>
<td><code>assertViewHas('posts', function ($posts) { ... })</code></td>
<td>Assert that <code>posts</code> view data exists and that it passes any assertions declared in the provided callback</td>
</tr>
<tr>
<td><code>assertViewIs('livewire.show-posts')</code></td>
<td>Assert that the component's render method returned the provided view name</td>
</tr>
<tr>
<td><code>assertFileDownloaded()</code></td>
<td>Assert that a file download has been triggered</td>
</tr>
<tr>
<td><code>assertFileDownloaded($filename)</code></td>
<td>Assert that a file download matching the provided file name has been triggered</td>
</tr>
<tr>
<td><code>assertNoFileDownloaded()</code></td>
<td>Assert that no file download has been triggered</td>
</tr>
<tr>
<td><code>assertUnauthorized()</code></td>
<td>Assert that an authorization exception has been thrown within the component (status code: 401)</td>
</tr>
<tr>
<td><code>assertForbidden()</code></td>
<td>Assert that an error response was triggered with the status code: 403</td>
</tr>
<tr>
<td><code>assertStatus(500)</code></td>
<td>Assert that the latest response matches the provided status code</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>
## File: the-livewire-protocol.md
```md
```json
{
    &quot;data&quot;: [
        &quot;todos&quot;: [[], [&quot;s&quot;: &quot;array&quot;]],
    ],
    &quot;memo&quot;: {
        &quot;id&quot;: &quot;...&quot;,
        &quot;name&quot;: &quot;...&quot;,
        &quot;path&quot;: &quot;...&quot;,
        &quot;method&quot;: &quot;...&quot;,
        &quot;locale&quot;: &quot;...&quot;,
        &quot;children&quot;: &quot;...&quot;
    },
    &quot;checksum&quot;: &quot;...&quot;
}
</div></code></pre>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"snapshot"</span>: {...},
    <span class="hljs-attr">"updates"</span>: {
        <span class="hljs-attr">"todos.0"</span>: <span class="hljs-string">"hey"</span>,
    },
    <span class="hljs-attr">"calls"</span>: [
        [
            <span class="hljs-string">"path"</span>: <span class="hljs-string">""</span>,
            <span class="hljs-string">"method"</span>: <span class="hljs-string">"add"</span>,
            <span class="hljs-string">"params"</span>: [],
        ]    
    ]
}
</div></code></pre>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"snapshot"</span>: {...},
    <span class="hljs-attr">"effects"</span>: {
        <span class="hljs-attr">"html"</span>: <span class="hljs-string">"..."</span>,
        <span class="hljs-attr">"returns"</span>: []
    }
}
</div></code></pre>
<pre class="hljs"><code><div>
## File: understanding-nesting.md
```md

Like many other component-based frameworks, Livewire components are nestable — meaning one component can render multiple components within itself.

However, because Livewire's nesting system is built differently than other frameworks, there are certain implications and constraints that are important to be aware of.

&gt; [!tip] Make sure you understand hydration first
&gt; Before learning more about Livewire's nesting system, it's helpful to fully understand how Livewire hydrates components. You can learn more by reading the [hydration documentation](/docs/hydration).

## Every component is an island

In Livewire, every component on a page tracks its state and makes updates independently of other components.

For example, consider the following `Posts` and nested `ShowPost` components:

```php
&lt;?php

namespace App\Livewire;

use Illuminate\Support\Facades\Auth;
use Livewire\Component;

class Posts extends Component
{
    public $postLimit = 2;

    public function render()
    {
        return view('livewire.posts', [
            'posts' =&gt; Auth::user()-&gt;posts()
                -&gt;limit($this-&gt;postLimit)-&gt;get(),
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    Post Limit: &lt;input type=&quot;number&quot; wire:model.live=&quot;postLimit&quot;&gt;

    @foreach ($posts as $post)
        &lt;livewire:show-post :$post :key=&quot;$post-&gt;id&quot;&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Auth</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-post'</span>);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;h1&gt;{{ $post-&gt;title }}&lt;/h1&gt;

    &lt;p&gt;{{ $post-&gt;content }}&lt;/p&gt;

    &lt;button wire:click=&quot;$refresh&quot;&gt;Refresh post&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>Here's what the HTML for the entire component tree might look like on initial page load:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:id</span>=<span class="hljs-string">"123"</span> <span class="hljs-attr">wire:snapshot</span>=<span class="hljs-string">"..."</span>&gt;</span>
    Post Limit: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">wire:model.live</span>=<span class="hljs-string">"postLimit"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:id</span>=<span class="hljs-string">"456"</span> <span class="hljs-attr">wire:snapshot</span>=<span class="hljs-string">"..."</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>The first post<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Post content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$refresh"</span>&gt;</span>Refresh post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:id</span>=<span class="hljs-string">"789"</span> <span class="hljs-attr">wire:snapshot</span>=<span class="hljs-string">"..."</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>The second post<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Post content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$refresh"</span>&gt;</span>Refresh post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Notice that the parent component contains both its rendered template and the rendered templates of all the components nested within it.</p>
<p>Because each component is independent, they each have their own IDs and snapshots (<code>wire:id</code> and <code>wire:snapshot</code>) embedded in their HTML for Livewire's JavaScript core to extract and track.</p>
<p>Let's consider a few different update scenarios to see the differences in how Livewire handles different levels of nesting.</p>
<h3 id="updating-a-child">Updating a child</h3>
<p>If you were to click the &quot;Refresh post&quot; button in one of the child <code>show-post</code> components, here is what would be sent to the server:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">memo</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'show-post'</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">'456'</span> },

    <span class="hljs-attr">state</span>: { ... },
}
</div></code></pre>
<p>Here's the HTML that would get sent back:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:id</span>=<span class="hljs-string">"456"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>The first post<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Post content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$refresh"</span>&gt;</span>Refresh post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>The important thing to note here is that when an update is triggered on a child component, only that component's data is sent to the server, and only that component is re-rendered.</p>
<p>Now let's look at the less intuitive scenario: updating a parent component.</p>
<h3 id="updating-the-parent">Updating the parent</h3>
<p>As a reminder, here's the Blade template of the parent <code>Posts</code> component:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    Post Limit: &lt;input type=&quot;number&quot; wire:model.live=&quot;postLimit&quot;&gt;

    @foreach ($posts as $post)
        &lt;livewire:show-post :$post :key=&quot;$post-&gt;id&quot;&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>If a user changes the &quot;Post Limit&quot; value from <code>2</code> to <code>1</code>, an update will be solely triggered on the parent.</p>
<p>Here's an example of what the request payload might look like:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">updates</span>: { <span class="hljs-attr">postLimit</span>: <span class="hljs-number">1</span> },

    <span class="hljs-attr">snapshot</span>: {
        <span class="hljs-attr">memo</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'posts'</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">'123'</span> },

        <span class="hljs-attr">state</span>: { <span class="hljs-attr">postLimit</span>: <span class="hljs-number">2</span>, ... },
    },
}
</div></code></pre>
<p>As you can see, only the snapshot for the parent <code>Posts</code> component is sent along to the server.</p>
<p>An important question you might be asking yourself is: what happens when the parent component re-renders and encounters the child <code>show-post</code> components? How will it re-render the children if their snapshots haven't been included in the request payload?</p>
<p>The answer is: they won't be re-rendered.</p>
<p>When Livewire renders the <code>Posts</code> component, it will render placeholders for any child components it encounters.</p>
<p>Here is an example of what the rendered HTML for the <code>Posts</code> component might be after the above update:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:id</span>=<span class="hljs-string">"123"</span>&gt;</span>
    Post Limit: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">wire:model.live</span>=<span class="hljs-string">"postLimit"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:id</span>=<span class="hljs-string">"456"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>As you can see, only one child has been rendered because <code>postLimit</code> was updated to <code>1</code>. However, you will also notice that instead of the full child component, there is only an empty <code>&lt;div&gt;&lt;/div&gt;</code> with the matching <code>wire:id</code> attribute.</p>
<p>When this HTML is received on the frontend, Livewire will <em>morph</em> the old HTML for this component into this new HTML, but intelligently skip any child component placeholders.</p>
<p>The effect is that, after <em>morphing</em>, the final DOM content of the parent <code>Posts</code> component will be the following:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:id</span>=<span class="hljs-string">"123"</span>&gt;</span>
    Post Limit: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">wire:model.live</span>=<span class="hljs-string">"postLimit"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:id</span>=<span class="hljs-string">"456"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>The first post<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Post content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$refresh"</span>&gt;</span>Refresh post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h2 id="performance-implications">Performance implications</h2>
<p>Livewire's &quot;island&quot; architecture can have both positive and negative implications for your application.</p>
<p>An advantage of this architecture is it allows you to isolate expensive portions of your application. For example, you can quarantine a slow database query to its own independent component, and its performance overhead won't impact the rest of the page.</p>
<p>However, the biggest drawback of this approach is that because components are entirely separate, inter-component communication/dependencies becomes more difficult.</p>
<p>For example, if you had a property passed down from the above parent <code>Posts</code> component to the nested <code>ShowPost</code> component, it wouldn't be &quot;reactive&quot;. Because each component is an island, if a request to the parent component changed the value of the property being passed into <code>ShowPost</code>, it wouldn't update inside <code>ShowPost</code>.</p>
<p>Livewire has overcome a number of these hurdles and provides dedicated APIs for these scenarios like: <a href="/docs/nesting#reactive-props">Reactive properties</a>, <a href="/docs/nesting#binding-to-child-data-using-wiremodel">Modelable components</a>, and <a href="/docs/nesting#directly-accessing-the-parent-from-the-child">the <code>$parent</code> object</a>.</p>
<p>Armed with this knowledge of how nested Livewire components operate, you will be able to make more informed decisions about when and how to nest components within your application.</p>
<pre class="hljs"><code><div>
## File: upgrading.md
```md

## Automated upgrade tool

To save you time upgrading, we've included an Artisan command to automate as many parts of the upgrade process as possible.

After [installing Livewire version 3](/docs/upgrading#update-livewire-to-version-3), run the following command, and you will receive prompts to upgrade each breaking change automatically:

```shell
php artisan livewire:upgrade
</div></code></pre>
<p>Although the above command can upgrade much of your application, the only way to ensure a complete upgrade is to follow the step-by-step guide on this page.</p>
<blockquote>
<p>[!tip] Hire us to upgrade your app instead
If you have a large Livewire application or just don't want to deal with upgrading from version 2 to version 3, you can hire us to handle it for you. <a href="/jumpstart">Learn more about our upgrade service here.</a></p>
</blockquote>
<h2 id="upgrade-php">Upgrade PHP</h2>
<p>Livewire now requires that your application is running on PHP version 8.1 or greater.</p>
<h2 id="update-livewire-to-version-3">Update Livewire to version 3</h2>
<p>Run the following composer command to upgrade your application's Livewire dependency from version 2 to 3:</p>
<pre class="hljs"><code><div>composer require livewire/livewire "^3.0"
</div></code></pre>
<blockquote>
<p>[!warning] Livewire 3 package compatibility
Most of the major third-party Livewire packages either currently support Livewire 3 or are working on supporting it soon. However, there will inevitably be packages that take longer to release support for Livewire 3.</p>
</blockquote>
<h2 id="clear-the-view-cache">Clear the view cache</h2>
<p>Run the following Artisan command from your application's root directory to clear any cached/compiled Blade views and force Livewire to re-compile them to be Livewire 3 compatible:</p>
<pre class="hljs"><code><div>php artisan view:clear
</div></code></pre>
<h2 id="merge-new-configuration">Merge new configuration</h2>
<p>Livewire 3 has changed multiple configuration options. If your application has a published configuration file (<code>config/livewire.php</code>), you will need to update it to account for the following changes.</p>
<h3 id="new-configuration">New configuration</h3>
<p>The following configuration keys have been introduced in version 3:</p>
<pre class="hljs"><code><div><span class="hljs-string">'legacy_model_binding'</span> =&gt; <span class="hljs-keyword">false</span>,

<span class="hljs-string">'inject_assets'</span> =&gt; <span class="hljs-keyword">true</span>,

<span class="hljs-string">'inject_morph_markers'</span> =&gt; <span class="hljs-keyword">true</span>,

<span class="hljs-string">'navigate'</span> =&gt; <span class="hljs-keyword">false</span>,

<span class="hljs-string">'pagination_theme'</span> =&gt; <span class="hljs-string">'tailwind'</span>,
</div></code></pre>
<p>You can reference <a href="https://github.com/livewire/livewire/blob/master/config/livewire.php">Livewire's new configuration file on GitHub</a> for additional option descriptions and copy-pastable code.</p>
<h3 id="changed-configuration">Changed configuration</h3>
<p>The following configuration items have been updated with new default values:</p>
<h4 id="new-class-namespace">New class namespace</h4>
<p>Livewire's default <code>class_namespace</code> has changed from <code>App\Http\Livewire</code> to <code>App\Livewire</code>. You are welcome to keep the old namespace configuration value; however, if you choose to update your configuration to the new namespace, you will have to move your Livewire components to <code>app/Livewire</code>:</p>
<pre class="hljs"><code><div><span class="hljs-string">'class_namespace'</span> =&gt; <span class="hljs-string">'App\\Http\\Livewire'</span>, <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-string">'class_namespace'</span> =&gt; <span class="hljs-string">'App\\Livewire'</span>, <span class="hljs-comment">// [tl! add]</span>
</div></code></pre>
<h4 id="new-layout-view-path">New layout view path</h4>
<p>When rendering full-page components in version 2, Livewire would use <code>resources/views/layouts/app.blade.php</code> as the default layout Blade component.</p>
<p>Because of a growing community preference for anonymous Blade components, Livewire 3 has changed the default location to: <code>resources/views/components/layouts/app.blade.php</code>.</p>
<pre class="hljs"><code><div><span class="hljs-string">'layout'</span> =&gt; <span class="hljs-string">'layouts.app'</span>, <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-string">'layout'</span> =&gt; <span class="hljs-string">'components.layouts.app'</span>, <span class="hljs-comment">// [tl! add]</span>
</div></code></pre>
<h3 id="removed-configuration">Removed configuration</h3>
<p>Livewire no longer recognizes the following configuration items.</p>
<h4 id="appurl"><code>app_url</code></h4>
<p>If your application is served under a non-root URI, in Livewire 2 you could use the <code>app_url</code> configuration option to configure the URL Livewire uses to make AJAX requests to.</p>
<p>In this case, we've found a string configuration to be too rigid. Therefore, Livewire 3 has chosen to use runtime configuration instead. You can reference our documentation on <a href="/docs/installation#configuring-livewires-update-endpoint">configuring Livewire's update endpoint</a> for more information.</p>
<h4 id="asseturl"><code>asset_url</code></h4>
<p>In Livewire 2, if your application was served under a non-root URI, you would use the <code>asset_url</code> configuration option to configure the base URL that Livewire uses to serve its JavaScript assets.</p>
<p>Livewire 3 has instead chosen a runtime configuration strategy. You can reference our documentation on <a href="/docs/installation#customizing-the-asset-url">configuring Livewire's script asset endpoint</a> for more information.</p>
<h4 id="middlewaregroup"><code>middleware_group</code></h4>
<p>Because Livewire now exposes a more flexible way to customize its update endpoint, the <code>middleware_group</code> configuration option has been removed.</p>
<p>You can reference our documentation on <a href="/docs/installation#configuring-livewires-update-endpoint">customizing Livewire's update endpoint</a> for more information on applying custom middleware to Livewire requests.</p>
<h4 id="manifestpath"><code>manifest_path</code></h4>
<p>Livewire 3 no longer uses a manifest file for component autoloading. Therefore, the <code>manifest_path</code> configuration is no longer necessary.</p>
<h4 id="backbuttoncache"><code>back_button_cache</code></h4>
<p>Because Livewire 3 now offers an <a href="/docs/navigate">SPA experience for your application using <code>wire:navigate</code></a>, the <code>back_button_cache</code> configuration is no longer necessary.</p>
<h2 id="livewire-app-namespace">Livewire app namespace</h2>
<p>In version 2, Livewire components were generated and recognized automatically under the <code>App\Http\Livewire</code> namespace.</p>
<p>Livewire 3 has changed this default to: <code>App\Livewire</code>.</p>
<p>You can either move all of your components to the new location or add the following configuration to your application's <code>config/livewire.php</code> configuration file:</p>
<pre class="hljs"><code><div><span class="hljs-string">'class_namespace'</span> =&gt; <span class="hljs-string">'App\\Http\\Livewire'</span>,
</div></code></pre>
<h3 id="discovery">Discovery</h3>
<p>With Livewire 3, there is no manifest present, and there is therefore nothing to “discover” in relation to Livewire Components, and you can safely remove any livewire:discover references from your build scripts without issue.</p>
<h2 id="page-component-layout-view">Page component layout view</h2>
<p>When rendering Livewire components as full pages using a syntax like the following:</p>
<pre class="hljs"><code><div>Route::get(<span class="hljs-string">'/posts'</span>, ShowPosts::class);
</div></code></pre>
<p>The Blade layout file used by Livewire to render the component has changed from <code>resources/views/layouts/app.blade.php</code> to <code>resources/views/components/layouts/app.blade.php</code>:</p>
<pre class="hljs"><code><div>resources/views/layouts/app.blade.php #[tl! remove]
resources/views/components/layouts/app.blade.php #[tl! add]
</div></code></pre>
<p>You can either move your layout file to the new location or apply the following configuration inside your application's <code>config/livewire.php</code> configuration file:</p>
<pre class="hljs"><code><div><span class="hljs-string">'layout'</span> =&gt; <span class="hljs-string">'layouts.app'</span>,
</div></code></pre>
<p>For more information, check out the documentation on <a href="/docs/components#layout-files">creating and using a page-component layout</a>.</p>
<h2 id="eloquent-model-binding">Eloquent model binding</h2>
<p>Livewire 2 supported <code>wire:model</code> binding directly to Eloquent model properties. For example, the following was a common pattern:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> Post $post;

<span class="hljs-keyword">protected</span> $rules = [
    <span class="hljs-string">'post.title'</span> =&gt; <span class="hljs-string">'required'</span>,
    <span class="hljs-string">'post.description'</span> =&gt; <span class="hljs-string">'required'</span>,
];
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"post.title"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"post.description"</span>&gt;</span>
</div></code></pre>
<p>In Livewire 3, binding directly to Eloquent models has been disabled in favor of using individual properties, or extracting <a href="/docs/forms#extracting-a-form-object">Form Objects</a>.</p>
<p>However, because this behavior is so heavily relied upon in Livewire applications, version 3 maintains support for this behavior via a configuration item in <code>config/livewire.php</code>:</p>
<pre class="hljs"><code><div><span class="hljs-string">'legacy_model_binding'</span> =&gt; <span class="hljs-keyword">true</span>,
</div></code></pre>
<p>By setting <code>legacy_model_binding</code> to <code>true</code>, Livewire will handle Eloquent model properties exactly as it did in version 2.</p>
<h2 id="alpinejs">AlpineJS</h2>
<p>Livewire 3 ships with <a href="https://alpinejs.dev">AlpineJS</a> by default.</p>
<p>If you manually include Alpine in your Livewire application, you will need to remove it, so that Livewire's built-in version doesn't conflict.</p>
<h3 id="including-alpine-via-a-script-tag">Including Alpine via a script tag</h3>
<p>If you include Alpine into your application via a script tag like the following, you can remove it entirely and Livewire will load its internal version instead:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove] --&gt;</span>
</div></code></pre>
<h3 id="including-plugins-via-a-script-tag">Including plugins via a script tag</h3>
<p>Livewire 3 now ships with the following Alpine plugins out-of-the-box:</p>
<ul>
<li><a href="https://alpinejs.dev/plugins/collapse">Collapse</a></li>
<li><a href="https://alpinejs.dev/plugins/focus">Focus</a></li>
<li><a href="https://alpinejs.dev/plugins/intersect">Intersect</a></li>
<li><a href="https://alpinejs.dev/plugins/mask">Mask</a></li>
<li><a href="https://alpinejs.dev/plugins/morph">Morph</a></li>
<li><a href="https://alpinejs.dev/plugins/persist">Persist</a></li>
</ul>
<p>If you have already included any of these in your application via <code>&lt;script&gt;</code> tags like below, you can remove them along with Alpine's core:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/@alpinejs/intersect@3.x.x/dist/cdn.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove:1] --&gt;</span>
<span class="hljs-comment">&lt;!-- ... --&gt;</span>
</div></code></pre>
<h3 id="accessing-the-alpine-global-via-a-script-tag">Accessing the Alpine global via a script tag</h3>
<p>If you are currently accessing the <code>Alpine</code> global object from a script tag like so:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'alpine:init'</span>, () =&gt; {
        Alpine.data(...)
    })
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<p>You may continue to do so, as Livewire internally includes and registers Alpine's global object like before.</p>
<h3 id="including-via-js-bundle">Including via JS bundle</h3>
<p>If you have included Alpine and any relevant plugins via NPM into your applications JavaScript bundle like so:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Warning: this is a snippet of the Livewire 2 approach to including Alpine</span>

<span class="hljs-keyword">import</span> Alpine <span class="hljs-keyword">from</span> <span class="hljs-string">'alpinejs'</span>
<span class="hljs-keyword">import</span> intersect <span class="hljs-keyword">from</span> <span class="hljs-string">'@alpinejs/intersect'</span>

Alpine.plugin(intersect)

Alpine.start()
</div></code></pre>
<p>You can remove them entirely, because Livewire includes Alpine and many popular Alpine plugins by default.</p>
<h4 id="accessing-alpine-via-js-bundle">Accessing Alpine via JS bundle</h4>
<p>If you are registering custom Alpine plugins or components inside your application's JavaScript bundle like so:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Warning: this is a snippet of the Livewire 2 approach to including Alpine</span>

<span class="hljs-keyword">import</span> Alpine <span class="hljs-keyword">from</span> <span class="hljs-string">'alpinejs'</span>
<span class="hljs-keyword">import</span> customPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">'./plugins/custom-plugin'</span>

Alpine.plugin(customPlugin)

Alpine.start()
</div></code></pre>
<p>You can still accomplish this by importing the Livewire core ESM module into your bundle and accessing <code>Alpine</code> from there.</p>
<p>To import Livewire into your bundle, you must first disable Livewire's normal JavaScript injection and provide the necessary configuration to Livewire by replacing <code>@livewireScripts</code> with <code>@livewireScriptConfig</code> in your application's primary layout:</p>
<pre class="hljs"><code><div>    &lt;!-- ... --&gt;

    @livewireScripts &lt;!-- [tl! remove] --&gt;
    @livewireScriptConfig &lt;!-- [tl! add] --&gt;
&lt;/body&gt;
</div></code></pre>
<p>Now, you can import <code>Alpine</code> and <code>Livewire</code> into your application's bundle like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Livewire, Alpine } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../vendor/livewire/livewire/dist/livewire.esm'</span>;
<span class="hljs-keyword">import</span> customPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">'./plugins/custom-plugin'</span>

Alpine.plugin(customPlugin)

Livewire.start()
</div></code></pre>
<p>Notice you no longer need to call <code>Alpine.start()</code>. Livewire will start Alpine automatically.</p>
<p>For more information, please consult our documentation on <a href="/docs/installation#manually-bundling-livewire-and-alpine">manually bundling Livewire's JavaScript</a>.</p>
<h2 id="wiremodel"><code>wire:model</code></h2>
<p>In Livewire 3, <code>wire:model</code> is &quot;deferred&quot; by default (instead of by <code>wire:model.defer</code>). To achieve the same behavior as <code>wire:model</code> from Livewire 2, you must use <code>wire:model.live</code>.</p>
<p>Below is a list of the necessary substitutions you will need to make in your templates to keep your application's behavior consistent:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"..."</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model.live</span>=<span class="hljs-string">"..."</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! add] --&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model.defer</span>=<span class="hljs-string">"..."</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model</span>=<span class="hljs-string">"..."</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! add] --&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model.lazy</span>=<span class="hljs-string">"..."</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">wire:model.blur</span>=<span class="hljs-string">"..."</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! add] --&gt;</span>
</div></code></pre>
<h2 id="entangle"><code>@entangle</code></h2>
<p>Similar to the changes to <code>wire:model</code>, Livewire 3 defers all data binding by default. To match this behavior, <code>@entangle</code> has been updated as well.</p>
<p>To keep your application running as expected, make the following <code>@entangle</code> substitutions:</p>
<pre class="hljs"><code><div>@entangle(...) &lt;!-- [tl! remove] --&gt;
@entangle(...).live &lt;!-- [tl! add] --&gt;

@entangle(...).defer &lt;!-- [tl! remove] --&gt;
@entangle(...) &lt;!-- [tl! add] --&gt;
</div></code></pre>
<h2 id="events">Events</h2>
<p>In Livewire 2, Livewire had two different PHP methods for triggering events:</p>
<ul>
<li><code>emit()</code></li>
<li><code>dispatchBrowserEvent()</code></li>
</ul>
<p>Livewire 3 has unified these two methods into a single method:</p>
<ul>
<li><code>dispatch()</code></li>
</ul>
<p>Here is a basic example of dispatching and listening for an event in Livewire 3:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Dispatching...</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> Post $post;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>, postId: <span class="hljs-keyword">$this</span>-&gt;post-&gt;id);
    }
}

<span class="hljs-comment">// Listening...</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dashboard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[On('post-created')]</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postAdded</span><span class="hljs-params">($postId)</span>
    </span>{
        <span class="hljs-comment">//</span>
    }
}
</div></code></pre>
<p>The three main changes from Livewire 2 are:</p>
<ol>
<li><code>emit()</code> has been renamed to <code>dispatch()</code> (Likewise <code>emitTo()</code> and <code>emitSelf()</code> are now <code>dispatchTo()</code> and <code>dispatchSelf()</code>)</li>
<li><code>dispatchBrowserEvent()</code> has been renamed to <code>dispatch()</code></li>
<li>All event parameters must be named</li>
</ol>
<p>For more information, check out the new <a href="/docs/events">events documentation page</a>.</p>
<p>Here are the &quot;find and replace&quot; differences that should be applied to your application:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;emit(<span class="hljs-string">'post-created'</span>); <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>); <span class="hljs-comment">// [tl! add]</span>

<span class="hljs-keyword">$this</span>-&gt;emitTo(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'post-created'</span>); <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>)-&gt;to(<span class="hljs-string">'foo'</span>); <span class="hljs-comment">// [tl! add]</span>

<span class="hljs-keyword">$this</span>-&gt;emitSelf(<span class="hljs-string">'post-created'</span>); <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>)-&gt;self(); <span class="hljs-comment">// [tl! add]</span>

<span class="hljs-keyword">$this</span>-&gt;emit(<span class="hljs-string">'post-created'</span>, $post-&gt;id); <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>, postId: $post-&gt;id); <span class="hljs-comment">// [tl! add]</span>

<span class="hljs-keyword">$this</span>-&gt;dispatchBrowserEvent(<span class="hljs-string">'post-created'</span>); <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>); <span class="hljs-comment">// [tl! add]</span>

<span class="hljs-keyword">$this</span>-&gt;dispatchBrowserEvent(<span class="hljs-string">'post-created'</span>, [<span class="hljs-string">'postId'</span> =&gt; $post-&gt;id]); <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'post-created'</span>, postId: $post-&gt;id); <span class="hljs-comment">// [tl! add]</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$emit('post-created')"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$dispatch('post-created')"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! add] --&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$emit('post-created', 1)"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$dispatch('post-created', { postId: 1 })"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! add] --&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$emitTo('foo', post-created', 1)"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"$dispatchTo('foo', 'post-created', { postId: 1 })"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! add] --&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$wire.emit('post-created', 1)"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">x-on:click</span>=<span class="hljs-string">"$dispatch('post-created', { postId: 1 })"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! add] --&gt;</span>
</div></code></pre>
<h3 id="emitup"><code>emitUp()</code></h3>
<p>The concept of <code>emitUp</code> has been removed entirely. Events are now dispatched using browser events and therefore will &quot;bubble up&quot; by default.</p>
<p>You can remove any instances of <code>$this-&gt;emitUp(...)</code> or <code>$emitUp(...)</code> from your components.</p>
<h3 id="testing-events">Testing events</h3>
<p>Livewire has also changed event assertions to match the new unified terminology regarding dispatching events:</p>
<pre class="hljs"><code><div>Livewire::test(Component::class)-&gt;assertEmitted(<span class="hljs-string">'post-created'</span>); <span class="hljs-comment">// [tl! remove]</span>
Livewire::test(Component::class)-&gt;assertDispatched(<span class="hljs-string">'post-created'</span>); <span class="hljs-comment">// [tl! add]</span>

Livewire::test(Component::class)-&gt;assertEmittedTo(Foo::class, <span class="hljs-string">'post-created'</span>); <span class="hljs-comment">// [tl! remove]</span>
Livewire::test(Component::class)-&gt;assertDispatchedTo(Foo:<span class="hljs-class"><span class="hljs-keyword">class</span>, '<span class="hljs-title">post</span>-<span class="hljs-title">created</span>'); // [<span class="hljs-title">tl</span>! <span class="hljs-title">add</span>]

<span class="hljs-title">Livewire</span>::<span class="hljs-title">test</span>(<span class="hljs-title">Component</span>::<span class="hljs-title">class</span>)-&gt;<span class="hljs-title">assertNotEmitted</span>('<span class="hljs-title">post</span>-<span class="hljs-title">created</span>'); // [<span class="hljs-title">tl</span>! <span class="hljs-title">remove</span>]
<span class="hljs-title">Livewire</span>::<span class="hljs-title">test</span>(<span class="hljs-title">Component</span>::<span class="hljs-title">class</span>)-&gt;<span class="hljs-title">assertNotDispatched</span>('<span class="hljs-title">post</span>-<span class="hljs-title">created</span>'); // [<span class="hljs-title">tl</span>! <span class="hljs-title">add</span>]

<span class="hljs-title">Livewire</span>::<span class="hljs-title">test</span>(<span class="hljs-title">Component</span>::<span class="hljs-title">class</span>)-&gt;<span class="hljs-title">assertEmittedUp</span>() // [<span class="hljs-title">tl</span>! <span class="hljs-title">remove</span>]
</span></div></code></pre>
<h3 id="url-query-string">URL query string</h3>
<p>In previous Livewire versions, if you bound a property to the URL's query string, the property value would always be present in the query string, unless you used the <code>except</code> option.</p>
<p>In Livewire 3, all properties bound to the query string will only show up if their value has been changed after the page load. This default removes the need for the <code>except</code> option:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>;

<span class="hljs-keyword">protected</span> $queryString = [
    <span class="hljs-string">'search'</span> =&gt; [<span class="hljs-string">'except'</span> =&gt; <span class="hljs-string">''</span>], <span class="hljs-comment">// [tl! remove]</span>
    <span class="hljs-string">'search'</span>, <span class="hljs-comment">// [tl! add]</span>
];
</div></code></pre>
<p>If you'd like to revert back to the Livewire 2 behavior of always showing a property in the query string no matter its value, you can use the <code>keep</code> option:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>;

<span class="hljs-keyword">protected</span> $queryString = [
    <span class="hljs-string">'search'</span> =&gt; [<span class="hljs-string">'keep'</span> =&gt; <span class="hljs-keyword">true</span>], <span class="hljs-comment">// [tl! highlight]</span>
];
</div></code></pre>
<h2 id="pagination">Pagination</h2>
<p>The pagination system has been updated in Livewire 3 to better support multiple paginators within the same component.</p>
<h3 id="update-published-pagination-views">Update published pagination views</h3>
<p>If you've published Livewire's pagination views, you can reference the new ones in the <a href="https://github.com/livewire/livewire/tree/master/src/Features/SupportPagination/views">pagination directory on GitHub</a> and update your application accordingly.</p>
<h3 id="accessing-this-page-directly">Accessing <code>$this-&gt;page</code> directly</h3>
<p>Because Livewire now supports multiple paginators per component, it has removed the <code>$page</code> property from the component class and replaced it with a <code>$paginators</code> property that stores an array of paginators:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;page = <span class="hljs-number">2</span>; <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-keyword">$this</span>-&gt;paginators[<span class="hljs-string">'page'</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// [tl! add]</span>
</div></code></pre>
<p>However, it is recommended that you use the provided <code>getPage</code> and <code>setPage</code> methods to modify and access the current page:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Getter...</span>
<span class="hljs-keyword">$this</span>-&gt;getPage();

<span class="hljs-comment">// Setter...</span>
<span class="hljs-keyword">$this</span>-&gt;setPage(<span class="hljs-number">2</span>);
</div></code></pre>
<h3 id="wireclickprefetch"><code>wire:click.prefetch</code></h3>
<p>Livewire's prefetching feature (<code>wire:click.prefetch</code>) has been removed entirely. If you depended on this feature, your application will still work, it will just be slightly less performant in the instances where you were previously benefiting from <code>.prefetch</code>.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click.prefetch</span>=<span class="hljs-string">""</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! remove] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"..."</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! add] --&gt;</span>
</div></code></pre>
<h2 id="component-class-changes">Component class changes</h2>
<p>The following changes have been made to Livewire's base <code>Livewire\Component</code> class that your application's components may have relied on.</p>
<h3 id="the-component-id-property">The component <code>$id</code> property</h3>
<p>If you accessed the component's ID directly via <code>$this-&gt;id</code>, you should instead use <code>$this-&gt;getId()</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;id; <span class="hljs-comment">// [tl! remove]</span>

<span class="hljs-keyword">$this</span>-&gt;getId(); <span class="hljs-comment">// [tl! add]</span>
</div></code></pre>
<h3 id="duplicate-method-and-property-names">Duplicate method and property names</h3>
<p>PHP allows you to use the same name for both a class property and method. In Livewire 3, this will cause problems when calling methods from the frontend via <code>wire:click</code>.</p>
<p>It is strongly recommended that you use distinct names for all public methods and properties in a component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>; <span class="hljs-comment">// [tl! remove]</span>

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> $query = <span class="hljs-string">''</span>; <span class="hljs-comment">// [tl! add]</span>

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h2 id="javascript-api-changes">JavaScript API changes</h2>
<h3 id="livewireload"><code>livewire:load</code></h3>
<p>In previous versions of Livewire, you could listen for the <code>livewire:load</code> event to execute JavaScript code immediately before Livewire initialized the page.</p>
<p>In Livewire 3, that event name has been changed to <code>livewire:init</code> to match Alpine's <code>alpine:init</code>:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:load'</span>, () =&gt; {...}) <span class="hljs-comment">// [tl! remove]</span>
<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'livewire:init'</span>, () =&gt; {...}) <span class="hljs-comment">// [tl! add]</span>
</div></code></pre>
<h3 id="page-expired-hook">Page expired hook</h3>
<p>In version 2, Livewire exposed a dedicated JavaScript method for customizing the page expiration behavior: <code>Livewire.onPageExpired()</code>. This method has been removed in favor of using the more powerful <code>request</code> hooks directly:</p>
<pre class="hljs"><code><div>Livewire.onPageExpired(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {...}) <span class="hljs-comment">// [tl! remove]</span>

Livewire.hook(<span class="hljs-string">'request'</span>, ({ fail }) =&gt; { <span class="hljs-comment">// [tl! add:8]</span>
    fail(<span class="hljs-function">(<span class="hljs-params">{ status, preventDefault }</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (status === <span class="hljs-number">419</span>) {
            preventDefault()

            confirm(<span class="hljs-string">'Your custom page expiration behavior...'</span>)
        }
    })
})
</div></code></pre>
<h3 id="new-lifecycle-hooks">New lifecycle hooks</h3>
<p>Many of Livewire's internal JavaScript lifecycle hooks have been changed in Livewire 3.</p>
<p>Here is a comparison of the old hooks and their new syntaxes for you to find/replace in your application:</p>
<pre class="hljs"><code><div>Livewire.hook(<span class="hljs-string">'component.initialized'</span>, (component) =&gt; {}) <span class="hljs-comment">// [tl! remove]</span>
Livewire.hook(<span class="hljs-string">'component.init'</span>, ({ component, cleanup }) =&gt; {}) <span class="hljs-comment">// [tl! add]</span>

Livewire.hook(<span class="hljs-string">'element.initialized'</span>, (el, component) =&gt; {}) <span class="hljs-comment">// [tl! remove]</span>
Livewire.hook(<span class="hljs-string">'element.init'</span>, ({ el, component }) =&gt; {}) <span class="hljs-comment">// [tl! add]</span>

Livewire.hook(<span class="hljs-string">'element.updating'</span>, (fromEl, toEl, component) =&gt; {}) <span class="hljs-comment">// [tl! remove]</span>
Livewire.hook(<span class="hljs-string">'morph.updating'</span>, ({ el, toEl, component }) =&gt; {}) <span class="hljs-comment">// [tl! add]</span>

Livewire.hook(<span class="hljs-string">'element.updated'</span>, (el, component) =&gt; {}) <span class="hljs-comment">// [tl! remove]</span>
Livewire.hook(<span class="hljs-string">'morph.updated'</span>, ({ el, component }) =&gt; {}) <span class="hljs-comment">// [tl! add]</span>

Livewire.hook(<span class="hljs-string">'element.removed'</span>, (el, component) =&gt; {}) <span class="hljs-comment">// [tl! remove]</span>
Livewire.hook(<span class="hljs-string">'morph.removed'</span>, ({ el, component }) =&gt; {}) <span class="hljs-comment">// [tl! add]</span>

Livewire.hook(<span class="hljs-string">'message.sent'</span>, (message, component) =&gt; {}) <span class="hljs-comment">// [tl! remove]</span>
Livewire.hook(<span class="hljs-string">'message.failed'</span>, (message, component) =&gt; {}) <span class="hljs-comment">// [tl! remove]</span>
Livewire.hook(<span class="hljs-string">'message.received'</span>, (message, component) =&gt; {}) <span class="hljs-comment">// [tl! remove]</span>
Livewire.hook(<span class="hljs-string">'message.processed'</span>, (message, component) =&gt; {}) <span class="hljs-comment">// [tl! remove]</span>

Livewire.hook(<span class="hljs-string">'commit'</span>, ({ component, commit, respond, succeed, fail }) =&gt; { <span class="hljs-comment">// [tl! add:14]</span>
    <span class="hljs-comment">// Equivalent of 'message.sent'</span>

    succeed(<span class="hljs-function">(<span class="hljs-params">{ snapshot, effect }</span>) =&gt;</span> {
        <span class="hljs-comment">// Equivalent of 'message.received'</span>

        queueMicrotask(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-comment">// Equivalent of 'message.processed'</span>
        })
    })

    fail(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-comment">// Equivalent of 'message.failed'</span>
    })
})
</div></code></pre>
<p>You may consult the new <a href="/docs/javascript">JavaScript hook documentation</a> for a more thorough understanding of the new hook system.</p>
<h2 id="localization">Localization</h2>
<p>If your application uses a locale prefix in the URI such as <code>https://example.com/en/...</code>, Livewire 2 automatically preserved this URL prefix when making component updates via <code>https://example.com/en/livewire/update</code>.</p>
<p>Livewire 3 has stopped supporting this behavior automatically. Instead, you can override Livewire's update endpoint with any URI prefixes you need using <code>setUpdateRoute()</code>:</p>
<pre class="hljs"><code><div>Route::group([<span class="hljs-string">'prefix'</span> =&gt; LaravelLocalization::setLocale()], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// Your other localized routes...</span>

    Livewire::setUpdateRoute(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($handle)</span> </span>{
        <span class="hljs-keyword">return</span> Route::post(<span class="hljs-string">'/livewire/update'</span>, $handle);
    });
});
</div></code></pre>
<p>For more information, please consult our documentation on <a href="/docs/installation#configuring-livewires-update-endpoint">configuring Livewire's update endpoint</a>.</p>
<pre class="hljs"><code><div>
## File: uploads.md
```md
Livewire offers powerful support for uploading files within your components.

First, add the `WithFileUploads` trait to your component. Once this trait has been added to your component, you can use `wire:model` on file inputs as if they were any other input type and Livewire will take care of the rest.

Here's an example of a simple component that handles uploading a photo:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;
use Livewire\WithFileUploads;
use Livewire\Attributes\Validate;

class UploadPhoto extends Component
{
    use WithFileUploads;

    #[Validate('image|max:1024')] // 1MB Max
    public $photo;

    public function save()
    {
        $this-&gt;photo-&gt;store(path: 'photos');
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input type=&quot;file&quot; wire:model=&quot;photo&quot;&gt;

    @error('photo') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror

    &lt;button type=&quot;submit&quot;&gt;Save photo&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<blockquote>
<p>[!warning] The &quot;upload&quot; method is reserved
Notice the above example uses a &quot;save&quot; method instead of an &quot;upload&quot; method. This is a common &quot;gotcha&quot;. The term &quot;upload&quot; is reserved by Livewire. You cannot use it as a method or property name in your component.</p>
</blockquote>
<p>From the developer's perspective, handling file inputs is no different than handling any other input type: Add <code>wire:model</code> to the <code>&lt;input&gt;</code> tag and everything else is taken care of for you.</p>
<p>However, more is happening under the hood to make file uploads work in Livewire. Here's a glimpse at what goes on when a user selects a file to upload:</p>
<ol>
<li>When a new file is selected, Livewire's JavaScript makes an initial request to the component on the server to get a temporary &quot;signed&quot; upload URL.</li>
<li>Once the URL is received, JavaScript does the actual &quot;upload&quot; to the signed URL, storing the upload in a temporary directory designated by Livewire and returning the new temporary file's unique hash ID.</li>
<li>Once the file is uploaded and the unique hash ID is generated, Livewire's JavaScript makes a final request to the component on the server, telling it to &quot;set&quot; the desired public property to the new temporary file.</li>
<li>Now, the public property (in this case, <code>$photo</code>) is set to the temporary file upload and is ready to be stored or validated at any point.</li>
</ol>
<h2 id="storing-uploaded-files">Storing uploaded files</h2>
<p>The previous example demonstrates the most basic storage scenario: moving the temporarily uploaded file to the &quot;photos&quot; directory on the application's default filesystem disk.</p>
<p>However, you may want to customize the file name of the stored file or even specify a specific storage &quot;disk&quot; to keep the file on (such as S3).</p>
<p>Livewire honors the same APIs Laravel uses for storing uploaded files, so feel free to consult <a href="https://laravel.com/docs/filesystem#file-uploads">Laravel's file upload documentation</a>. However, below are a few common storage scenarios and examples:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// Store the file in the "photos" directory of the default filesystem disk</span>
    <span class="hljs-keyword">$this</span>-&gt;photo-&gt;store(path: <span class="hljs-string">'photos'</span>);

    <span class="hljs-comment">// Store the file in the "photos" directory in a configured "s3" disk</span>
    <span class="hljs-keyword">$this</span>-&gt;photo-&gt;store(path: <span class="hljs-string">'photos'</span>, <span class="hljs-string">'s3'</span>);

    <span class="hljs-comment">// Store the file in the "photos" directory with the filename "avatar.png"</span>
    <span class="hljs-keyword">$this</span>-&gt;photo-&gt;storeAs(path: <span class="hljs-string">'photos'</span>, name: <span class="hljs-string">'avatar'</span>);

    <span class="hljs-comment">// Store the file in the "photos" directory in a configured "s3" disk with the filename "avatar.png"</span>
    <span class="hljs-keyword">$this</span>-&gt;photo-&gt;storeAs(path: <span class="hljs-string">'photos'</span>, name: <span class="hljs-string">'avatar'</span>, <span class="hljs-string">'s3'</span>);

    <span class="hljs-comment">// Store the file in the "photos" directory, with "public" visibility in a configured "s3" disk</span>
    <span class="hljs-keyword">$this</span>-&gt;photo-&gt;storePublicly(path: <span class="hljs-string">'photos'</span>, <span class="hljs-string">'s3'</span>);

    <span class="hljs-comment">// Store the file in the "photos" directory, with the name "avatar.png", with "public" visibility in a configured "s3" disk</span>
    <span class="hljs-keyword">$this</span>-&gt;photo-&gt;storePubliclyAs(path: <span class="hljs-string">'photos'</span>, name: <span class="hljs-string">'avatar'</span>, <span class="hljs-string">'s3'</span>);
}
</div></code></pre>
<h2 id="handling-multiple-files">Handling multiple files</h2>
<p>Livewire automatically handles multiple file uploads by detecting the <code>multiple</code> attribute on the <code>&lt;input&gt;</code> tag.</p>
<p>For example, below is a component with an array property named <code>$photos</code>. By adding <code>multiple</code> to the form's file input, Livewire will automatically append new files to this array:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">WithFileUploads</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadPhotos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">WithFileUploads</span>;

    <span class="hljs-comment">#[Validate(['photos.*' =&gt; 'image|max:1024'])]</span>
    <span class="hljs-keyword">public</span> $photos = [];

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;photos <span class="hljs-keyword">as</span> $photo) {
            $photo-&gt;store(path: <span class="hljs-string">'photos'</span>);
        }
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input type=&quot;file&quot; wire:model=&quot;photos&quot; multiple&gt;

    @error('photos.*') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror

    &lt;button type=&quot;submit&quot;&gt;Save photo&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<h2 id="file-validation">File validation</h2>
<p>Like we've discussed, validating file uploads with Livewire is the same as handling file uploads from a standard Laravel controller.</p>
<blockquote>
<p>[!warning] Ensure S3 is properly configured
Many of the validation rules relating to files require access to the file. When <a href="#upload-to-s3">uploading directly to S3</a>, these validation rules will fail if the S3 file object is not publicly accessible.</p>
</blockquote>
<p>For more information on file validation, consult <a href="https://laravel.com/docs/validation#available-validation-rules">Laravel's file validation documentation</a>.</p>
<h2 id="temporary-preview-urls">Temporary preview URLs</h2>
<p>After a user chooses a file, you should typically show them a preview of that file before they submit the form and store the file.</p>
<p>Livewire makes this trivial by using the <code>-&gt;temporaryUrl()</code> method on uploaded files.</p>
<blockquote>
<p>[!info] Temporary URLs are restricted to images
For security reasons, temporary upload URLs are only supported on files with image MIME types.</p>
</blockquote>
<p>Let's explore an example of a file upload with an image preview:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">WithFileUploads</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadPhoto</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">WithFileUploads</span>;

    <span class="hljs-comment">#[Validate('image|max:1024')]</span>
    <span class="hljs-keyword">public</span> $photo;

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    @if ($photo) &lt;!-- [tl! highlight:2] --&gt;
        &lt;img src=&quot;{{ $photo-&gt;temporaryUrl() }}&quot;&gt;
    @endif

    &lt;input type=&quot;file&quot; wire:model=&quot;photo&quot;&gt;

    @error('photo') &lt;span class=&quot;error&quot;&gt;{{ $message }}&lt;/span&gt; @enderror

    &lt;button type=&quot;submit&quot;&gt;Save photo&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>As previously discussed, Livewire stores temporary files in a non-public directory; therefore, typically there's no simple way to expose a temporary, public URL to your users for image previewing.</p>
<p>However, Livewire solves this issue by providing a temporary, signed URL that pretends to be the uploaded image so your page can show an image preview to your users.</p>
<p>This URL is protected against showing files in directories above the temporary directory. And, because it's signed, users can't abuse this URL to preview other files on your system.</p>
<blockquote>
<p>[!tip] S3 temporary signed URLs
If you've configured Livewire to use S3 for temporary file storage, calling <code>-&gt;temporaryUrl()</code> will generate a temporary, signed URL to S3 directly so that image previews aren't loaded from your Laravel application server.</p>
</blockquote>
<h2 id="testing-file-uploads">Testing file uploads</h2>
<p>You can use Laravel's existing file upload testing helpers to test file uploads.</p>
<p>Below is a complete example of testing the <code>UploadPhoto</code> component with Livewire:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Http</span>\<span class="hljs-title">UploadedFile</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Storage</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">UploadPhoto</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadPhotoTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">can_upload_photo</span><span class="hljs-params">()</span>
    </span>{
        Storage::fake(<span class="hljs-string">'avatars'</span>);

        $file = UploadedFile::fake()-&gt;image(<span class="hljs-string">'avatar.png'</span>);

        Livewire::test(UploadPhoto::class)
            -&gt;set(<span class="hljs-string">'photo'</span>, $file)
            -&gt;call(<span class="hljs-string">'upload'</span>, <span class="hljs-string">'uploaded-avatar.png'</span>);

        Storage::disk(<span class="hljs-string">'avatars'</span>)-&gt;assertExists(<span class="hljs-string">'uploaded-avatar.png'</span>);
    }
}
</div></code></pre>
<p>Below is an example of the <code>UploadPhoto</code> component required to make the previous test pass:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">WithFileUploads</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadPhoto</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">use</span> <span class="hljs-title">WithFileUploads</span>;

    <span class="hljs-keyword">public</span> $photo;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span><span class="hljs-params">($name)</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;photo-&gt;storeAs(<span class="hljs-string">'/'</span>, $name, disk: <span class="hljs-string">'avatars'</span>);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>For more information on testing file uploads, please consult <a href="https://laravel.com/docs/http-tests#testing-file-uploads">Laravel's file upload testing documentation</a>.</p>
<h2 id="uploading-directly-to-amazon-s3">Uploading directly to Amazon S3</h2>
<p>As previously discussed, Livewire stores all file uploads in a temporary directory until the developer permanently stores the file.</p>
<p>By default, Livewire uses the default filesystem disk configuration (usually <code>local</code>) and stores the files within a <code>livewire-tmp/</code> directory.</p>
<p>Consequently, file uploads are always utilizing your application server, even if you choose to store the uploaded files in an S3 bucket later.</p>
<p>If you wish to bypass your application server and instead store Livewire's temporary uploads in an S3 bucket, you can configure that behavior in your application's <code>config/livewire.php</code> configuration file. First, set <code>livewire.temporary_file_upload.disk</code> to <code>s3</code> (or another custom disk that uses the <code>s3</code> driver):</p>
<pre class="hljs"><code><div><span class="hljs-keyword">return</span> [
    <span class="hljs-comment">// ...</span>
    <span class="hljs-string">'temporary_file_upload'</span> =&gt; [
        <span class="hljs-string">'disk'</span> =&gt; <span class="hljs-string">'s3'</span>,
        <span class="hljs-comment">// ...</span>
    ],
];
</div></code></pre>
<p>Now, when a user uploads a file, the file will never actually be stored on your server. Instead, it will be uploaded directly to your S3 bucket within the <code>livewire-tmp/</code> sub-directory.</p>
<blockquote>
<p>[!info] Publishing Livewire's configuration file
Before customizing the file upload disk, you must first publish Livewire's configuration file to your application's <code>/config</code> directory by running the following command:</p>
<pre class="hljs"><code><div>php artisan livewire:publish --config
</div></code></pre>
</blockquote>
<h3 id="configuring-automatic-file-cleanup">Configuring automatic file cleanup</h3>
<p>Livewire's temporary upload directory will fill up with files quickly; therefore, it's essential to configure S3 to clean up files older than 24 hours.</p>
<p>To configure this behavior, run the following Artisan command from the environment that is utilizing an S3 bucket for file uploads:</p>
<pre class="hljs"><code><div>php artisan livewire:configure-s3-upload-cleanup
</div></code></pre>
<p>Now, any temporary files older than 24 hours will be cleaned up by S3 automatically.</p>
<blockquote>
<p>[!info]
If you are not using S3 for file storage, Livewire will handle file cleanup automatically and there is no need to run the command above.</p>
</blockquote>
<h2 id="loading-indicators">Loading indicators</h2>
<p>Although <code>wire:model</code> for file uploads works differently than other <code>wire:model</code> input types under the hood, the interface for showing loading indicators remains the same.</p>
<p>You can display a loading indicator scoped to the file upload like so:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;file&quot; wire:model=&quot;photo&quot;&gt;

&lt;div wire:loading wire:target=&quot;photo&quot;&gt;Uploading...&lt;/div&gt;
</div></code></pre>
<p>Now, while the file is uploading, the &quot;Uploading...&quot; message will be shown and then hidden when the upload is finished.</p>
<p>For more information on loading states, check out our comprehensive <a href="/docs/wire-loading">loading state documentation</a>.</p>
<h2 id="progress-indicators">Progress indicators</h2>
<p>Every Livewire file upload operation dispatches JavaScript events on the corresponding <code>&lt;input&gt;</code> element, allowing custom JavaScript to intercept the events:</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>livewire-upload-start</code></td>
<td>Dispatched when the upload starts</td>
</tr>
<tr>
<td><code>livewire-upload-finish</code></td>
<td>Dispatched if the upload is successfully finished</td>
</tr>
<tr>
<td><code>livewire-upload-cancel</code></td>
<td>Dispatched if the upload was cancelled prematurely</td>
</tr>
<tr>
<td><code>livewire-upload-error</code></td>
<td>Dispatched if the upload fails</td>
</tr>
<tr>
<td><code>livewire-upload-progress</code></td>
<td>An event containing the upload progress percentage as the upload progresses</td>
</tr>
</tbody>
</table>
<p>Below is an example of wrapping a Livewire file upload in an Alpine component to display an upload progress bar:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;div
        x-data=&quot;{ uploading: false, progress: 0 }&quot;
        x-on:livewire-upload-start=&quot;uploading = true&quot;
        x-on:livewire-upload-finish=&quot;uploading = false&quot;
        x-on:livewire-upload-cancel=&quot;uploading = false&quot;
        x-on:livewire-upload-error=&quot;uploading = false&quot;
        x-on:livewire-upload-progress=&quot;progress = $event.detail.progress&quot;
    &gt;
        &lt;!-- File Input --&gt;
        &lt;input type=&quot;file&quot; wire:model=&quot;photo&quot;&gt;

        &lt;!-- Progress Bar --&gt;
        &lt;div x-show=&quot;uploading&quot;&gt;
            &lt;progress max=&quot;100&quot; x-bind:value=&quot;progress&quot;&gt;&lt;/progress&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- ... --&gt;
&lt;/form&gt;
</div></code></pre>
<h2 id="cancelling-an-upload">Cancelling an upload</h2>
<p>If an upload is taking a long time, a user may want to cancel it. You can provide this functionality with Livewire's <code>$cancelUpload()</code> function in JavaScript.</p>
<p>Here's an example of creating a &quot;Cancel Upload&quot; button in a Livewire component using <code>wire:click</code> to handle the click event:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;!-- File Input --&gt;
    &lt;input type=&quot;file&quot; wire:model=&quot;photo&quot;&gt;

    &lt;!-- Cancel upload button --&gt;
    &lt;button type=&quot;button&quot; wire:click=&quot;$cancelUpload('photo')&quot;&gt;Cancel Upload&lt;/button&gt;

    &lt;!-- ... --&gt;
&lt;/form&gt;
</div></code></pre>
<p>When &quot;Cancel upload&quot; is pressed, the file upload will request will be aborted and the file input will be cleared. The user can now attempt another upload with a different file.</p>
<p>Alternatively, you can call <code>cancelUpload(...)</code> from Alpine like so:</p>
<pre class="hljs"><code><div>&lt;button type=&quot;button&quot; x-on:click=&quot;$wire.cancelUpload('photo')&quot;&gt;Cancel Upload&lt;/button&gt;
</div></code></pre>
<h2 id="javascript-upload-api">JavaScript upload API</h2>
<p>Integrating with third-party file-uploading libraries often requires more control than a simple <code>&lt;input type=&quot;file&quot; wire:model=&quot;...&quot;&gt;</code> element.</p>
<p>For these scenarios, Livewire exposes dedicated JavaScript functions.</p>
<p>These functions exist on a JavaScript component object, which can be accessed using Livewire's convenient <code>$wire</code> object from within your Livewire component's template:</p>
<pre class="hljs"><code><div>@script
&lt;script&gt;
    let file = $wire.el.querySelector('input[type=&quot;file&quot;]').files[0]

    // Upload a file...
    $wire.upload('photo', file, (uploadedFilename) =&gt; {
        // Success callback...
    }, () =&gt; {
        // Error callback...
    }, (event) =&gt; {
        // Progress callback...
        // event.detail.progress contains a number between 1 and 100 as the upload progresses
    }, () =&gt; {
        // Cancelled callback...
    })

    // Upload multiple files...
    $wire.uploadMultiple('photos', [file], successCallback, errorCallback, progressCallback, cancelledCallback)

    // Remove single file from multiple uploaded files...
    $wire.removeUpload('photos', uploadedFilename, successCallback)

    // Cancel an upload...
    $wire.cancelUpload('photos')
&lt;/script&gt;
@endscript
</div></code></pre>
<h2 id="configuration">Configuration</h2>
<p>Because Livewire stores all file uploads temporarily before the developer can validate or store them, it assumes some default handling behavior for all file uploads.</p>
<h3 id="global-validation">Global validation</h3>
<p>By default, Livewire will validate all temporary file uploads with the following rules: <code>file|max:12288</code> (Must be a file less than 12MB).</p>
<p>If you wish to customize these rules, you can do so inside your application's <code>config/livewire.php</code> file:</p>
<pre class="hljs"><code><div><span class="hljs-string">'temporary_file_upload'</span> =&gt; [
    <span class="hljs-comment">// ...</span>
    <span class="hljs-string">'rules'</span> =&gt; <span class="hljs-string">'file|mimes:png,jpg,pdf|max:102400'</span>, <span class="hljs-comment">// (100MB max, and only accept PNGs, JPEGs, and PDFs)</span>
],
</div></code></pre>
<h3 id="global-middleware">Global middleware</h3>
<p>The temporary file upload endpoint is assigned a throttling middleware by default. You can customize exactly what middleware this endpoint uses via the following configuration option:</p>
<pre class="hljs"><code><div><span class="hljs-string">'temporary_file_upload'</span> =&gt; [
    <span class="hljs-comment">// ...</span>
    <span class="hljs-string">'middleware'</span> =&gt; <span class="hljs-string">'throttle:5,1'</span>, <span class="hljs-comment">// Only allow 5 uploads per user per minute</span>
],
</div></code></pre>
<h3 id="temporary-upload-directory">Temporary upload directory</h3>
<p>Temporary files are uploaded to the specified disk's <code>livewire-tmp/</code> directory. You can customize this directory via the following configuration option:</p>
<pre class="hljs"><code><div><span class="hljs-string">'temporary_file_upload'</span> =&gt; [
    <span class="hljs-comment">// ...</span>
    <span class="hljs-string">'directory'</span> =&gt; <span class="hljs-string">'tmp'</span>,
],
</div></code></pre>
<pre class="hljs"><code><div>
## File: url.md
```md
Livewire allows you to store component properties in the URL's query string. For example, you may want a `$search` property in your component to be included in the URL: `https://example.com/users?search=bob`. This is particularly useful for things like filtering, sorting, and pagination, as it allows users to share and bookmark specific states of a page.

## Basic usage

Below is a `ShowUsers` component that allows you to search users by their name via a simple text input:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Attributes\Url;
use Livewire\Component;
use App\Models\User;

class ShowUsers extends Component
{
    public $search = '';

    public function render()
    {
        return view('livewire.show-users', [
            'users' =&gt; User::search($this-&gt;search)-&gt;get(),
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;input type=&quot;text&quot; wire:model.live=&quot;search&quot;&gt;

    &lt;ul&gt;
        @foreach ($users as $user)
            &lt;li wire:key=&quot;{{ $user-&gt;id }}&quot;&gt;{{ $user-&gt;name }}&lt;/li&gt;
        @endforeach
    &lt;/ul&gt;
&lt;/div&gt;
</div></code></pre>
<p>As you can see, because the text input uses <code>wire:model.live=&quot;search&quot;</code>, as a user types into the field, network requests will be sent to update the <code>$search</code> property and show a filtered set of users on the page.</p>
<p>However, if the visitor refreshes the page, the search value and results will be lost.</p>
<p>To preserve the search value across page loads so that a visitor can refresh the page or share the URL, we can store the search value in the URL's query string by adding the <code>#[Url]</code> attribute above the <code>$search</code> property like so:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Url</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowUsers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Url] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> view(<span class="hljs-string">'livewire.show-users'</span>, [
            <span class="hljs-string">'posts'</span> =&gt; User::search(<span class="hljs-keyword">$this</span>-&gt;search)-&gt;get(),
        ]);
    }
}
</div></code></pre>
<p>Now, if a user types &quot;bob&quot; into the search field, the URL bar in the browser will show:</p>
<pre class="hljs"><code><div>https://example.com/users?search=bob
</div></code></pre>
<p>If they now load this URL from a new browser window, &quot;bob&quot; will be filled in the search field, and the user results will be filtered accordingly.</p>
<h2 id="initializing-properties-from-the-url">Initializing properties from the URL</h2>
<p>As you saw in the previous example, when a property uses <code>#[Url]</code>, not only does it store its updated value in the query string of the URL, it also references any existing query string values on page load.</p>
<p>For example, if a user visits the URL <code>https://example.com/users?search=bob</code>, Livewire will set the initial value of <code>$search</code> to &quot;bob&quot;.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Url</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowUsers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Url]</span>
    <span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>; <span class="hljs-comment">// Will be set to "bob"...</span>

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h3 id="nullable-properties">Nullable properties</h3>
<p>By default, if a page is loaded with an empty query string entry like <code>?search=</code>, Livewire will treat that value as an empty string. In many cases, this is expected, however there are times when you want <code>?search=</code> to be treated as <code>null</code>.</p>
<p>In these cases, you can use a nullable typehint like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Url</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowUsers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Url]</span>
    <span class="hljs-keyword">public</span> ?string $search; <span class="hljs-comment">// [tl! highlight]</span>

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Because <code>?</code> is present in the above typehint, Livewire will see <code>?search=</code> and set <code>$search</code> to <code>null</code> instead of an empty string.</p>
<p>This works the other way around as well, if you set <code>$this-&gt;search = null</code> in your application, it will be represented in the query string as <code>?search=</code>.</p>
<h2 id="using-an-alias">Using an alias</h2>
<p>Livewire gives you full control over what name displays in the URL's query string. For example, you may have a <code>$search</code> property but want to either obfuscate the actual property name or shorten it to <code>q</code>.</p>
<p>You can specify a query string alias by providing the <code>as</code> parameter to the <code>#[Url]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Url</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowUsers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Url(as: 'q')]</span>
    <span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>;

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now, when a user types &quot;bob&quot; into the search field, the URL will show: <code>https://example.com/users?q=bob</code> instead of <code>?search=bob</code>.</p>
<h2 id="excluding-certain-values">Excluding certain values</h2>
<p>By default, Livewire will only put an entry in the query string when it's value has changed from what it was at initialization. Most of the time, this is the desired behavior, however, there are certain scenarios where you may want more control over which value Livewire excludes from the query string. In these cases you can use the <code>except</code> parameter.</p>
<p>For example, in the component below, the initial value of <code>$search</code> is modified in <code>mount()</code>. To ensure the browser will only ever exclude <code>search</code> from the query string if the <code>search</code> value is an empty string, the <code>except</code> parameter has been added to <code>#[Url]</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Url</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowUsers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Url(except: '')]</span>
    <span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">$this</span>-&gt;search = auth()-&gt;user()-&gt;username;
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Without <code>except</code> in the above example, Livewire would remove the <code>search</code> entry from the query string any time the value of <code>search</code> is equal to the initial value of <code>auth()-&gt;user()-&gt;username</code>. Instead, because <code>except: ''</code> has been used, Livewire will preserve all query string values except when <code>search</code> is an empty string.</p>
<h2 id="display-on-page-load">Display on page load</h2>
<p>By default, Livewire will only display a value in the query string after the value has been changed on the page. For example, if the default value for <code>$search</code> is an empty string: <code>&quot;&quot;</code>, when the actual search input is empty, no value will appear in the URL.</p>
<p>If you want the <code>?search</code> entry to always be included in the query string, even when the value is empty, you can provide the <code>keep</code> parameter to the <code>#[Url]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Url</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowUsers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Url(keep: true)]</span>
    <span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>;

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Now, when the page loads, the URL will be changed to the following: <code>https://example.com/users?search=</code></p>
<h2 id="storing-in-history">Storing in history</h2>
<p>By default, Livewire uses <a href="https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState"><code>history.replaceState()</code></a> to modify the URL instead of <a href="https://developer.mozilla.org/en-US/docs/Web/API/History/pushState"><code>history.pushState()</code></a>. This means that when Livewire updates the query string, it modifies the current entry in the browser's history state instead of adding a new one.</p>
<p>Because Livewire &quot;replaces&quot; the current history, pressing the &quot;back&quot; button in the browser will go to the previous page rather than the previous <code>?search=</code> value.</p>
<p>To force Livewire to use <code>history.pushState</code> when updating the URL, you can provide the <code>history</code> parameter to the <code>#[Url]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Url</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowUsers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Url(history: true)]</span>
    <span class="hljs-keyword">public</span> $search = <span class="hljs-string">''</span>;

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>In the example above, when a user changes the search value from &quot;bob&quot; to &quot;frank&quot; and then clicks the browser's back button, the search value (and the URL) will be set back to &quot;bob&quot; instead of navigating to the previously visited page.</p>
<h2 id="using-the-querystring-method">Using the queryString method</h2>
<p>The query string can also be defined as a method on the component. This can be useful if some properties have dynamic options.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowUsers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryString</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'search'</span> =&gt; [
                <span class="hljs-string">'as'</span> =&gt; <span class="hljs-string">'q'</span>,
            ],
        ];
    }
}
</div></code></pre>
<h2 id="trait-hooks">Trait hooks</h2>
<p>Livewire offers <a href="/docs/lifecycle-hooks">hooks</a> for query strings as well.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">trait</span> WithSorting
{
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryStringWithSorting</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'sortBy'</span> =&gt; [<span class="hljs-string">'as'</span> =&gt; <span class="hljs-string">'sort'</span>],
            <span class="hljs-string">'sortDirection'</span> =&gt; [<span class="hljs-string">'as'</span> =&gt; <span class="hljs-string">'direction'</span>],
        ];
    }
}
</div></code></pre>
<pre class="hljs"><code><div>
## File: validation.md
```md
Livewire aims to make validating a user's input and giving them feedback as pleasant as possible. By building on top of Laravel's validation features, Livewire leverages your existing knowledge while also providing you with robust, additional features like real-time validation.

Here's an example `CreatePost` component that demonstrates the most basic validation workflow in Livewire:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;
use App\Models\Post;

class CreatePost extends Component
{
	public $title = '';

    public $content = '';

    public function save()
    {
        $validated = $this-&gt;validate([ // [tl! highlight:3]
			'title' =&gt; 'required|min:3',
			'content' =&gt; 'required|min:3',
        ]);

		Post::create($validated);

		return redirect()-&gt;to('/posts');
    }

    public function render()
    {
        return view('livewire.create-post');
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
	&lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;
    &lt;div&gt;@error('title') {{ $message }} @enderror&lt;/div&gt;

	&lt;textarea wire:model=&quot;content&quot;&gt;&lt;/textarea&gt;
    &lt;div&gt;@error('content') {{ $message }} @enderror&lt;/div&gt;

	&lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>As you can see, Livewire provides a <code>validate()</code> method that you can call to validate your component's properties. It returns the validated set of data that you can then safely insert into the database.</p>
<p>On the frontend, you can use Laravel's existing Blade directives to show validation messages to your users.</p>
<p>For more information, see <a href="https://laravel.com/docs/blade#validation-errors">Laravel's documentation on rendering validation errors in Blade</a>.</p>
<h2 id="validate-attributes">Validate attributes</h2>
<p>If you prefer to co-locate your component's validation rules with the properties directly, you can use Livewire's <code>#[Validate]</code> attribute.</p>
<p>By associating validation rules with properties using <code>#[Validate]</code>, Livewire will automatically run the properties validation rules before each update. However, you should still run <code>$this-&gt;validate()</code> before persisting data to a database so that properties that haven't been updated are also validated.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Validate('required|min:3')] // [tl! highlight]</span>
	<span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required|min:3')] // [tl! highlight]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate();

		Post::create([
            <span class="hljs-string">'title'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;title,
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;content,
		]);

		<span class="hljs-keyword">return</span> redirect()-&gt;to(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<blockquote>
<p>[!info] Validate attributes don't support Rule objects
PHP Attributes are restricted to certain syntaxes like plain strings and arrays. If you find yourself wanting to use run-time syntaxes like Laravel's Rule objects (<code>Rule::exists(...)</code>) you should instead <a href="#defining-a-rules-method">define a <code>rules()</code> method</a> in your component.</p>
<p>Learn more in the documentation on <a href="#using-laravel-rule-objects">using Laravel Rule objects with Livewire</a>.</p>
</blockquote>
<p>If you prefer more control over when the properties are validated, you can pass a <code>onUpdate: false</code> parameter to the <code>#[Validate]</code> attribute. This will disable any automatic validation and instead assume you want to manually validate the properties using the <code>$this-&gt;validate()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Validate('required|min:3', onUpdate: false)]</span>
	<span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required|min:3', onUpdate: false)]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        $validated = <span class="hljs-keyword">$this</span>-&gt;validate();

		Post::create($validated);

		<span class="hljs-keyword">return</span> redirect()-&gt;to(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h3 id="custom-attribute-name">Custom attribute name</h3>
<p>If you wish to customize the attribute name injected into the validation message, you may do so using the <code>as: </code> parameter:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;

<span class="hljs-comment">#[Validate('required', as: 'date of birth')]</span>
<span class="hljs-keyword">public</span> $dob;
</div></code></pre>
<p>When validation fails in the above snippet, Laravel will use &quot;date of birth&quot; instead of &quot;dob&quot; as the name of the field in the validation message. The generated message will be &quot;The date of birth field is required&quot; instead of &quot;The dob field is required&quot;.</p>
<h3 id="custom-validation-message">Custom validation message</h3>
<p>To bypass Laravel's validation message and replace it with your own, you can use the <code>message: </code> parameter in the <code>#[Validate]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;

<span class="hljs-comment">#[Validate('required', message: 'Please provide a post title')]</span>
<span class="hljs-keyword">public</span> $title;
</div></code></pre>
<p>Now, when the validation fails for this property, the message will  be &quot;Please provide a post title&quot; instead of &quot;The title field is required&quot;.</p>
<p>If you wish to add different messages for different rules, you can simply provide multiple <code>#[Validate]</code> attributes:</p>
<pre class="hljs"><code><div><span class="hljs-comment">#[Validate('required', message: 'Please provide a post title')]</span>
<span class="hljs-comment">#[Validate('min:3', message: 'This title is too short')]</span>
<span class="hljs-keyword">public</span> $title;
</div></code></pre>
<h3 id="opting-out-of-localization">Opting out of localization</h3>
<p>By default, Livewire rule messages and attributes are localized using Laravel's translate helper: <code>trans()</code>.</p>
<p>You can opt-out of localization by passing the <code>translate: false</code> parameter to the <code>#[Validate]</code> attribute:</p>
<pre class="hljs"><code><div><span class="hljs-comment">#[Validate('required', message: 'Please provide a post title', translate: false)]</span>
<span class="hljs-keyword">public</span> $title;
</div></code></pre>
<h3 id="custom-key">Custom key</h3>
<p>When applying validation rules directly to a property using the <code>#[Validate]</code> attribute, Livewire assumes the validation key should be the name of the property itself. However, there are times when you may want to customize the validation key.</p>
<p>For example, you might want to provide separate validation rules for an array property and its children. In this case, instead of passing a validation rule as the first argument to the <code>#[Validate]</code> attribute, you can pass an array of key-value pairs instead:</p>
<pre class="hljs"><code><div><span class="hljs-comment">#[Validate([</span>
    <span class="hljs-string">'todos'</span> =&gt; <span class="hljs-string">'required'</span>,
    <span class="hljs-string">'todos.*'</span> =&gt; [
        <span class="hljs-string">'required'</span>,
        <span class="hljs-string">'min:3'</span>,
        <span class="hljs-keyword">new</span> Uppercase,
    ],
])]
<span class="hljs-keyword">public</span> $todos = [];
</div></code></pre>
<p>Now, when a user updates <code>$todos</code>, or the <code>validate()</code> method is called, both of these validation rules will be applied.</p>
<h2 id="form-objects">Form objects</h2>
<p>As more properties and validation rules are added to a Livewire component, it can begin to feel too crowded. To alleviate this pain and also provide a helpful abstraction for code reuse, you can use Livewire's <em>Form Objects</em> to store your properties and validation rules.</p>
<p>Below is the same <code>CreatePost</code> example, but now the properties and rules have been extracted to a dedicated form object named <code>PostForm</code>:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Form</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Form</span>
</span>{
    <span class="hljs-comment">#[Validate('required|min:3')]</span>
	<span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required|min:3')]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;
}
</div></code></pre>
<p>The <code>PostForm</code> above can now be defined as a property on the <code>CreatePost</code> component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>\<span class="hljs-title">PostForm</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> PostForm $form;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
		Post::create(
    		<span class="hljs-keyword">$this</span>-&gt;form-&gt;all()
    	);

		<span class="hljs-keyword">return</span> redirect()-&gt;to(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>As you can see, instead of listing out each property individually, we can retrieve all the property values using the <code>-&gt;all()</code> method on the form object.</p>
<p>Also, when referencing the property names in the template, you must prepend <code>form.</code> to each instance:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
	&lt;input type=&quot;text&quot; wire:model=&quot;form.title&quot;&gt;
    &lt;div&gt;@error('form.title') {{ $message }} @enderror&lt;/div&gt;

	&lt;textarea wire:model=&quot;form.content&quot;&gt;&lt;/textarea&gt;
    &lt;div&gt;@error('form.content') {{ $message }} @enderror&lt;/div&gt;

	&lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>When using form objects, <code>#[Validate]</code> attribute validation will be run every time a property is updated. However, if you disable this behavior by specifying <code>onUpdate: false</code> on the attribute, you can manually run a form object's validation using <code>$this-&gt;form-&gt;validate()</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
</span>{
    Post::create(
        <span class="hljs-keyword">$this</span>-&gt;form-&gt;validate()
    );

    <span class="hljs-keyword">return</span> redirect()-&gt;to(<span class="hljs-string">'/posts'</span>);
}
</div></code></pre>
<p>Form objects are a useful abstraction for most larger datasets and a variety of additional features that make them even more powerful. For more information, check out the comprehensive <a href="/docs/forms#extracting-a-form-object">form object documentation</a>.</p>
<h2 id="real-time-validation">Real-time validation</h2>
<p>Real-time validation is the term used for when you validate a user's input as they fill out a form rather than waiting for the form submission.</p>
<p>By using <code>#[Validate]</code> attributes directly on Livewire properties, any time a network request is sent to update a property's value on the server, the provided validation rules will be applied.</p>
<p>This means to provide a real-time validation experience for your users on a specific input, no extra backend work is required. The only thing that is required is using <code>wire:model.live</code> or <code>wire:model.blur</code> to instruct Livewire to trigger network requests as the fields are filled out.</p>
<p>In the below example, <code>wire:model.blur</code> has been added to the text input. Now, when a user types in the field and then tabs or clicks away from the field, a network request will be triggered with the updated value and the validation rules will run:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model.blur=&quot;title&quot;&gt;

    &lt;!-- --&gt;
&lt;/form&gt;
</div></code></pre>
<p>If you are using a <code>rules()</code> method to declare your validation rules for a property instead of the <code>#[Validate]</code> attribute, you can still include a #[Validate] attribute with no parameters to retain the real-time validating behavior:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Validate] // [tl! highlight]</span>
	<span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rules</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'title'</span> =&gt; <span class="hljs-string">'required|min:5'</span>,
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-string">'required|min:5'</span>,
        ];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        $validated = <span class="hljs-keyword">$this</span>-&gt;validate();

		Post::create($validated);

		<span class="hljs-keyword">return</span> redirect()-&gt;to(<span class="hljs-string">'/posts'</span>);
    }
</div></code></pre>
<p>Now, in the above example, even though <code>#[Validate]</code> is empty, it will tell Livewire to run the fields validation provided by <code>rules()</code> everytime the property is updated.</p>
<h2 id="customizing-error-messages">Customizing error messages</h2>
<p>Out-of-the-box, Laravel provides sensible validation messages like &quot;The title field is required.&quot; if the <code>$title</code> property has the <code>required</code> rule attached to it.</p>
<p>However, you may need to customize the language of these error messages to better suite your application and its users.</p>
<h3 id="custom-attribute-names">Custom attribute names</h3>
<p>Sometimes the property you are validating has a name that isn't suited for displaying to users. For example, if you have a database field in your app named <code>dob</code> that stands for &quot;Date of birth&quot;, you would want to show your users &quot;The date of birth field is required&quot; instead of &quot;The dob field is required&quot;.</p>
<p>Livewire allows you to specify an alternative name for a property using the <code>as: </code> parameter:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;

<span class="hljs-comment">#[Validate('required', as: 'date of birth')]</span>
<span class="hljs-keyword">public</span> $dob = <span class="hljs-string">''</span>;
</div></code></pre>
<p>Now, if the <code>required</code> validation rule fails, the error message will state &quot;The date of birth field is required.&quot; instead of &quot;The dob field is required.&quot;.</p>
<h3 id="custom-messages">Custom messages</h3>
<p>If customizing the property name isn't enough, you can customize the entire validation message using the <code>message: </code> parameter:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;

<span class="hljs-comment">#[Validate('required', message: 'Please fill out your date of birth.')]</span>
<span class="hljs-keyword">public</span> $dob = <span class="hljs-string">''</span>;
</div></code></pre>
<p>If you have multiple rules to customize the message for, it is recommended that you use entirely separate <code>#[Validate]</code> attributes for each, like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;

<span class="hljs-comment">#[Validate('required', message: 'Please enter a title.')]</span>
<span class="hljs-comment">#[Validate('min:5', message: 'Your title is too short.')]</span>
<span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;
</div></code></pre>
<p>If you want to use the <code>#[Validate]</code> attribute's array syntax instead, you can specify custom attributes and messages like so:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;

<span class="hljs-comment">#[Validate([</span>
    <span class="hljs-string">'titles'</span> =&gt; <span class="hljs-string">'required'</span>,
    <span class="hljs-string">'titles.*'</span> =&gt; <span class="hljs-string">'required|min:5'</span>,
], message: [
    <span class="hljs-string">'required'</span> =&gt; <span class="hljs-string">'The :attribute is missing.'</span>,
    <span class="hljs-string">'titles.required'</span> =&gt; <span class="hljs-string">'The :attribute are missing.'</span>,
    <span class="hljs-string">'min'</span> =&gt; <span class="hljs-string">'The :attribute is too short.'</span>,
], attribute: [
    <span class="hljs-string">'titles.*'</span> =&gt; <span class="hljs-string">'title'</span>,
])]
<span class="hljs-keyword">public</span> $titles = [];
</div></code></pre>
<h2 id="defining-a-rules-method">Defining a <code>rules()</code> method</h2>
<p>As an alternative to Livewire's <code>#[Validate]</code> attributes, you can define a method in your component called <code>rules()</code> and return a list of fields and corresponding validation rules. This can be helpful if you are trying to use run-time syntaxes that aren't supported in PHP Attributes, for example, Laravel rule objects like <code>Rule::password()</code>.</p>
<p>These rules will then be applied when you run <code>$this-&gt;validate()</code> inside the component. You also can define the <code>messages()</code> and <code>validationAttributes()</code> functions.</p>
<p>Here's an example:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Validation</span>\<span class="hljs-title">Rule</span> <span class="hljs-title">as</span> <span class="hljs-title">ValidationRule</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rules</span><span class="hljs-params">()</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:6]
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'title'</span> =&gt; ValidationRule::exists(<span class="hljs-string">'posts'</span>, <span class="hljs-string">'title'</span>),
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-string">'required|min:3'</span>,
        ];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">messages</span><span class="hljs-params">()</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:6]
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'content.required'</span> =&gt; <span class="hljs-string">'The :attribute are missing.'</span>,
            <span class="hljs-string">'content.min'</span> =&gt; <span class="hljs-string">'The :attribute is too short.'</span>,
        ];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validationAttributes</span><span class="hljs-params">()</span> // [<span class="hljs-title">tl</span>! <span class="hljs-title">highlight</span>:6]
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-string">'description'</span>,
        ];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate();

		Post::create([
            <span class="hljs-string">'title'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;title,
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;content,
		]);

		<span class="hljs-keyword">return</span> redirect()-&gt;to(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<blockquote>
<p>[!warning] The <code>rules()</code> method doesn't validate on data updates
When defining rules via the <code>rules()</code> method, Livewire will ONLY use these validation rules to validate properties when you run <code>$this-&gt;validate()</code>. This is different than standard <code>#[Validate]</code> attributes which are applied every time a field is updated via something like <code>wire:model</code>. To apply these validation rules to a property every time it's updated, you can still use <code>#[Validate]</code> with no extra parameters.</p>
</blockquote>
<h2 id="using-laravel-rule-objects">Using Laravel Rule objects</h2>
<p>Laravel <code>Rule</code> objects are an extremely powerful way to add advanced validation behavior to your forms.</p>
<p>Here is an example of using Rule objects in conjunction with Livewire's <code>rules()</code> method to achieve more sophisticated validation:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Validation</span>\<span class="hljs-title">Rule</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Form</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Form</span>
</span>{
    <span class="hljs-keyword">public</span> ?Post $post;

    <span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rules</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> [
            <span class="hljs-string">'title'</span> =&gt; [
                <span class="hljs-string">'required'</span>,
                Rule::unique(<span class="hljs-string">'posts'</span>)-&gt;ignore(<span class="hljs-keyword">$this</span>-&gt;post), <span class="hljs-comment">// [tl! highlight]</span>
            ],
            <span class="hljs-string">'content'</span> =&gt; <span class="hljs-string">'required|min:5'</span>,
        ];
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;title = <span class="hljs-keyword">$this</span>-&gt;post-&gt;title;
        <span class="hljs-keyword">$this</span>-&gt;content = <span class="hljs-keyword">$this</span>-&gt;post-&gt;content;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;validate(); <span class="hljs-comment">// [tl! highlight]</span>

        <span class="hljs-keyword">$this</span>-&gt;post-&gt;update(<span class="hljs-keyword">$this</span>-&gt;all());

        <span class="hljs-keyword">$this</span>-&gt;reset();
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h2 id="manually-controlling-validation-errors">Manually controlling validation errors</h2>
<p>Livewire's validation utilities should handle most common validation scenarios; however, there are times when you may want full control over the validation messages in your component.</p>
<p>Below are all the available methods for manipulating the validation errors in your Livewire component:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$this-&gt;addError([key], [message])</code></td>
<td>Manually add a validation message to the error bag</td>
</tr>
<tr>
<td><code>$this-&gt;resetValidation([?key])</code></td>
<td>Reset the validation errors for the provided key, or reset all errors if no key is supplied</td>
</tr>
<tr>
<td><code>$this-&gt;getErrorBag()</code></td>
<td>Retrieve the underlying Laravel error bag used in the Livewire component</td>
</tr>
</tbody>
</table>
<blockquote>
<p>[!info] Using <code>$this-&gt;addError()</code> with Form Objects
When manually adding errors using <code>$this-&gt;addError</code> inside of a form object the key will automatically be prefixed with the name of the property the form is assigned to in the parent component. For example, if in your Component you assign the form to a property called <code>$data</code>, key will become <code>data.key</code>.</p>
</blockquote>
<h2 id="accessing-the-validator-instance">Accessing the validator instance</h2>
<p>Sometimes you may want to access the Validator instance that Livewire uses internally in the <code>validate()</code> method. This is possible using the <code>withValidator</code> method. The closure you provide receives the fully constructed validator as an argument, allowing you to call any of its methods before the validation rules are actually evaluated.</p>
<p>Below is an example of intercepting Livewire's internal validator to manually check a condition and add an additional validation message:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Attributes</span>\<span class="hljs-title">Validate</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-comment">#[Validate('required|min:3')]</span>
	<span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-comment">#[Validate('required|min:3')]</span>
    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boot</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;withValidator(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($validator)</span> </span>{
            $validator-&gt;after(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($validator)</span> </span>{
                <span class="hljs-keyword">if</span> (str(<span class="hljs-keyword">$this</span>-&gt;title)-&gt;startsWith(<span class="hljs-string">'"'</span>)) {
                    $validator-&gt;errors()-&gt;add(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Titles cannot start with quotations'</span>);
                }
            });
        });
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
		Post::create(<span class="hljs-keyword">$this</span>-&gt;all());

		<span class="hljs-keyword">return</span> redirect()-&gt;to(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h2 id="using-custom-validators">Using custom validators</h2>
<p>If you wish to use your own validation system in Livewire, that isn't a problem. Livewire will catch any <code>ValidationException</code> exceptions thrown inside of components and provide the errors to the view just as if you were using Livewire's own <code>validate()</code> method.</p>
<p>Below is an example of the <code>CreatePost</code> component, but instead of using Livewire's validation features, a completely custom validator is being created and applied to the component properties:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">Facades</span>\<span class="hljs-title">Validator</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
	<span class="hljs-keyword">public</span> $title = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $content = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span><span class="hljs-params">()</span>
    </span>{
        $validated = Validator::make(
            <span class="hljs-comment">// Data to validate...</span>
            [<span class="hljs-string">'title'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;title, <span class="hljs-string">'content'</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;content],

            <span class="hljs-comment">// Validation rules to apply...</span>
            [<span class="hljs-string">'title'</span> =&gt; <span class="hljs-string">'required|min:3'</span>, <span class="hljs-string">'content'</span> =&gt; <span class="hljs-string">'required|min:3'</span>],

            <span class="hljs-comment">// Custom validation messages...</span>
            [<span class="hljs-string">'required'</span> =&gt; <span class="hljs-string">'The :attribute field is required'</span>],
         )-&gt;validate();

		Post::create($validated);

		<span class="hljs-keyword">return</span> redirect()-&gt;to(<span class="hljs-string">'/posts'</span>);
    }

    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h2 id="testing-validation">Testing validation</h2>
<p>Livewire provides useful testing utilities for validation scenarios, such as the <code>assertHasErrors()</code> method.</p>
<p>Below is a basic test case that ensures validation errors are thrown if no input is set for the <code>title</code> property:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">Feature</span>\<span class="hljs-title">Livewire</span>;

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">CreatePost</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Livewire</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Tests</span>\<span class="hljs-title">TestCase</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatePostTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cant_create_post_without_title</span><span class="hljs-params">()</span>
    </span>{
        Livewire::test(CreatePost::class)
            -&gt;set(<span class="hljs-string">'content'</span>, <span class="hljs-string">'Sample content...'</span>)
            -&gt;call(<span class="hljs-string">'save'</span>)
            -&gt;assertHasErrors(<span class="hljs-string">'title'</span>);
    }
}
</div></code></pre>
<p>In addition to testing the presence of errors, <code>assertHasErrors</code> allows you to also narrow down the assertion to specific rules by passing the rules to assert against as the second argument to the method:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cant_create_post_with_title_shorter_than_3_characters</span><span class="hljs-params">()</span>
</span>{
    Livewire::test(CreatePost::class)
        -&gt;set(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Sa'</span>)
        -&gt;set(<span class="hljs-string">'content'</span>, <span class="hljs-string">'Sample content...'</span>)
        -&gt;call(<span class="hljs-string">'save'</span>)
        -&gt;assertHasErrors([<span class="hljs-string">'title'</span> =&gt; [<span class="hljs-string">'min:3'</span>]]);
}
</div></code></pre>
<p>You can also assert the presence of validation errors for multiple properties at the same time:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/** <span class="hljs-doctag">@test</span> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cant_create_post_without_title_and_content</span><span class="hljs-params">()</span>
</span>{
    Livewire::test(CreatePost::class)
        -&gt;call(<span class="hljs-string">'save'</span>)
        -&gt;assertHasErrors([<span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>]);
}
</div></code></pre>
<p>For more information on other testing utilities provided by Livewire, check out the <a href="/docs/testing">testing documentation</a>.</p>
<h2 id="deprecated-rule-attribute">Deprecated <code>[#Rule]</code> attribute</h2>
<p>When Livewire v3 first launched, it used the term &quot;Rule&quot; instead of &quot;Validate&quot; for it's validation attributes (<code>#[Rule]</code>).</p>
<p>Because of naming conflicts with Laravel rule objects, this has since been changed to <code>#[Validate]</code>. Both are supported in Livewire v3, however it is recommended that you change all occurrences of <code>#[Rule]</code> with <code>#[Validate]</code> to stay current.</p>
<pre class="hljs"><code><div>
## File: volt.md
```md
&gt; [!warning] Get comfortable with Livewire first
&gt; Before using Volt, we recommend getting familiar with standard, class-based Livewire usage. This will allow you to quickly transfer your knowledge of Livewire into writing components using Volt's functional API.

Volt is an elegantly crafted functional API for Livewire that supports single-file components, allowing a component's PHP logic and Blade templates to coexist in the same file. Behind the scenes, the functional API is compiled to Livewire class components and linked with the template present in the same file.

A simple Volt component looks like the following:

```php
&lt;?php

use function Livewire\Volt\{state};

state(['count' =&gt; 0]);

$increment = fn () =&gt; $this-&gt;count++;

?&gt;

&lt;div&gt;
    &lt;h1&gt;{{ $count }}&lt;/h1&gt;
    &lt;button wire:click=&quot;increment&quot;&gt;+&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<h2 id="installation">Installation</h2>
<p>To get started, install Volt into your project using the Composer package manager:</p>
<pre class="hljs"><code><div>composer require livewire/volt
</div></code></pre>
<p>After installing Volt, you may execute the <code>volt:install</code> Artisan command, which will install Volt's service provider file into your application. This service provider specifies the mounted directories in which Volt will search for single file components:</p>
<pre class="hljs"><code><div>php artisan volt:install
</div></code></pre>
<h2 id="creating-components">Creating components</h2>
<p>You may create a Volt component by placing a file with the <code>.blade.php</code> extension in any of your Volt mounted directories. By default, the <code>VoltServiceProvider</code> mounts the <code>resources/views/livewire</code> and <code>resources/views/pages</code> directories, but you may customize these directories in your Volt service provider's <code>boot</code> method.</p>
<p>For convenience, you may use the <code>make:volt</code> Artisan command to create a new Volt component:</p>
<pre class="hljs"><code><div>php artisan make:volt counter
</div></code></pre>
<p>By adding the <code>--test</code> directive when generating a component, a corresponding test file will also be generated. If you want the associated test to use <a href="https://pestphp.com/">Pest</a>, you should use the <code>--pest</code> flag:</p>
<pre class="hljs"><code><div>php artisan make:volt counter --<span class="hljs-built_in">test</span> --pest
</div></code></pre>
<p>By adding the <code>--class</code> directive it will generate a class-based volt component.</p>
<pre class="hljs"><code><div>php artisan make:volt counter --class
</div></code></pre>
<h2 id="api-style">API style</h2>
<p>By utilizing Volt's functional API, we can define a Livewire component's logic through imported <code>Livewire\Volt</code> functions. Volt then transforms and compiles the functional code into a conventional Livewire class, enabling us to leverage the extensive capabilities of Livewire with reduced boilerplate.</p>
<p>Volt's API automatically binds any closure it uses to the underlying component. So, at any time, actions, computed properties, or listeners can refer to the component using the <code>$this</code> variable:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'count'</span> =&gt; <span class="hljs-number">0</span>]);

$increment = fn () =&gt; <span class="hljs-keyword">$this</span>-&gt;count++;

<span class="hljs-comment">// ...</span>
</div></code></pre>
<h3 id="class-based-volt-components">Class-based Volt components</h3>
<p>If you would like to enjoy the single-file component capabilities of Volt while still writing class-based components, we've got you covered. To get started, define an anonymous class that extends <code>Livewire\Volt\Component</code>. Within the class, you may utilize all of the features of Livewire using traditional Livewire syntax:</p>
<pre class="hljs"><code><div>&lt;?php

use Livewire\Volt\Component;

new class extends Component {
    public $count = 0;

    public function increment()
    {
        $this-&gt;count++;
    }
} ?&gt;

&lt;div&gt;
    &lt;h1&gt;{{ $count }}&lt;/h1&gt;
    &lt;button wire:click=&quot;increment&quot;&gt;+&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<h4 id="class-attributes">Class attributes</h4>
<p>Just like typical Livewire components, Volt components support class attributes. When utilizing anonymous PHP classes, class attributes should be defined after the <code>new</code> keyword:</p>
<pre class="hljs"><code><div>&lt;?php

use Livewire\Attributes\{Layout, Title};
use Livewire\Volt\Component;

new
#[Layout('layouts.guest')]
#[Title('Login')]
class extends Component
{
    public string $name = '';

    // ...
</div></code></pre>
<h4 id="providing-additional-view-data">Providing additional view data</h4>
<p>When using class-based Volt components, the rendered view is the template present in the same file. If you need to pass additional data to the view each time it is rendered, you may use the <code>with</code> method. This data will be passed to the view in addition to the component's public properties:</p>
<pre class="hljs"><code><div>&lt;?php

use Livewire\WithPagination;
use Livewire\Volt\Component;
use App\Models\Post;

new class extends Component {
    use WithPagination;

    public function with(): array
    {
        return [
            'posts' =&gt; Post::paginate(10),
        ];
    }
} ?&gt;

&lt;div&gt;
    &lt;!-- ... --&gt;
&lt;/div&gt;
</div></code></pre>
<h4 id="modifying-the-view-instance">Modifying the view instance</h4>
<p>Sometimes, you may wish to interact with the view instance directly, for example, to set the view's title using a translated string. To achieve this, you may define a <code>rendering</code> method on your component:</p>
<pre class="hljs"><code><div>&lt;?php

use Illuminate\View\View;
use Livewire\Volt\Component;

new class extends Component {
    public function rendering(View $view): void
    {
        $view-&gt;title('Create Post');

        // ...
    }

    // ...
</div></code></pre>
<h2 id="rendering-and-mounting-components">Rendering and mounting components</h2>
<p>Just like a typical Livewire component, Volt components may be rendered using Livewire's tag syntax or the <code>@livewire</code> Blade directive:</p>
<pre class="hljs"><code><div>&lt;livewire:user-index :users=&quot;$users&quot; /&gt;
</div></code></pre>
<p>To declare the component's accepted properties, you may use the <code>state</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state(<span class="hljs-string">'users'</span>);

<span class="hljs-comment">// ...</span>
</div></code></pre>
<p>If necessary, you can intercept the properties passed to the component by providing a closure to the <code>state</code> function, allowing you to interact with and modify the given value:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'count'</span> =&gt; fn ($users) =&gt; count($users)]);
</div></code></pre>
<p>The <code>mount</code> function may be used to define the &quot;mount&quot; <a href="/docs/lifecycle-hooks">lifecycle hook</a> of the Livewire component. The parameters provided to the component will be injected into this method. Any other parameters required by the mount hook will be resolved by Laravel's service container:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Services</span>\<span class="hljs-title">UserCounter</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">mount</span>};

mount(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(UserCounter $counter, $users)</span> </span>{
    $counter-&gt;store(<span class="hljs-string">'userCount'</span>, count($users));

    <span class="hljs-comment">// ...</span>
});
</div></code></pre>
<h3 id="full-page-components">Full-page components</h3>
<p>Optionally, you may render a Volt component as a full page component by defining a Volt route in your application's <code>routes/web.php</code> file:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\<span class="hljs-title">Volt</span>;

Volt::route(<span class="hljs-string">'/users'</span>, <span class="hljs-string">'user-index'</span>);
</div></code></pre>
<p>By default, the component will be rendered using the <code>components.layouts.app</code> layout. You may customize this layout file using the <code>layout</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">layout</span>, <span class="hljs-title">state</span>};

state(<span class="hljs-string">'users'</span>);

layout(<span class="hljs-string">'components.layouts.admin'</span>);

<span class="hljs-comment">// ...</span>
</div></code></pre>
<p>You may also customize the title of the page using the <code>title</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">layout</span>, <span class="hljs-title">state</span>, <span class="hljs-title">title</span>};

state(<span class="hljs-string">'users'</span>);

layout(<span class="hljs-string">'components.layouts.admin'</span>);

title(<span class="hljs-string">'Users'</span>);

<span class="hljs-comment">// ...</span>
</div></code></pre>
<p>If the title relies on component state or an external dependency, you may pass a closure to the <code>title</code> function instead:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">layout</span>, <span class="hljs-title">state</span>, <span class="hljs-title">title</span>};

state(<span class="hljs-string">'users'</span>);

layout(<span class="hljs-string">'components.layouts.admin'</span>);

title(fn () =&gt; <span class="hljs-string">'Users: '</span> . <span class="hljs-keyword">$this</span>-&gt;users-&gt;count());
</div></code></pre>
<h2 id="properties">Properties</h2>
<p>Volt properties, like Livewire properties, are conveniently accessible in the view and persist between Livewire updates. You can define a property using the <code>state</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'count'</span> =&gt; <span class="hljs-number">0</span>]);

<span class="hljs-meta">?&gt;</span>

&lt;div&gt;
    {{ $count }}
&lt;/div&gt;
</div></code></pre>
<p>If the initial value of a state property relies on outside dependencies, such as database queries, models, or container services, its resolution should be encapsulated within a closure. This prevents the value from being resolved until it is absolutely necessary:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'count'</span> =&gt; fn () =&gt; User::count()]);
</div></code></pre>
<p>If the initial value of a state property is being injected via <a href="https://github.com/laravel/folio">Laravel Folio's</a> route model binding, it should also be encapsulated within a closure:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'user'</span> =&gt; fn () =&gt; $user]);
</div></code></pre>
<p>Of course, properties may also be declared without explicitly specifying their initial value. In such cases, their initial value will be <code>null</code> or will be set based on the properties passed into the component when it is rendered:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">mount</span>, <span class="hljs-title">state</span>};

state([<span class="hljs-string">'count'</span>]);

mount(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($users)</span> </span>{
    <span class="hljs-keyword">$this</span>-&gt;count = count($users);

    <span class="hljs-comment">//</span>
});
</div></code></pre>
<h3 id="locked-properties">Locked properties</h3>
<p>Livewire offers the ability to safeguard properties by enabling you to &quot;lock&quot; them, thereby preventing any modifications from occurring on the client-side. To achieve this using Volt, simply chain the <code>locked</code> method on the state you wish to protect:</p>
<pre class="hljs"><code><div>state([<span class="hljs-string">'id'</span>])-&gt;locked();
</div></code></pre>
<h3 id="reactive-properties">Reactive properties</h3>
<p>When working with nested components, you may find yourself in a situation where you need to pass a property from a parent component to a child component, and have the child component <a href="/docs/nesting#reactive-props">automatically update</a> when the parent component updates the property.</p>
<p>To achieve this using Volt, you may chain the <code>reactive</code> method on the state you wish to be reactive:</p>
<pre class="hljs"><code><div>state([<span class="hljs-string">'todos'</span>])-&gt;reactive();
</div></code></pre>
<h3 id="computed-properties">Computed properties</h3>
<p>Livewire also allows you to define <a href="/docs/computed-properties">computed properties</a>, which can be useful for lazily fetching information needed by your component. Computed property results are &quot;memoized&quot;, or cached in memory, for an individual Livewire request lifecycle.</p>
<p>To define a computed property, you may use the <code>computed</code> function. The name of the variable will determine the name of the computed property:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">computed</span>};

$count = computed(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> User::count();
});

<span class="hljs-meta">?&gt;</span>

&lt;div&gt;
    {{ <span class="hljs-keyword">$this</span>-&gt;count }}
&lt;/div&gt;
</div></code></pre>
<p>You may persist the computed property's value in your application's cache by chaining the <code>persist</code> method onto the computed property definition:</p>
<pre class="hljs"><code><div>$count = computed(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> User::count();
})-&gt;persist();
</div></code></pre>
<p>By default, Livewire caches the computed property's value for 3600 seconds. You may customize this value by providing the desired number of seconds to the <code>persist</code> method:</p>
<pre class="hljs"><code><div>$count = computed(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> User::count();
})-&gt;persist(seconds: <span class="hljs-number">10</span>);
</div></code></pre>
<h2 id="actions">Actions</h2>
<p>Livewire <a href="/docs/actions">actions</a> provide a convenient way to listen to page interactions and invoke a corresponding method on your component, resulting in the re-rendering of the component. Often, actions are invoked in response to the user clicking a button.</p>
<p>To define a Livewire action using Volt, you simply need to define a closure. The name of the variable containing the closure will determine the name of the action:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'count'</span> =&gt; <span class="hljs-number">0</span>]);

$increment = fn () =&gt; <span class="hljs-keyword">$this</span>-&gt;count++;

<span class="hljs-meta">?&gt;</span>

&lt;div&gt;
    &lt;h1&gt;{{ $count }}&lt;/h1&gt;
    &lt;button wire:click=<span class="hljs-string">"increment"</span>&gt;+&lt;/button&gt;
&lt;/div&gt;
</div></code></pre>
<p>Within the closure, the <code>$this</code> variable is bound to the underlying Livewire component, giving you the ability to access other methods on the component just as you would in a typical Livewire component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'count'</span> =&gt; <span class="hljs-number">0</span>]);

$increment = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">$this</span>-&gt;dispatch(<span class="hljs-string">'count-updated'</span>);

    <span class="hljs-comment">//</span>
};
</div></code></pre>
<p>Your action may also receive arguments or dependencies from Laravel's service container:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Repositories</span>\<span class="hljs-title">PostRepository</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'postId'</span>]);

$delete = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(PostRepository $posts)</span> </span>{
    $posts-&gt;delete(<span class="hljs-keyword">$this</span>-&gt;postId);

    <span class="hljs-comment">// ...</span>
};
</div></code></pre>
<h3 id="renderless-actions">Renderless actions</h3>
<p>In some cases, your component might declare an action that does not perform any operations that would cause the component's rendered Blade template to change. If that's the case, you can <a href="/docs/actions#skipping-re-renders">skip the rendering phase</a> of Livewire's lifecycle by encapsulating the action within the <code>action</code> function and chaining the <code>renderless</code> method onto its definition:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">action</span>};

$incrementViewCount = action(fn () =&gt; <span class="hljs-keyword">$this</span>-&gt;viewCount++)-&gt;renderless();
</div></code></pre>
<h3 id="protected-helpers">Protected helpers</h3>
<p>By default, all Volt actions are &quot;public&quot; and may be invoked by the client. If you wish to create a function that is <a href="/docs/actions#keep-dangerous-methods-protected-or-private">only accessible from within your actions</a>, you may use the <code>protect</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Repositories</span>\<span class="hljs-title">PostRepository</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">protect</span>, <span class="hljs-title">state</span>};

state([<span class="hljs-string">'postId'</span>]);

$delete = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(PostRepository $posts)</span> </span>{
    <span class="hljs-keyword">$this</span>-&gt;ensurePostCanBeDeleted();

    $posts-&gt;delete(<span class="hljs-keyword">$this</span>-&gt;postId);

    <span class="hljs-comment">// ...</span>
};

$ensurePostCanBeDeleted = protect(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ...</span>
});
</div></code></pre>
<h2 id="forms">Forms</h2>
<p>Livewire's <a href="/docs/forms">forms</a> provide a convenient way to deal with form validation and submission within a single class. To use a Livewire form within a Volt component, you may utilize the <code>form</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Livewire</span>\<span class="hljs-title">Forms</span>\<span class="hljs-title">PostForm</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">form</span>};

form(PostForm::class);

$save = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">$this</span>-&gt;form-&gt;store();

    <span class="hljs-comment">// ...</span>
};

<span class="hljs-meta">?&gt;</span>

&lt;form wire:submit=<span class="hljs-string">"save"</span>&gt;
    &lt;input type=<span class="hljs-string">"text"</span> wire:model=<span class="hljs-string">"form.title"</span>&gt;
    @error(<span class="hljs-string">'form.title'</span>) &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span>="<span class="hljs-title">error</span>"&gt;</span>{{ $message }}&lt;/span&gt; @enderror

    &lt;button type=<span class="hljs-string">"submit"</span>&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>As you can see, the <code>form</code> function accepts the name of a Livewire form class. Once defined, the form can be accessed via the <code>$this-&gt;form</code> property within your component.</p>
<p>If you want to use a different property name for your form, you can pass the name as the second argument to the <code>form</code> function:</p>
<pre class="hljs"><code><div>form(PostForm::class, <span class="hljs-string">'postForm'</span>);

$save = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">$this</span>-&gt;postForm-&gt;store();

    <span class="hljs-comment">// ...</span>
};
</div></code></pre>
<h2 id="listeners">Listeners</h2>
<p>Livewire's global <a href="/docs/events">event system</a> enables communication between components. If two Livewire components exist on a page, they can communicate by utilizing events and listeners. When using Volt, listeners can be defined using the <code>on</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">on</span>};

on([<span class="hljs-string">'eventName'</span> =&gt; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//</span>
}]);
</div></code></pre>
<p>If you need to assign dynamic names to event listeners, such as those based on the authenticated user or data passed to the component, you can pass a closure to the <code>on</code> function. This closure can receive any component parameter, as well as additional dependencies which will be resolved via Laravel's service container:</p>
<pre class="hljs"><code><div>on(fn ($post) =&gt; [
    <span class="hljs-string">'event-'</span>.$post-&gt;id =&gt; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//</span>
    }),
]);
</div></code></pre>
<p>For convenience, component data may also be referenced when defining listeners using &quot;dot&quot; notation:</p>
<pre class="hljs"><code><div>on([<span class="hljs-string">'event-{post.id}'</span> =&gt; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//</span>
}]);
</div></code></pre>
<h2 id="lifecycle-hooks">Lifecycle hooks</h2>
<p>Livewire has a variety of <a href="/docs/lifecycle-hooks">lifecycle hooks</a> that may be used to execute code at various points in a component's lifecycle. Using Volt's convenient API, you can define these lifecycle hooks using their corresponding functions:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">boot</span>, <span class="hljs-title">booted</span>, ...};

boot(fn () =&gt; <span class="hljs-comment">/* ... */</span>);
booted(fn () =&gt; <span class="hljs-comment">/* ... */</span>);
mount(fn () =&gt; <span class="hljs-comment">/* ... */</span>);
hydrate(fn () =&gt; <span class="hljs-comment">/* ... */</span>);
hydrate([<span class="hljs-string">'count'</span> =&gt; fn () =&gt; <span class="hljs-comment">/* ... */</span>]);
dehydrate(fn () =&gt; <span class="hljs-comment">/* ... */</span>);
dehydrate([<span class="hljs-string">'count'</span> =&gt; fn () =&gt; <span class="hljs-comment">/* ... */</span>]);
updating([<span class="hljs-string">'count'</span> =&gt; fn () =&gt; <span class="hljs-comment">/* ... */</span>]);
updated([<span class="hljs-string">'count'</span> =&gt; fn () =&gt; <span class="hljs-comment">/* ... */</span>]);
</div></code></pre>
<h2 id="lazy-loading-placeholders">Lazy loading placeholders</h2>
<p>When rendering Livewire components, you may pass the <code>lazy</code> parameter to a Livewire component to <a href="/docs/lazy">defer its loading</a> until the initial page is fully loaded. By default, Livewire inserts <code>&lt;div&gt;&lt;/div&gt;</code> tags into the DOM where the component will be loaded.</p>
<p>If you would like to customize the HTML that is displayed within the component's placeholder while the initial page is loaded, you may use the <code>placeholder</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">placeholder</span>};

placeholder(<span class="hljs-string">'&lt;div&gt;Loading...&lt;/div&gt;'</span>);
</div></code></pre>
<h2 id="validation">Validation</h2>
<p>Livewire offers easy access to Laravel's powerful <a href="/docs/validation">validation features</a>. Using Volt's API, you may define your component's validation rules using the <code>rules</code> function. Like traditional Livewire components, these rules will be applied to your component data when you invoke the <code>validate</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">rules</span>};

rules([<span class="hljs-string">'name'</span> =&gt; <span class="hljs-string">'required|min:6'</span>, <span class="hljs-string">'email'</span> =&gt; <span class="hljs-string">'required|email'</span>]);

$submit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">$this</span>-&gt;validate();

    <span class="hljs-comment">// ...</span>
};

<span class="hljs-meta">?&gt;</span>

&lt;form wire:submit.prevent=<span class="hljs-string">"submit"</span>&gt;
    <span class="hljs-comment">//</span>
&lt;/form&gt;
</div></code></pre>
<p>If you need to define rules dynamically, such as rules based on the authenticated user or a information from your database, you can provide a closure to the <code>rules</code> function:</p>
<pre class="hljs"><code><div>rules(fn () =&gt; [
    <span class="hljs-string">'name'</span> =&gt; [<span class="hljs-string">'required'</span>, <span class="hljs-string">'min:6'</span>],
    <span class="hljs-string">'email'</span> =&gt; [<span class="hljs-string">'required'</span>, <span class="hljs-string">'email'</span>, <span class="hljs-string">'not_in:'</span>.Auth::user()-&gt;email]
]);
</div></code></pre>
<h3 id="error-messages-and-attributes">Error messages and attributes</h3>
<p>To modify the validation messages or attributes used during validation, you can chain the <code>messages</code> and <code>attributes</code> methods onto your <code>rules</code> definition:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">rules</span>};

rules([<span class="hljs-string">'name'</span> =&gt; <span class="hljs-string">'required|min:6'</span>, <span class="hljs-string">'email'</span> =&gt; <span class="hljs-string">'required|email'</span>])
    -&gt;messages([
        <span class="hljs-string">'email.required'</span> =&gt; <span class="hljs-string">'The :attribute may not be empty.'</span>,
        <span class="hljs-string">'email.email'</span> =&gt; <span class="hljs-string">'The :attribute format is invalid.'</span>,
    ])-&gt;attributes([
        <span class="hljs-string">'email'</span> =&gt; <span class="hljs-string">'email address'</span>,
    ]);
</div></code></pre>
<h2 id="file-uploads">File uploads</h2>
<p>When using Volt, <a href="/docs/uploads">uploading and storing files</a> is much easier thanks to Livewire. To include the <code>Livewire\WithFileUploads</code> trait on your functional Volt component, you may use the <code>usesFileUploads</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>, <span class="hljs-title">usesFileUploads</span>};

usesFileUploads();

state([<span class="hljs-string">'photo'</span>]);

$save = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">$this</span>-&gt;validate([
        <span class="hljs-string">'photo'</span> =&gt; <span class="hljs-string">'image|max:1024'</span>,
    ]);

    <span class="hljs-keyword">$this</span>-&gt;photo-&gt;store(<span class="hljs-string">'photos'</span>);
};
</div></code></pre>
<h2 id="url-query-parameters">URL query parameters</h2>
<p>Sometimes it's useful to <a href="/docs/url">update the browser's URL query parameters</a> when your component state changes. In these cases, you can use the <code>url</code> method to instruct Livewire to sync the URL query parameters with a piece of component state:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">computed</span>, <span class="hljs-title">state</span>};

state([<span class="hljs-string">'search'</span>])-&gt;url();

$posts = computed(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Post::where(<span class="hljs-string">'title'</span>, <span class="hljs-string">'like'</span>, <span class="hljs-string">'%'</span>.<span class="hljs-keyword">$this</span>-&gt;search.<span class="hljs-string">'%'</span>)-&gt;get();
});

<span class="hljs-meta">?&gt;</span>

&lt;div&gt;
    &lt;input wire:model.live=<span class="hljs-string">"search"</span> type=<span class="hljs-string">"search"</span> placeholder=<span class="hljs-string">"Search posts by title..."</span>&gt;

    &lt;h1&gt;Search Results:&lt;/h1&gt;

    &lt;ul&gt;
        @<span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">$this</span>-&gt;posts <span class="hljs-keyword">as</span> $post)
            &lt;li wire:key=<span class="hljs-string">"{{ $post-&gt;id }}"</span>&gt;{{ $post-&gt;title }}&lt;/li&gt;
        @<span class="hljs-keyword">endforeach</span>
    &lt;/ul&gt;
&lt;/div&gt;
</div></code></pre>
<p>Additional URL query parameters options supported by Livewire, such as URL query parameters aliases, may also be provided to the <code>url</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">Post</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'page'</span> =&gt; <span class="hljs-number">1</span>])-&gt;url(<span class="hljs-keyword">as</span>: <span class="hljs-string">'p'</span>, history: <span class="hljs-keyword">true</span>, keep: <span class="hljs-keyword">true</span>);

<span class="hljs-comment">// ...</span>
</div></code></pre>
<h2 id="pagination">Pagination</h2>
<p>Livewire and Volt also have complete support for <a href="/docs/pagination">pagination</a>. To include Livewire's <code>Livewire\WithPagination</code> trait on your functional Volt component, you may use the <code>usesPagination</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">with</span>, <span class="hljs-title">usesPagination</span>};

usesPagination();

with(fn () =&gt; [<span class="hljs-string">'posts'</span> =&gt; Post::paginate(<span class="hljs-number">10</span>)]);

<span class="hljs-meta">?&gt;</span>

&lt;div&gt;
    @<span class="hljs-keyword">foreach</span> ($posts <span class="hljs-keyword">as</span> $post)
        <span class="hljs-comment">//</span>
    @<span class="hljs-keyword">endforeach</span>

    {{ $posts-&gt;links() }}
&lt;/div&gt;
</div></code></pre>
<p>Like Laravel, Livewire's default pagination view uses Tailwind classes for styling. If you use Bootstrap in your application, you can enable the Bootstrap pagination theme by specifying your desired theme when invoking the <code>usesPagination</code> function:</p>
<pre class="hljs"><code><div>usesPagination(theme: <span class="hljs-string">'bootstrap'</span>);
</div></code></pre>
<h2 id="custom-traits-and-interfaces">Custom traits and interfaces</h2>
<p>To include any arbitrary trait or interface on your functional Volt component, you may use the <code>uses</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">uses</span>};

<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Contracts</span>\<span class="hljs-title">Sorting</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Concerns</span>\<span class="hljs-title">WithSorting</span>;

uses([Sorting::class, WithSorting::class]);
</div></code></pre>
<h2 id="anonymous-components">Anonymous components</h2>
<p>Sometimes, you may want to convert a small portion of a page into a Volt component without extracting it into a separate file. For example, imagine a Laravel route that returns the following view:</p>
<pre class="hljs"><code><div>Route::get(<span class="hljs-string">'/counter'</span>, fn () =&gt; view(<span class="hljs-string">'pages/counter.blade.php'</span>));
</div></code></pre>
<p>The view's content is a typical Blade template, including layout definitions and slots. However, by wrapping a portion of the view within the <code>@volt</code> Blade directive, we can convert that piece of the view into a fully-functional Volt component:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state([<span class="hljs-string">'count'</span> =&gt; <span class="hljs-number">0</span>]);

$increment = fn () =&gt; <span class="hljs-keyword">$this</span>-&gt;count++;

<span class="hljs-meta">?&gt;</span>

&lt;x-app-layout&gt;
    &lt;x-slot name=<span class="hljs-string">"header"</span>&gt;
        Counter
    &lt;/x-slot&gt;

    @volt(<span class="hljs-string">'counter'</span>)
        &lt;div&gt;
            &lt;h1&gt;{{ $count }}&lt;/h1&gt;
            &lt;button wire:click=<span class="hljs-string">"increment"</span>&gt;+&lt;/button&gt;
        &lt;/div&gt;
    @endvolt
&lt;/x-app-layout&gt;
</div></code></pre>
<h4 id="passing-data-to-anonymous-components">Passing data to anonymous components</h4>
<p>When rendering a view that contains an anonymous component, all of the data given to the view will also be available to the anonymous Volt component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Models</span>\<span class="hljs-title">User</span>;

Route::get(<span class="hljs-string">'/counter'</span>, fn () =&gt; view(<span class="hljs-string">'users.counter'</span>, [
    <span class="hljs-string">'count'</span> =&gt; User::count(),
]));
</div></code></pre>
<p>Of course, you may declare this data as &quot;state&quot; on your Volt component. When initializing state from data proxied to the component by the view, you only need to declare the name of the state variable. Volt will automatically hydrate the state's default value using the proxied view data:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

<span class="hljs-keyword">use</span> <span class="hljs-title">function</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\{<span class="hljs-title">state</span>};

state(<span class="hljs-string">'count'</span>);

$increment = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Store the new count value in the database...</span>

    <span class="hljs-keyword">$this</span>-&gt;count++;
};

<span class="hljs-meta">?&gt;</span>

&lt;x-app-layout&gt;
    &lt;x-slot name=<span class="hljs-string">"header"</span>&gt;
        Initial value: {{ $count }}
    &lt;/x-slot&gt;

    @volt(<span class="hljs-string">'counter'</span>)
        &lt;div&gt;
            &lt;h1&gt;{{ $count }}&lt;/h1&gt;
            &lt;button wire:click=<span class="hljs-string">"increment"</span>&gt;+&lt;/button&gt;
        &lt;/div&gt;
    @endvolt
&lt;/x-app-layout&gt;
</div></code></pre>
<h2 id="testing-components">Testing components</h2>
<p>To begin testing a Volt component, you may invoke the <code>Volt::test</code> method, providing the name of the component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Volt</span>\<span class="hljs-title">Volt</span>;

it(<span class="hljs-string">'increments the counter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    Volt::test(<span class="hljs-string">'counter'</span>)
        -&gt;assertSee(<span class="hljs-string">'0'</span>)
        -&gt;call(<span class="hljs-string">'increment'</span>)
        -&gt;assertSee(<span class="hljs-string">'1'</span>);
});
</div></code></pre>
<p>When testing a Volt component, you may utilize all of the methods provided by the standard <a href="/docs/testing">Livewire testing API</a>.</p>
<p>If your Volt component is nested, you may use &quot;dot&quot; notation to specify the component that you wish to test:</p>
<pre class="hljs"><code><div>Volt::test(<span class="hljs-string">'users.stats'</span>)
</div></code></pre>
<p>When testing a page that contains an anonymous Volt component, you may use the <code>assertSeeVolt</code> method to assert that the component is rendered:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">$this</span>-&gt;get(<span class="hljs-string">'/users'</span>)
    -&gt;assertSeeVolt(<span class="hljs-string">'stats'</span>);
</div></code></pre>
<pre class="hljs"><code><div>
## File: wire-click.md
```md

Livewire provides a simple `wire:click` directive for calling component methods (aka actions) when a user clicks a specific element on the page.

For example, given the `ShowInvoice` component below:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;
use App\Models\Invoice;

class ShowInvoice extends Component
{
    public Invoice $invoice;

    public function download()
    {
        return response()-&gt;download(
            $this-&gt;invoice-&gt;file_path, 'invoice.pdf'
        );
    }
}
</div></code></pre>
<p>You can trigger the <code>download()</code> method from the class above when a user clicks a &quot;Download Invoice&quot; button by adding <code>wire:click=&quot;download&quot;</code>:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">wire:click</span>=<span class="hljs-string">"download"</span>&gt;</span> <span class="hljs-comment">&lt;!-- [tl! highlight] --&gt;</span>
    Download Invoice
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<h2 id="using-wireclick-on-links">Using <code>wire:click</code> on links</h2>
<p>When using <code>wire:click</code> on <code>&lt;a&gt;</code> tags, you must append <code>.prevent</code> to prevent the default handling of a link in the browser. Otherwise, the browser will visit the provided link and update the page's URL.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">wire:click.prevent</span>=<span class="hljs-string">"..."</span>&gt;</span>
</div></code></pre>
<h2 id="going-deeper">Going deeper</h2>
<p>The <code>wire:click</code> directive is just one of many different available event listeners in Livewire. For full documentation on its (and other event listeners) capabilities, visit <a href="/docs/actions">the Livewire actions documentation page</a>.</p>
<pre class="hljs"><code><div>
## File: wire-confirm.md
```md

Before performing dangerous actions in Livewire, you may want to provide your users with some sort of visual confirmation.

Livewire makes this easy to do by adding `wire:confirm` in addition to any action (`wire:click`, `wire:submit`, etc.).

Here's an example of adding a confirmation dialog to a &quot;Delete post&quot; button:

```blade
&lt;button
    type=&quot;button&quot;
    wire:click=&quot;delete&quot;
    wire:confirm=&quot;Are you sure you want to delete this post?&quot;
&gt;
    Delete post &lt;!-- [tl! highlight:-2,1] --&gt;
&lt;/button&gt;
</div></code></pre>
<p>When a user clicks &quot;Delete post&quot;, Livewire will trigger a confirmation dialog (The default browser confirmation alert). If the user hits escape or presses cancel, the action won't be performed. If they press &quot;OK&quot;, the action will be completed.</p>
<h2 id="prompting-users-for-input">Prompting users for input</h2>
<p>For even more dangerous actions such as deleting a user's account entirely, you may want to present them with a confirmation prompt which they would need to type in a specific string of characters to confirm the action.</p>
<p>Livewire provides a helpful <code>.prompt</code> modifier, that when applied to <code>wire:confirm</code>, it will prompt the user for input and only confirm the action if the input matches (case-sensitive) the provided string (designated by a &quot;|&quot; (pipe) character at the end if the <code>wire:confirm</code> value):</p>
<pre class="hljs"><code><div>&lt;button
    type=&quot;button&quot;
    wire:click=&quot;delete&quot;
    wire:confirm.prompt=&quot;Are you sure?\n\nType DELETE to confirm|DELETE&quot;
&gt;
    Delete account &lt;!-- [tl! highlight:-2,1] --&gt;
&lt;/button&gt;
</div></code></pre>
<p>When a user presses &quot;Delete account&quot;, the action will only be performed if &quot;DELETE&quot; is entered into the prompt, otherwise, the action will be cancelled.</p>
<pre class="hljs"><code><div>
## File: wire-dirty.md
```md

In a traditional HTML page containing a form, the form is only ever submitted when the user presses the &quot;Submit&quot; button.

However, Livewire is capable of much more than traditional form submissions. You can validate form inputs in real-time or even save the form as a user types.

In these &quot;real-time&quot; update scenarios, it can be helpful to signal to your users when a form or subset of a form has been changed, but hasn't been saved to the database.

When a form contains un-saved input, that form is considered &quot;dirty&quot;. It only becomes &quot;clean&quot; when a network request has been triggered to synchronize the server state with the client-side state.

## Basic usage

Livewire allows you to easily toggle visual elements on the page using the `wire:dirty` directive.

By adding `wire:dirty` to an element, you are instructing Livewire to only show the element when the client-side state diverges from the server-side state.

To demonstrate, here is an example of an `UpdatePost` form containing a visual &quot;Unsaved changes...&quot; indication that signals to the user that the form contains input that has not been saved:

```blade
&lt;form wire:submit=&quot;update&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;

    &lt;!-- ... --&gt;

    &lt;button type=&quot;submit&quot;&gt;Update&lt;/button&gt;

    &lt;div wire:dirty&gt;Unsaved changes...&lt;/div&gt; &lt;!-- [tl! highlight] --&gt;
&lt;/form&gt;
</div></code></pre>
<p>Because <code>wire:dirty</code> has been added to the &quot;Unsaved changes...&quot; message, the message will be hidden by default. Livewire will automatically display the message when the user starts modifying the form inputs.</p>
<p>When the user submits the form, the message will disappear again, since the server / client data is back in sync.</p>
<h3 id="removing-elements">Removing elements</h3>
<p>By adding the <code>.remove</code> modifier to <code>wire:dirty</code>, you can instead show an element by default and only hide it when the component has &quot;dirty&quot; state:</p>
<pre class="hljs"><code><div>&lt;div wire:dirty.remove&gt;The data is in-sync...&lt;/div&gt;
</div></code></pre>
<h2 id="targeting-property-updates">Targeting property updates</h2>
<p>Imagine you are using <code>wire:model.blur</code> to update a property on the server immediately after a user leaves an input field. In this scenario, you can provide a &quot;dirty&quot; indication for only that property by adding <code>wire:target</code> to the element that contains the <code>wire:dirty</code> directive.</p>
<p>Here is an example of only showing a dirty indication when the title property has been changed:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;update&quot;&gt;
    &lt;input wire:model.blur=&quot;title&quot;&gt;

    &lt;div wire:dirty wire:target=&quot;title&quot;&gt;Unsaved title...&lt;/div&gt; &lt;!-- [tl! highlight] --&gt;

    &lt;button type=&quot;submit&quot;&gt;Update&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<h2 id="toggling-classes">Toggling classes</h2>
<p>Often, instead of toggling entire elements, you may want to toggle individual CSS classes on an input when its state is &quot;dirty&quot;.</p>
<p>Below is an example where a user types into an input field and the border becomes yellow, indicating an &quot;unsaved&quot; state. Then, when the user tabs away from the field, the border is removed, indicating that the state has been saved on the server:</p>
<pre class="hljs"><code><div>&lt;input wire:model.blur=&quot;title&quot; wire:dirty.class=&quot;border-yellow-500&quot;&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: wire-ignore.md
```md

Livewire's ability to make updates to the page is what makes it &quot;live&quot;, however, there are times when you might want to prevent Livewire from updating a portion of the page.

In these cases, you can use the `wire:ignore` directive to instruct Livewire to ignore the contents of a particular element, even if they change between requests.

This is most useful in the context of working with third-party javascript libraries for custom form inputs and such.

Below is an example of wrapping an element used by a third-party library in `wire:ignore` so that Livewire doesn't tamper with the HTML generated by the library:

```blade
&lt;form&gt;
    &lt;!-- ... --&gt;

    &lt;div wire:ignore&gt;
        &lt;!-- This element would be reference by a --&gt;
        &lt;!-- third-party library for initialization... --&gt;
        &lt;input id=&quot;id-for-date-picker-library&quot;&gt;
    &lt;/div&gt;

    &lt;!-- ... --&gt;
&lt;/form&gt;
</div></code></pre>
<p>You can also instruct Livewire to only ignore changes to attributes of the root element rather than observing changes to it's contents using <code>wire:ignore.self</code>.</p>
<pre class="hljs"><code><div>&lt;div wire:ignore.self&gt;
    &lt;!-- ... --&gt;
&lt;/div&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: wire-init.md
```md

Livewire offers a `wire:init` directive to run an action as soon as the component is rendered. This can be helpful in cases where you don't want to hold up the entire page load, but want to load some data immediately after the page load.

```blade
&lt;div wire:init=&quot;loadPosts&quot;&gt;
    &lt;!-- ... --&gt;
&lt;/div&gt;
</div></code></pre>
<p>The <code>loadPosts</code> action will be run immediately after the Livewire component renders on the page.</p>
<p>In most cases however, <a href="/docs/lazy">Livewire's lazy loading feature</a> is preferable to using <code>wire:init</code>.</p>
<pre class="hljs"><code><div>
## File: wire-loading.md
```md

Loading indicators are an important part of crafting good user interfaces. They give users visual feedback when a request is being made to the server, so they know they are waiting for a process to complete.

## Basic usage

Livewire provides a simple yet extremely powerful syntax for controlling loading indicators: `wire:loading`. Adding `wire:loading` to any element will hide it by default (using `display: none` in CSS) and show it when a request is sent to the server.

Below is a basic example of a `CreatePost` component's form with `wire:loading` being used to toggle a loading message:

```blade
&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;!-- ... --&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;

    &lt;div wire:loading&gt; &lt;!-- [tl! highlight:2] --&gt;
        Saving post...
    &lt;/div&gt;
&lt;/form&gt;
</div></code></pre>
<p>When a user presses &quot;Save&quot;, the &quot;Saving post...&quot; message will appear below the button while the &quot;save&quot; action is being executed. The message will disappear when the response is received from the server and processed by Livewire.</p>
<h3 id="removing-elements">Removing elements</h3>
<p>Alternatively, you can append <code>.remove</code> for the inverse effect, showing an element by default and hiding it during requests to the server:</p>
<pre class="hljs"><code><div>&lt;div wire:loading.remove&gt;...&lt;/div&gt;
</div></code></pre>
<h2 id="toggling-classes">Toggling classes</h2>
<p>In addition to toggling the visibility of entire elements, it's often useful to change the styling of an existing element by toggling CSS classes on and off during requests to the server. This technique can be used for things like changing background colors, lowering opacity, triggering spinning animations, and more.</p>
<p>Below is a simple example of using the <a href="https://tailwindcss.com/">Tailwind</a> class <code>opacity-50</code> to make the &quot;Save&quot; button fainter while the form is being submitted:</p>
<pre class="hljs"><code><div>&lt;button wire:loading.class=&quot;opacity-50&quot;&gt;Save&lt;/button&gt;
</div></code></pre>
<p>Like toggling an element, you can perform the inverse class operation by appending <code>.remove</code> to the <code>wire:loading</code> directive. In the example below, the button's <code>bg-blue-500</code> class will be removed when the &quot;Save&quot; button is pressed:</p>
<pre class="hljs"><code><div>&lt;button class=&quot;bg-blue-500&quot; wire:loading.class.remove=&quot;bg-blue-500&quot;&gt;
    Save
&lt;/button&gt;
</div></code></pre>
<h2 id="toggling-attributes">Toggling attributes</h2>
<p>By default, when a form is submitted, Livewire will automatically disable the submit button and add the <code>readonly</code> attribute to each input element while the form is being processed.</p>
<p>However, in addition to this default behavior, Livewire offers the <code>.attr</code> modifier to allow you to toggle other attributes on an element or toggle attributes on elements that are outside of forms:</p>
<pre class="hljs"><code><div>&lt;button
    type=&quot;button&quot;
    wire:click=&quot;remove&quot;
    wire:loading.attr=&quot;disabled&quot;
&gt;
    Remove
&lt;/button&gt;
</div></code></pre>
<p>Because the button above isn't a submit button, it won't be disabled by Livewire's default form handling behavior when pressed. Instead, we manually added <code>wire:loading.attr=&quot;disabled&quot;</code> to achieve this behavior.</p>
<h2 id="targeting-specific-actions">Targeting specific actions</h2>
<p>By default, <code>wire:loading</code> will be triggered whenever a component makes a request to the server.</p>
<p>However, in components with multiple elements that can trigger server requests, you should scope your loading indicators down to individual actions.</p>
<p>For example, consider the following &quot;Save post&quot; form. In addition to a &quot;Save&quot; button that submits the form, there might also be a &quot;Remove&quot; button that executes a &quot;remove&quot; action on the component.</p>
<p>By adding <code>wire:target</code> to the following <code>wire:loading</code> element, you can instruct Livewire to only show the loading message when the &quot;Remove&quot; button is clicked:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;!-- ... --&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;

    &lt;button type=&quot;button&quot; wire:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;

    &lt;div wire:loading wire:target=&quot;remove&quot;&gt;  &lt;!-- [tl! highlight:2] --&gt;
        Removing post...
    &lt;/div&gt;
&lt;/form&gt;
</div></code></pre>
<p>When the above &quot;Remove&quot; button is pressed, the &quot;Removing post...&quot; message will be displayed to the user. However, the message will not be displayed when the &quot;Save&quot; button is pressed.</p>
<h3 id="targeting-multiple-actions">Targeting multiple actions</h3>
<p>You may find yourself in a situation where you would like <code>wire:loading</code> to react to some, but not all, actions on a page. In these cases you can pass multiple actions into <code>wire:target</code> separated by a comma. For example:</p>
<p>``blade</p>
<form wire:submit="save">
    <input type="text" wire:model.blur="title">
</form><pre><code>&lt;!-- ... --&gt;

&lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;

&lt;button type=&quot;button&quot; wire:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;

&lt;div wire:loading wire:target=&quot;save, remove&quot;&gt;  &lt;!-- [tl! highlight:2] --&gt;
    Updating post...
&lt;/div&gt;
</code></pre>

```
<p>The loading indicator (&quot;Updating post...&quot;) will now only be shown when the &quot;Remove&quot; or &quot;Save&quot; button are pressed, and not when the <code>$title</code> field is being sent to the server.</p>
<h3 id="targeting-action-parameters">Targeting action parameters</h3>
<p>In situations where the same action is triggered with different parameters from multiple places on a page, you can further scope <code>wire:target</code> to a specific action by passing in additional parameters. For example, consider the following scenario where a &quot;Remove&quot; button exists for each post on the page:</p>
<pre class="hljs"><code><div>&lt;div&gt;
    @foreach ($posts as $post)
        &lt;div wire:key=&quot;{{ $post-&gt;id }}&quot;&gt;
            &lt;h2&gt;{{ $post-&gt;title }}&lt;/h2&gt;

            &lt;button wire:click=&quot;remove({{ $post-&gt;id }})&quot;&gt;Remove&lt;/button&gt;

            &lt;div wire:loading wire:target=&quot;remove({{ $post-&gt;id }})&quot;&gt;  &lt;!-- [tl! highlight:2] --&gt;
                Removing post...
            &lt;/div&gt;
        &lt;/div&gt;
    @endforeach
&lt;/div&gt;
</div></code></pre>
<p>Without passing <code>{{ $post-&gt;id }}</code> to <code>wire:target=&quot;remove&quot;</code>, the &quot;Removing post...&quot; message would show when any of the buttons on the page are clicked.</p>
<p>However, because we are passing in unique parameters to each instance of <code>wire:target</code>, Livewire will only show the loading message when the matching parameters are passed to the &quot;remove&quot; action.</p>
<h3 id="targeting-property-updates">Targeting property updates</h3>
<p>Livewire also allows you to target specific component property updates by passing the property's name to the <code>wire:target</code> directive.</p>
<p>Consider the following example where a form input named <code>username</code> uses <code>wire:model.live</code> for real-time validation as a user types:</p>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;input type=&quot;text&quot; wire:model.live=&quot;username&quot;&gt;
    @error('username') &lt;span&gt;{{ $message }}&lt;/span&gt; @enderror

    &lt;div wire:loading wire:target=&quot;username&quot;&gt; &lt;!-- [tl! highlight:2] --&gt;
        Checking availability of username...
    &lt;/div&gt;

    &lt;!-- ... --&gt;
&lt;/form&gt;
</div></code></pre>
<p>The &quot;Checking availability...&quot; message will show when the server is updated with the new username as the user types into the input field.</p>
<h2 id="customizing-css-display-property">Customizing CSS display property</h2>
<p>When <code>wire:loading</code> is added to an element, Livewire updates the CSS <code>display</code> property of the element to show and hide the element. By default, Livewire uses <code>none</code> to hide and <code>inline-block</code> to show.</p>
<p>If you are toggling an element that uses a display value other than <code>inline-block</code>, like <code>flex</code> in the following example, you can append <code>.flex</code> to <code>wire:loading</code>:</p>
<pre class="hljs"><code><div>&lt;div class=&quot;flex&quot; wire:loading.flex&gt;...&lt;/div&gt;
</div></code></pre>
<p>Below is the complete list of available display values:</p>
<pre class="hljs"><code><div>&lt;div wire:loading.inline-flex&gt;...&lt;/div&gt;
&lt;div wire:loading.inline&gt;...&lt;/div&gt;
&lt;div wire:loading.block&gt;...&lt;/div&gt;
&lt;div wire:loading.table&gt;...&lt;/div&gt;
&lt;div wire:loading.flex&gt;...&lt;/div&gt;
&lt;div wire:loading.grid&gt;...&lt;/div&gt;
</div></code></pre>
<h2 id="delaying-a-loading-indicator">Delaying a loading indicator</h2>
<p>On fast connections, updates often happen so quickly that loading indicators only flash briefly on the screen before being removed. In these cases, the indicator is more of a distraction than a helpful affordance.</p>
<p>For this reason, Livewire provides a <code>.delay</code> modifier to delay the showing of an indicator. For example, if you add <code>wire:loading.delay</code> to an element like so:</p>
<pre class="hljs"><code><div>&lt;div wire:loading.delay&gt;...&lt;/div&gt;
</div></code></pre>
<p>The above element will only appear if the request takes over 200 milliseconds. The user will never see the indicator if the request completes before then.</p>
<p>To customize the amount of time to delay the loading indicator, you can use one of Livewire's helpful interval aliases:</p>
<pre class="hljs"><code><div>&lt;div wire:loading.delay.shortest&gt;...&lt;/div&gt; &lt;!-- 50ms --&gt;
&lt;div wire:loading.delay.shorter&gt;...&lt;/div&gt;  &lt;!-- 100ms --&gt;
&lt;div wire:loading.delay.short&gt;...&lt;/div&gt;    &lt;!-- 150ms --&gt;
&lt;div wire:loading.delay&gt;...&lt;/div&gt;          &lt;!-- 200ms --&gt;
&lt;div wire:loading.delay.long&gt;...&lt;/div&gt;     &lt;!-- 300ms --&gt;
&lt;div wire:loading.delay.longer&gt;...&lt;/div&gt;   &lt;!-- 500ms --&gt;
&lt;div wire:loading.delay.longest&gt;...&lt;/div&gt;  &lt;!-- 1000ms --&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: wire-model.md
```md

Livewire makes it easy to bind a component property's value with form inputs using `wire:model`.

Here is a simple example of using `wire:model` to bind the `$title` and `$content` properties with form inputs in a &quot;Create Post&quot; component:

```php
use Livewire\Component;
use App\Models\Post;

class CreatePost extends Component
{
    public $title = '';

    public $content = '';

    public function save()
    {
		$post = Post::create([
			'title' =&gt; $this-&gt;title
			'content' =&gt; $this-&gt;content
		]);

        // ...
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt;
    &lt;label&gt;
        &lt;span&gt;Title&lt;/span&gt;

        &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt; &lt;!-- [tl! highlight] --&gt;
    &lt;/label&gt;

    &lt;label&gt;
        &lt;span&gt;Content&lt;/span&gt;

        &lt;textarea wire:model=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;!-- [tl! highlight] --&gt;
    &lt;/label&gt;

	&lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>Because both inputs use <code>wire:model</code>, their values will be synchronized with the server's properties when the &quot;Save&quot; button is pressed.</p>
<blockquote>
<p>[!warning] &quot;Why isn't my component live updating as I type?&quot;
If you tried this in your browser and are confused why the title isn't automatically updating, it's because Livewire only updates a component when an &quot;action&quot; is submitted—like pressing a submit button—not when a user types into a field. This cuts down on network requests and improves performance. To enable &quot;live&quot; updating as a user types, you can use <code>wire:model.live</code> instead. <a href="/docs/properties#data-binding">Learn more about data binding</a>.</p>
</blockquote>
<h2 id="customizing-update-timing">Customizing update timing</h2>
<p>By default, Livewire will only send a network request when an action is performed (like <code>wire:click</code> or <code>wire:submit</code>), NOT when a <code>wire:model</code> input is updated.</p>
<p>This drastically improves the performance of Livewire by reducing network requests and provides a smoother experience for your users.</p>
<p>However, there are occasions where you may want to update the server more frequently for things like real-time validation.</p>
<h3 id="live-updating">Live updating</h3>
<p>To send property updates to the server as a user types into an input-field, you can append the <code>.live</code> modifier to <code>wire:model</code>:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">wire:model.live</span>=<span class="hljs-string">"title"</span>&gt;</span>
</div></code></pre>
<h4 id="customizing-the-debounce">Customizing the debounce</h4>
<p>By default, when using <code>wire:model.live</code>, Livewire adds a 150 millisecond debounce to server updates. This means if a user is continually typing, Livewire will wait until the user stops typing for 150 milliseconds before sending a request.</p>
<p>You can customize this timing by appending <code>.debounce.Xms</code> to the input. Here is an example of changing the debounce to 250 milliseconds:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">wire:model.live.debounce.250ms</span>=<span class="hljs-string">"title"</span>&gt;</span>
</div></code></pre>
<h3 id="updating-on-%22blur%22-event">Updating on &quot;blur&quot; event</h3>
<p>By appending the <code>.blur</code> modifier, Livewire will only send network requests with property updates when a user clicks away from an input, or presses the tab key to move to the next input.</p>
<p>Adding <code>.blur</code> is helpful for scenarios where you want to update the server more frequently, but not as a user types. For example, real-time validation is a common instance where <code>.blur</code> is helpful.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">wire:model.blur</span>=<span class="hljs-string">"title"</span>&gt;</span>
</div></code></pre>
<h3 id="updating-on-%22change%22-event">Updating on &quot;change&quot; event</h3>
<p>There are times when the behavior of <code>.blur</code> isn't exactly what you want and instead <code>.change</code> is.</p>
<p>For example, if you want to run validation every time a select input is changed, by adding <code>.change</code>, Livewire will send a network request and validate the property as soon as a user selects a new option. As opposed to <code>.blur</code> which will only update the server after the user tabs away from the select input.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">wire:model.change</span>=<span class="hljs-string">"title"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- ... --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
</div></code></pre>
<p>Any changes made to the text input will be automatically synchronized with the <code>$title</code> property in your Livewire component.</p>
<h2 id="all-available-modifiers">All available modifiers</h2>
<table>
<thead>
<tr>
<th>Modifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.live</code></td>
<td>Send updates as a user types</td>
</tr>
<tr>
<td><code>.blur</code></td>
<td>Only send updates on the <code>blur</code> event</td>
</tr>
<tr>
<td><code>.change</code></td>
<td>Only send updates on the the <code>change</code> event</td>
</tr>
<tr>
<td><code>.lazy</code></td>
<td>An alias for <code>.change</code></td>
</tr>
<tr>
<td><code>.debounce.[?]ms</code></td>
<td>Debounce the sending of updates by the specified millisecond delay</td>
</tr>
<tr>
<td><code>.throttle.[?]ms</code></td>
<td>Throttle network request updates by the specified millisecond interval</td>
</tr>
<tr>
<td><code>.number</code></td>
<td>Cast the text value of an input to <code>int</code> on the server</td>
</tr>
<tr>
<td><code>.boolean</code></td>
<td>Cast the text value of an input to <code>bool</code> on the server</td>
</tr>
<tr>
<td><code>.fill</code></td>
<td>Use the initial value provided by a &quot;value&quot; HTML attribute on page-load</td>
</tr>
</tbody>
</table>
<h2 id="input-fields">Input fields</h2>
<p>Livewire supports most native input elements out of the box. Meaning you should just be able to attach <code>wire:model</code> to any input element in the browser and easily bind properties to them.</p>
<p>Here's a comprehensive list of the different available input types and how you use them in a Livewire context.</p>
<h3 id="text-inputs">Text inputs</h3>
<p>First and foremost, text inputs are the bedrock of most forms. Here's how to bind a property named &quot;title&quot; to one:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;
</div></code></pre>
<h3 id="textarea-inputs">Textarea inputs</h3>
<p>Textarea elements are similarly straightforward. Simply add <code>wire:model</code> to a textarea and the value will be bound:</p>
<pre class="hljs"><code><div>&lt;textarea type=&quot;text&quot; wire:model=&quot;content&quot;&gt;&lt;/textarea&gt;
</div></code></pre>
<p>If the &quot;content&quot; value is initialized with a string, Livewire will fill the textarea with that value - there's no need to do something like the following:</p>
<pre class="hljs"><code><div>&lt;!-- Warning: This snippet demonstrates what NOT to do... --&gt;

&lt;textarea type=&quot;text&quot; wire:model=&quot;content&quot;&gt;{{ $content }}&lt;/textarea&gt;
</div></code></pre>
<h3 id="checkboxes">Checkboxes</h3>
<p>Checkboxes can be used for single values, such as when toggling a boolean property. Or, checkboxes may be used to toggle a single value in a group of related values. We'll discuss both scenarios:</p>
<h4 id="single-checkbox">Single checkbox</h4>
<p>At the end of a signup form, you might have a checkbox allowing the user to opt-in to email updates. You might call this property <code>$receiveUpdates</code>. You can easily bind this value to the checkbox using <code>wire:model</code>:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;checkbox&quot; wire:model=&quot;receiveUpdates&quot;&gt;
</div></code></pre>
<p>Now when the <code>$receiveUpdates</code> value is <code>false</code>, the checkbox will be unchecked. Of course, when the value is <code>true</code>, the checkbox will be checked.</p>
<h4 id="multiple-checkboxes">Multiple checkboxes</h4>
<p>Now, let's say in addition to allowing the user to decide to receive updates, you have an array property in your class called <code>$updateTypes</code>, allowing the user to choose from a variety of update types:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> $updateTypes = [];
</div></code></pre>
<p>By binding multiple checkboxes to the <code>$updateTypes</code> property, the user can select multiple update types and they will be added to the <code>$updateTypes</code> array property:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;checkbox&quot; value=&quot;email&quot; wire:model=&quot;updateTypes&quot;&gt;
&lt;input type=&quot;checkbox&quot; value=&quot;sms&quot; wire:model=&quot;updateTypes&quot;&gt;
&lt;input type=&quot;checkbox&quot; value=&quot;notification&quot; wire:model=&quot;updateTypes&quot;&gt;
</div></code></pre>
<p>For example, if the user checks the first two boxes but not the third, the value of <code>$updateTypes</code> will be: <code>[&quot;email&quot;, &quot;sms&quot;]</code></p>
<h3 id="radio-buttons">Radio buttons</h3>
<p>To toggle between two different values for a single property, you may use radio buttons:</p>
<pre class="hljs"><code><div>&lt;input type=&quot;radio&quot; value=&quot;yes&quot; wire:model=&quot;receiveUpdates&quot;&gt;
&lt;input type=&quot;radio&quot; value=&quot;no&quot; wire:model=&quot;receiveUpdates&quot;&gt;
</div></code></pre>
<h3 id="select-dropdowns">Select dropdowns</h3>
<p>Livewire makes it simple to work with <code>&lt;select&gt;</code> dropdowns. When adding <code>wire:model</code> to a dropdown, the currently selected value will be bound to the provided property name and vice versa.</p>
<p>In addition, there's no need to manually add <code>selected</code> to the option that will be selected - Livewire handles that for you automatically.</p>
<p>Below is an example of a select dropdown filled with a static list of states:</p>
<pre class="hljs"><code><div>&lt;select wire:model=&quot;state&quot;&gt;
    &lt;option value=&quot;AL&quot;&gt;Alabama&lt;/option&gt;
    &lt;option value=&quot;AK&quot;&gt;Alaska&lt;/option&gt;
    &lt;option value=&quot;AZ&quot;&gt;Arizona&lt;/option&gt;
    ...
&lt;/select&gt;
</div></code></pre>
<p>When a specific state is selected, for example, &quot;Alaska&quot;, the <code>$state</code> property on the component will be set to <code>AK</code>. If you would prefer the value to be set to &quot;Alaska&quot; instead of &quot;AK&quot;, you can leave the <code>value=&quot;&quot;</code> attribute off the <code>&lt;option&gt;</code> element entirely.</p>
<p>Often, you may build your dropdown options dynamically using Blade:</p>
<pre class="hljs"><code><div>&lt;select wire:model=&quot;state&quot;&gt;
    @foreach (\App\Models\State::all() as $state)
        &lt;option value=&quot;{{ $state-&gt;id }}&quot;&gt;{{ $state-&gt;label }}&lt;/option&gt;
    @endforeach
&lt;/select&gt;
</div></code></pre>
<p>If you don't have a specific option selected by default, you may want to show a muted placeholder option by default, such as &quot;Select a state&quot;:</p>
<pre class="hljs"><code><div>&lt;select wire:model=&quot;state&quot;&gt;
    &lt;option disabled&gt;Select a state...&lt;/option&gt;

    @foreach (\App\Models\State::all() as $state)
        &lt;option value=&quot;{{ $option-&gt;id }}&quot;&gt;{{ $option-&gt;label }}&lt;/option&gt;
    @endforeach
&lt;/select&gt;
</div></code></pre>
<p>As you can see, there is no &quot;placeholder&quot; attribute for a select menu like there is for text inputs. Instead, you have to add a <code>disabled</code> option element as the first option in the list.</p>
<h3 id="dependent-select-dropdowns">Dependent select dropdowns</h3>
<p>Sometimes you may want one select menu to be dependent on another. For example, a list of cities that changes based on which state is selected.</p>
<p>For the most part, this works as you'd expect, however there is one important gotcha: You must add a <code>wire:key</code> to the changing select so that Livewire properly refreshes it's value when the options change.</p>
<p>Here's an example of two selects, one for states, one for cities. When the state select changes, the options in the city select will change properly:</p>
<pre class="hljs"><code><div>&lt;!-- States select menu... --&gt;
&lt;select wire:model.live=&quot;selectedState&quot;&gt;
    @foreach (State::all() as $state)
        &lt;option value=&quot;{{ $state-&gt;id }}&quot;&gt;{{ $state-&gt;label }}&lt;/option&gt;
    @endforeach
&lt;/select&gt;

&lt;!-- Cities dependent select menu... --&gt;
&lt;select wire:model.live=&quot;selectedCity&quot; wire:key=&quot;{{ $selectedState }}&quot;&gt; &lt;!-- [tl! highlight] --&gt;
    @foreach (City::whereStateId($selectedState-&gt;id)-&gt;get() as $city)
        &lt;option value=&quot;{{ $city-&gt;id }}&quot;&gt;{{ $city-&gt;label }}&lt;/option&gt;
    @endforeach
&lt;/select&gt;
</div></code></pre>
<p>Again, the only thing non-standard here is the <code>wire:key</code> that has been added to the second select. This ensures that when the state changes, the &quot;selectedCity&quot; value will be reset propertly.</p>
<h3 id="multi-select-dropdowns">Multi-select dropdowns</h3>
<p>If you are using a &quot;multiple&quot; select menu, Livewire works as expected. In this example, states will be added to the <code>$states</code> array property when they are selected and removed if they are deselected:</p>
<pre class="hljs"><code><div>&lt;select wire:model=&quot;states&quot; multiple&gt;
    &lt;option value=&quot;AL&quot;&gt;Alabama&lt;/option&gt;
    &lt;option value=&quot;AK&quot;&gt;Alaska&lt;/option&gt;
    &lt;option value=&quot;AZ&quot;&gt;Arizona&lt;/option&gt;
    ...
&lt;/select&gt;
</div></code></pre>
<h2 id="going-deeper">Going deeper</h2>
<p>For a more complete documentation on using <code>wire:model</code> in the context of HTML forms, visit the <a href="/docs/forms">Livewire forms documentation page</a>.</p>
<pre class="hljs"><code><div>
## File: wire-navigate.md
```md

Livewire's `wire:navigate` feature makes page navigation much faster, providing an SPA-like experience for your users.

This page is a simple reference for the `wire:navigate` directive. Be sure to read the [page on Livewire's Navigate feature](/docs/navigate) for more complete documentation.

Below is a simple example of adding `wire:navigate` to links in a nav bar:

```blade
&lt;nav&gt;
    &lt;a href=&quot;/&quot; wire:navigate&gt;Dashboard&lt;/a&gt;
    &lt;a href=&quot;/posts&quot; wire:navigate&gt;Posts&lt;/a&gt;
    &lt;a href=&quot;/users&quot; wire:navigate&gt;Users&lt;/a&gt;
&lt;/nav&gt;
</div></code></pre>
<p>When any of these links are clicked, Livewire will intercept the click and instead of allowing the browser to perform a full page visit, Livewire will fetch the page in the background and swap it with the current page (resulting in much faster and smoother page navigation).</p>
<h2 id="prefetching-pages-on-hover">Prefetching pages on hover</h2>
<p>By adding the <code>.hover</code> modifier, Livewire will pre-fetch a page when a user hovers over a link. This way, the page will have already been downloaded from the server when the user clicks on the link.</p>
<pre class="hljs"><code><div>&lt;a href=&quot;/&quot; wire:navigate.hover&gt;Dashboard&lt;/a&gt;
</div></code></pre>
<h2 id="going-deeper">Going deeper</h2>
<p>For more complete documentation on this feature, visit <a href="/docs/navigate">Livewire's navigate documentation page</a>.</p>
<pre class="hljs"><code><div>
## File: wire-offline.md
```md

In certain circumstances it can be helpful for your users to know if they are currently connected to the internet.

If for example, you have built a blogging platform on Livewire, you may want to notify your users in some way if they are offline so that they don't draft an entire blog post without the ability for Livewire to save it to the database.

Livewire make this trivial by providing the `wire:offline` directive. By attaching `wire:offline` to an element in your Livewire component, it will be hidden by default and only be displayed when Livewire detects the network connection has been interrupted and is unavailable. It will then disappear again when the network has regained connection.

For example:

```blade
&lt;p class=&quot;alert alert-warning&quot; wire:offline&gt;
    Whoops, your device has lost connection. The web page you are viewing is offline.
&lt;/p&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: wire-poll.md
```md
Polling is a technique used in web applications to &quot;poll&quot; the server (send requests on a regular interval) for updates. It's a simple way to keep a page up-to-date without the need for a more sophisticated technology like [WebSockets](/docs/events#real-time-events-using-laravel-echo).

## Basic usage

Using polling inside Livewire is as simple as adding `wire:poll` to an element.

Below is an example of a `SubscriberCount` component that shows a user's subscriber count:

```php
&lt;?php

namespace App\Livewire;

use Illuminate\Support\Facades\Auth;
use Livewire\Component;

class SubscriberCount extends Component
{
    public function render()
    {
        return view('livewire.subscriber-count', [
            'count' =&gt; Auth::user()-&gt;subscribers-&gt;count(),
        ]);
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div wire:poll&gt; &lt;!-- [tl! highlight] --&gt;
    Subscribers: {{ $count }}
&lt;/div&gt;
</div></code></pre>
<p>Normally, this component would show the subscriber count for the user and never update until the page was refreshed. However, because of <code>wire:poll</code> on the component's template, this component will now refresh itself every <code>2.5</code> seconds, keeping the subscriber count up-to-date.</p>
<p>You can also specify an action to fire on the polling interval by passing a value to <code>wire:poll</code>:</p>
<pre class="hljs"><code><div>&lt;div wire:poll=&quot;refreshSubscribers&quot;&gt;
    Subscribers: {{ $count }}
&lt;/div&gt;
</div></code></pre>
<p>Now, the <code>refreshSubscribers()</code> method on the component will be called every <code>2.5</code> seconds.</p>
<h2 id="timing-control">Timing control</h2>
<p>The primary drawback of polling is that it can be resource intensive. If you have a thousand visitors on a page that uses polling, one thousand network requests will be triggered every <code>2.5</code> seconds.</p>
<p>The best way to reduce requests in this scenario is simply to make the polling interval longer.</p>
<p>You can manually control how often the component will poll by appending the desired duration to <code>wire:poll</code> like so:</p>
<pre class="hljs"><code><div>&lt;div wire:poll.15s&gt; &lt;!-- In seconds... --&gt;

&lt;div wire:poll.15000ms&gt; &lt;!-- In milliseconds... --&gt;
</div></code></pre>
<h2 id="background-throttling">Background throttling</h2>
<p>To further cut down on server requests, Livewire automatically throttles polling when a page is in the background. For example, if a user keeps a page open in a different browser tab, Livewire will reduce the number of polling requests by 95% until the user revisits the tab.</p>
<p>If you want to opt-out of this behavior and keep polling continuously, even when a tab is in the background, you can add the <code>.keep-alive</code> modifier to <code>wire:poll</code>:</p>
<pre class="hljs"><code><div>&lt;div wire:poll.keep-alive&gt;
</div></code></pre>
<h2 id="viewport-throttling">Viewport throttling</h2>
<p>Another measure you can take to only poll when necessary, is to add the <code>.visible</code> modifier to <code>wire:poll</code>. The <code>.visible</code> modifier instructs Livewire to only poll the component when it is visible on the page:</p>
<pre class="hljs"><code><div>&lt;div wire:poll.visible&gt;
</div></code></pre>
<p>If a component using <code>wire:visible</code> is at the bottom of a long page, it won't start polling until the user scrolls it into the viewport. When the user scrolls away, it will stop polling again.</p>
<pre class="hljs"><code><div>
## File: wire-stream.md
```md

Livewire allows you to stream content to a web page before a request is complete via the `wire:stream` API. This is an extremely useful feature for things like AI chat-bots which stream responses as they are generated.

&gt; [!warning] Not compatible with Laravel Octane
&gt; Livewire currently does not support using `wire:stream` with Laravel Octane.

To demonstrate the most basic functionality of `wire:stream`, below is a simple CountDown component that when a button is pressed displays a count-down to the user from &quot;3&quot; to &quot;0&quot;:

```php
use Livewire\Component;

class CountDown extends Component
{
    public $start = 3;

    public function begin()
    {
        while ($this-&gt;start &gt;= 0) {
            // Stream the current count to the browser...
            $this-&gt;stream(  // [tl! highlight:4]
                to: 'count',
                content: $this-&gt;start,
                replace: true,
            );

            // Pause for 1 second between numbers...
            sleep(1);

            // Decrement the counter...
            $this-&gt;start = $this-&gt;start - 1;
        };
    }

    public function render()
    {
        return &lt;&lt;&lt;'HTML'
        &lt;div&gt;
            &lt;button wire:click=&quot;begin&quot;&gt;Start count-down&lt;/button&gt;

            &lt;h1&gt;Count: &lt;span wire:stream=&quot;count&quot;&gt;{{ $start }}&lt;/span&gt;&lt;/h1&gt; &lt;!-- [tl! highlight] --&gt;
        &lt;/div&gt;
        HTML;
    }
}
</div></code></pre>
<p>Here's what's happening from the user's perspective when they press &quot;Start count-down&quot;:</p>
<ul>
<li>&quot;Count: 3&quot; is shown on the page</li>
<li>They press the &quot;Start count-down&quot; button</li>
<li>One second elapses and &quot;Count: 2&quot; is shown</li>
<li>This process continues until &quot;Count: 0&quot; is shown</li>
</ul>
<p>All of the above happens while a single network request is out to the server.</p>
<p>Here's what's happening from the system's perspective when the button is pressed:</p>
<ul>
<li>A request is sent to Livewire to call the <code>begin()</code> method</li>
<li>The <code>begin()</code> method is called and the <code>while</code> loop begins</li>
<li><code>$this-&gt;stream()</code> is called and immediately starts a &quot;streamed response&quot; to the browser</li>
<li>The browser receives a streamed response with instructions to find the element in the component with <code>wire:stream=&quot;count&quot;</code>, and replace its contents with the received payload (&quot;3&quot; in the case of the first streamed number)</li>
<li>The <code>sleep(1)</code> method causes the server to hang for one second</li>
<li>The <code>while</code> loop is repeated and the process of streaming a new number every second continues until the <code>while</code> condition is falsy</li>
<li>When <code>begin()</code> has finished running and all the counts have been streamed to the browser, Livewire finishes it's request lifecycle, rendering the component and sending the final response to the browser</li>
</ul>
<h2 id="streaming-chat-bot-responses">Streaming chat-bot responses</h2>
<p>A common use-case for <code>wire:stream</code> is streaming chat-bot responses as they are received from an API that supports streamed responses (like <a href="https://chat.openai.com/">OpenAI's ChatGPT</a>).</p>
<p>Below is an example of using <code>wire:stream</code> to accomplish a ChatGPT-like interface:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> <span class="hljs-title">Livewire</span>\<span class="hljs-title">Component</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatBot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>
</span>{
    <span class="hljs-keyword">public</span> $prompt = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $question = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> $answer = <span class="hljs-string">''</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submitPrompt</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;question = <span class="hljs-keyword">$this</span>-&gt;prompt;

        <span class="hljs-keyword">$this</span>-&gt;prompt = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">$this</span>-&gt;js(<span class="hljs-string">'$wire.ask()'</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">$this</span>-&gt;answer = OpenAI::ask(<span class="hljs-keyword">$this</span>-&gt;question, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($partial)</span> </span>{
            <span class="hljs-keyword">$this</span>-&gt;stream(to: <span class="hljs-string">'answer'</span>, content: $partial); <span class="hljs-comment">// [tl! highlight]</span>
        });
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&lt;&lt;&lt;'HTML'
        &lt;div&gt;
            &lt;section&gt;
                &lt;div&gt;ChatBot&lt;/div&gt;

                @if (<span class="hljs-subst">$question</span>)
                    &lt;article&gt;
                        &lt;hgroup&gt;
                            &lt;h3&gt;User&lt;/h3&gt;
                            &lt;p&gt;{{ <span class="hljs-subst">$question</span> }}&lt;/p&gt;
                        &lt;/hgroup&gt;

                        &lt;hgroup&gt;
                            &lt;h3&gt;ChatBot&lt;/h3&gt;
                            &lt;p wire:stream="answer"&gt;{{ <span class="hljs-subst">$answer</span> }}&lt;/p&gt; &lt;!-- [tl! highlight] --&gt;
                        &lt;/hgroup&gt;
                    &lt;/article&gt;
                @endif
            &lt;/section&gt;

            &lt;form wire:submit="submitPrompt"&gt;
                &lt;input wire:model="prompt" type="text" placeholder="Send a message" autofocus&gt;
            &lt;/form&gt;
        &lt;/div&gt;
        HTML;
    }
}
</span></div></code></pre>
<p>Here's what's going on in the above example:</p>
<ul>
<li>A user types into a text field labelled &quot;Send a message&quot; to ask the chat-bot a question.</li>
<li>They press the [Enter] key.</li>
<li>A network request is sent to the server, sets the message to the <code>$question</code> property, and clears the <code>$prompt</code> property.</li>
<li>The response is sent back to the browser and the input is cleared. Because <code>$this-&gt;js('...')</code> was called, a new request is triggered to the server calling the <code>ask()</code> method.</li>
<li>The <code>ask()</code> method calls on the ChatBot API and receives streamed response partials via the <code>$partial</code> parameter in the callback.</li>
<li>Each <code>$partial</code> gets streamed to the browser into the <code>wire:stream=&quot;answer&quot;</code> element on the page, showing the answer progressively reveal itself to the user.</li>
<li>When the entire response is received, the Livewire request finishes and the user receives the full response.</li>
</ul>
<h2 id="replace-vs-append">Replace vs. append</h2>
<p>When streaming content to an element using <code>$this-&gt;stream()</code>, you can tell Livewire to either replace the contents of the target element with the streamed contents or append them to the existing contents.</p>
<p>Replacing or appending can both be desirable depending on the scenario. For example, when streaming a response from a chatbot, typically appending is desired (and is therefore the default). However, when showing something like a count-down, replacing is more fitting.</p>
<p>You can configure either by passing the <code>replace:</code> parameter to <code>$this-&gt;stream</code> with a boolean value:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Append contents...</span>
<span class="hljs-keyword">$this</span>-&gt;stream(to: <span class="hljs-string">'target'</span>, content: <span class="hljs-string">'...'</span>);

<span class="hljs-comment">// Replace contents...</span>
<span class="hljs-keyword">$this</span>-&gt;stream(to: <span class="hljs-string">'target'</span>, content: <span class="hljs-string">'...'</span>, replace: <span class="hljs-keyword">true</span>);
</div></code></pre>
<p>Append/replace can also be specified at the target element level by appending or removing the <code>.replace</code> modifier:</p>
<pre class="hljs"><code><div>// Append contents...
&lt;div wire:stream=&quot;target&quot;&gt;

// Replace contents...
&lt;div wire:stream.replace=&quot;target&quot;&gt;
</div></code></pre>
<pre class="hljs"><code><div>
## File: wire-submit.md
```md

Livewire makes it easy to handle form submissions via the `wire:submit` directive. By adding `wire:submit` to a `&lt;form&gt;` element, Livewire will intercept the form submission, prevent the default browser handling, and call any Livewire component method.

Here's a basic example of using `wire:submit` to handle a &quot;Create Post&quot; form submission:

```php
&lt;?php

namespace App\Livewire;

use Livewire\Component;
use App\Models\Post;

class CreatePost extends Component
{
    public $title = '';

    public $content = '';

    public function save()
    {
        Post::create([
            'title' =&gt; $this-&gt;title,
            'content' =&gt; $this-&gt;content,
        ]);

        $this-&gt;redirect('/posts');
    }

    public function render()
    {
        return view('livewire.create-post');
    }
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;form wire:submit=&quot;save&quot;&gt; &lt;!-- [tl! highlight] --&gt;
    &lt;input type=&quot;text&quot; wire:model=&quot;title&quot;&gt;

    &lt;textarea wire:model=&quot;content&quot;&gt;&lt;/textarea&gt;

    &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</div></code></pre>
<p>In the above example, when a user submits the form by clicking &quot;Save&quot;, <code>wire:submit</code> intercepts the <code>submit</code> event and calls the <code>save()</code> action on the server.</p>
<blockquote>
<p>[!info] Livewire automatically calls <code>preventDefault()</code>
<code>wire:submit</code> is different than other Livewire event handlers in that it internally calls <code>event.preventDefault()</code> without the need for the <code>.prevent</code> modifier. This is because there are very few instances you would be listening for the <code>submit</code> event and NOT want to prevent it's default browser handling (performing a full form submission to an endpoint).</p>
</blockquote>
<blockquote>
<p>[!info] Livewire automatically disables forms while submitting
By default, when Livewire is sending a form submission to the server, it will disable form submit buttons and mark all form inputs as <code>readonly</code>. This way a user cannot submit the same form again until the initial submission is complete.</p>
</blockquote>
<h2 id="going-deeper">Going deeper</h2>
<p><code>wire:submit</code> is just one of many event listeners that Livewire provides. The following two pages provide much more complete documentation on using <code>wire:submit</code> in your application:</p>
<ul>
<li><a href="/docs/actions">Responding to browser events with Livewire</a></li>
<li><a href="/docs/forms">Creating forms in Livewire</a></li>
</ul>
<pre class="hljs"><code><div>
## File: wire-transition.md
```md

## Basic usage

Showing or hiding content in Livewire is as simple as using one of Blade's conditional directives like `@if`. To enhance this experience for your users, Livewire provides a `wire:transition` directive that allows you to transition conditional elements smoothly in and out of the page.

For example, below is a `ShowPost` component with the ability to toggle viewing comments on and off:

```php
use App\Models\Post;

class ShowPost extends Component
{
    public Post $post;

    public $showComments = false;
}
</div></code></pre>
<pre class="hljs"><code><div>&lt;div&gt;
    &lt;!-- ... --&gt;

    &lt;button wire:click=&quot;$set('showComments', true)&quot;&gt;Show comments&lt;/button&gt;

    @if ($showComments)
        &lt;div wire:transition&gt; &lt;!-- [tl! highlight] --&gt;
            @foreach ($post-&gt;comments as $comment)
                &lt;!-- ... --&gt;
            @endforeach
        &lt;/div&gt;
    @endif
&lt;/div&gt;
</div></code></pre>
<p>Because <code>wire:transition</code> has been added to the <code>&lt;div&gt;</code> containing the post's comments, when the &quot;Show comments&quot; button is pressed, <code>$showComments</code> will be set to <code>true</code> and the comments will &quot;fade&quot; onto the page instead of abruptly appearing.</p>
<h2 id="limitations">Limitations</h2>
<p>Currently, <code>wire:transition</code> is only supported on a single element inside a Blade conditional like <code>@if</code>. It will not work as expected when used in a list of sibling elements. For example, the following will NOT work properly:</p>
<pre class="hljs"><code><div>&lt;!-- Warning: The following is code that will not work propertly --&gt;
&lt;ul&gt;
    @foreach ($post-&gt;comments as $comment)
        &lt;li wire:transition wire:key=&quot;{{ $comment-&gt;id }}&quot;&gt;{{ $comment-&gt;content }}&lt;/li&gt;
    @endforeach
&lt;/ul&gt;
</div></code></pre>
<p>If one of the above comment <code>&lt;li&gt;</code> elements were to get removed, you would expect Livewire to transition it out. However, because of hurdles with Livewire's underlying &quot;morph&quot; mechanism, this will not be the case. There is currently no way to transition dynamic lists in Livewire using <code>wire:transition</code>.</p>
<h2 id="default-transition-style">Default transition style</h2>
<p>By default, Livewire applies both an opacity and a scale CSS transition to elements with <code>wire:transtion</code>. Here's a visual preview:</p>
<div x-data="{ show: false }" x-cloak class="border border-gray-700 rounded-xl p-6 w-full flex justify-between">
    <a href="#" x-on:click.prevent="show = ! show" class="py-2.5 outline-none">
        Preview transition <span x-text="show ? &apos;out&apos; : &apos;in &#x2192;&apos;">in</span>
    </a>
    <div class="hey">
        <div x-show="show" x-transition class="inline-flex px-16 py-2.5 rounded-[10px] bg-pink-400 text-white uppercase font-medium transition focus-visible:outline-none focus-visible:!ring-1 focus-visible:!ring-white" style="
                background: linear-gradient(109.48deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.1) 100%), #EE5D99;
                box-shadow: inset 0px -1px 0px rgba(0, 0, 0, 0.5), inset 0px 1px 0px rgba(255, 255, 255, 0.1);
            ">
            &#xA0;
        </div>
    </div>
</div>
<p>The above transition uses the following values for transitioning by default:</p>
<table>
<thead>
<tr>
<th>Transition in</th>
<th>Transition out</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>duration: 150ms</code></td>
<td><code>duration: 75ms</code></td>
</tr>
<tr>
<td><code>opacity: [0 - 100]</code></td>
<td><code>opacity: [100 - 0]</code></td>
</tr>
<tr>
<td><code>transform: scale([0.95 - 1])</code></td>
<td><code>transform: scale([1 - 0.95])</code></td>
</tr>
</tbody>
</table>
<h2 id="customizing-transitions">Customizing transitions</h2>
<p>To customize the CSS Livewire internally uses when transitioning, you can use any combination of the available modifiers:</p>
<table>
<thead>
<tr>
<th>Modifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.in</code></td>
<td>Only transition the element &quot;in&quot;</td>
</tr>
<tr>
<td><code>.out</code></td>
<td>Only transition the element &quot;out&quot;</td>
</tr>
<tr>
<td><code>.duration.[?]ms</code></td>
<td>Customize the transtion duration in milliseconds</td>
</tr>
<tr>
<td><code>.duration.[?]s</code></td>
<td>Customize the transtion duration in seconds</td>
</tr>
<tr>
<td><code>.delay.[?]ms</code></td>
<td>Customize the transtion delay in milliseconds</td>
</tr>
<tr>
<td><code>.delay.[?]s</code></td>
<td>Customize the transtion delay in seconds</td>
</tr>
<tr>
<td><code>.opacity</code></td>
<td>Only apply the opacity transition</td>
</tr>
<tr>
<td><code>.scale</code></td>
<td>Only apply the scale transition</td>
</tr>
<tr>
<td><code>.origin.[top\|bottom\|left\|right]</code></td>
<td>Customize the scale &quot;origin&quot; used</td>
</tr>
</tbody>
</table>
<p>Below is a list of various transition combinations that may help to better visualize these customizations:</p>
<p><strong>Fade-only transition</strong></p>
<p>By default Livewire both fades and scales the element when transitioning. You can disable scaling and only fade by adding the <code>.opacity</code> modifier. This is useful for things like transitioning a full-page overlay, where adding a scale doesn't make sense.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:transition.opacity</span>&gt;</span>
</div></code></pre>
<div x-data="{ show: false }" x-cloak class="border border-gray-700 rounded-xl p-6 w-full flex justify-between">
    <a href="#" x-on:click.prevent="show = ! show" class="py-2.5 outline-none">
        Preview transition <span x-text="show ? &apos;out&apos; : &apos;in &#x2192;&apos;">in</span>
    </a>
    <div class="hey">
        <div x-show="show" x-transition.opacity class="inline-flex px-16 py-2.5 rounded-[10px] bg-pink-400 text-white uppercase font-medium transition focus-visible:outline-none focus-visible:!ring-1 focus-visible:!ring-white" style="
                background: linear-gradient(109.48deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.1) 100%), #EE5D99;
                box-shadow: inset 0px -1px 0px rgba(0, 0, 0, 0.5), inset 0px 1px 0px rgba(255, 255, 255, 0.1);
            ">
            ...
        </div>
    </div>
</div>
<p><strong>Fade-out transition</strong></p>
<p>A common transition technique is to show an element immediately when transitioning in, and fade its opacity when transitioning out. You'll notice this effect on most native MacOS dropdowns and menus. Therefore it's commonly applied on the web to dropdowns, popovers, and menus.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:transition.out.opacity.duration.200ms</span>&gt;</span>
</div></code></pre>
<div x-data="{ show: false }" x-cloak class="border border-gray-700 rounded-xl p-6 w-full flex justify-between">
    <a href="#" x-on:click.prevent="show = ! show" class="py-2.5 outline-none">
        Preview transition <span x-text="show ? &apos;out&apos; : &apos;in &#x2192;&apos;">in</span>
    </a>
    <div class="hey">
        <div x-show="show" x-transition.out.opacity.duration.200ms class="inline-flex px-16 py-2.5 rounded-[10px] bg-pink-400 text-white uppercase font-medium transition focus-visible:outline-none focus-visible:!ring-1 focus-visible:!ring-white" style="
                background: linear-gradient(109.48deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.1) 100%), #EE5D99;
                box-shadow: inset 0px -1px 0px rgba(0, 0, 0, 0.5), inset 0px 1px 0px rgba(255, 255, 255, 0.1);
            ">
            ...
        </div>
    </div>
</div>
<p><strong>Origin-top transition</strong></p>
<p>When using Livewire to transition an element such as a dropdown menu, it makes sense to scale in from the top of the menu as the origin, rather than center (Livewire's default). This way the menu feels visually anchored to the element that triggered it.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">wire:transition.scale.origin.top</span>&gt;</span>
</div></code></pre>
<div x-data="{ show: false }" x-cloak class="border border-gray-700 rounded-xl p-6 w-full flex justify-between">
    <a href="#" x-on:click.prevent="show = ! show" class="py-2.5 outline-none">
        Preview transition <span x-text="show ? &apos;out&apos; : &apos;in &#x2192;&apos;">in</span>
    </a>
    <div class="hey">
        <div x-show="show" x-transition.origin.top class="inline-flex px-16 py-2.5 rounded-[10px] bg-pink-400 text-white uppercase font-medium transition focus-visible:outline-none focus-visible:!ring-1 focus-visible:!ring-white" style="
                background: linear-gradient(109.48deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.1) 100%), #EE5D99;
                box-shadow: inset 0px -1px 0px rgba(0, 0, 0, 0.5), inset 0px 1px 0px rgba(255, 255, 255, 0.1);
            ">
            ...
        </div>
    </div>
</div>
<blockquote>
<p>[!tip] Livewire uses Alpine transitions behind the scenes
When using <code>wire:transition</code> on an element, Livewire is internally applying Alpine's <code>x-transition</code> directive. Therefore you can use most if not all syntaxes you would normally use with <code>x-transition</code>. Check out <a href="https://alpinejs.dev/directives/transition">Alpine's transition documentation</a> for all its capabilities.</p>
</blockquote>
<pre class="hljs"><code><div>
## File: rules/Casing rules.md
```md
Title case: &quot;This Is A Title&quot;
Sentance case: &quot;This is a sentance.&quot;
Bullet case: &quot;This is a bullet&quot;

</div></code></pre>
<h2 id="file-rulesreferencing-file-names-in-a-sentancemd">File: rules/Referencing file names in a sentance.md</h2>
<pre class="hljs"><code><div>A: "When run, Livewire will create a new file in your app, <span class="hljs-code">`app/Livewire/CreatePost.php`</span>, with the following contents:"

B: "When run, Livewire will create a new <span class="hljs-code">`app/Livewire/CreatePost.php`</span> file in your app, with the following contents:"

C: "When run, Livewire will create a file called <span class="hljs-code">`app/Livewire/CreatePost.php`</span>, with the following contents:"

C is preferred

</div></code></pre>
<h2 id="file-rulesexamplesmd">File: rules/examples.md</h2>
<pre class="hljs"><code><div><span class="hljs-bullet">
* </span>CreatePost
<span class="hljs-bullet">* </span>UpdatePost
<span class="hljs-bullet">* </span>ShowPosts
<span class="hljs-bullet">* </span>SearchPosts
<span class="hljs-bullet">* </span>TodoList
</div></code></pre>
<h2 id="file-rulesquestionsmd">File: rules/questions.md</h2>
<pre class="hljs"><code><div><span class="hljs-bullet">* </span>What to use as a dummy URL: 
<span class="hljs-bullet">    * </span>? <span class="hljs-code">`https://application.test/?page=2`</span>
</div></code></pre>
<h2 id="file-rulesrulesmd">File: rules/rules.md</h2>
<pre class="hljs"><code><div><span class="hljs-quote">&gt; When do you start a file with "&lt; ?php"</span>

<span class="hljs-quote">&gt; Always use tailwind in examples?  </span>

<span class="hljs-quote">&gt; Use active voice.</span>

<span class="hljs-quote">&gt; Use second-person singular ("You")</span>

<span class="hljs-quote">&gt; Sometimes you can introduce a concept with first-person plural ("We") and switch to "You" when giving step-by-step instructions</span>

<span class="hljs-quote">&gt; Always include import statements </span>

<span class="hljs-quote">&gt; Be consistant, but switch it up (tone, filler transition text, using colons)</span>

<span class="hljs-quote">&gt; Optimize for skimming (don't show "wrong" example first unless you have visual aid. People aint reading the words: this is wrong up-front)</span>


[[Referencing file names in a sentance]]
[[Casing rules]]
<span class="hljs-bullet">

* </span>Start with H2's, H1 will be the title of the page
<span class="hljs-bullet">* </span>Have good syntax highlighting, use Torchlight
<span class="hljs-bullet">* </span>Have good typography, use "prose" from tailwind
<span class="hljs-bullet">* </span>Write code examples first, then structure, then links and inlines, THEN paragraphs
<span class="hljs-bullet">* </span>Repeat yourself
<span class="hljs-bullet">    * </span>Write for a user to enter in anywhere and have context.
<span class="hljs-bullet">* </span>Concept of "beginning to end"
<span class="hljs-bullet">    * </span>Using "We" at beginning and transitioning to "You"
<span class="hljs-bullet">    * </span>Using more full code examples at the beginning




Blocks:
<span class="hljs-bullet">* </span>line break
<span class="hljs-bullet">* </span>tips
<span class="hljs-bullet">* </span>warnings
<span class="hljs-bullet">* </span>"go here to learn more"
<span class="hljs-bullet">* </span>check out the screencast here
<span class="hljs-bullet">* </span>Footer with more links

<span class="hljs-section">### Order by:</span>
<span class="hljs-bullet">* </span>Order from "generic" to "specific" (broad/niche)
<span class="hljs-bullet">* </span>Order from happy path to edge cases (or commonness of needs/usage)
<span class="hljs-bullet">* </span>Need for previous knowledge (one section might rely on another earlier section)

<span class="hljs-section">## Group by:</span>
<span class="hljs-bullet">* </span>Type of thing:
<span class="hljs-bullet">    * </span>ex. <span class="hljs-code">`wire:loading.class`</span> is extremely popular. <span class="hljs-code">`wire:loading.attr`</span> is not, however it should be placed immediately after <span class="hljs-code">`.class`</span> because it's so popular



</div></code></pre>
<p id="hidden_comment">
    This is a hidden comment. It explains that the following style tag is meant to 
    style HTML content if this Markdown is converted to HTML. This comment should 
    not be visible in most Markdown renderers.
</p>
<style>
    #hidden_comment {
        display: none;
    }
    table {
        width: 100%;
    }
    table tr:first-child {
        font-weight: bold;
    }
    table tr:last-child {
        font-style: italic;
    }
</style>

</body>
</html>
